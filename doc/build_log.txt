28-mar-2023:

Started designing emulation board (need better name!) last Sunday, just to
see if it's possible. As of today, added PSRAM (32MB), and changed to 1.8v
operation. Used the modified RP2040 minimal board as a starting point,
and also upgraded to Kicad 6. Some strangenesses observed...

Now on to Micro SD and VGA support.
SD card from "Hardware Design with RP2040" uses:
GPIO 18-22: SD card data bus 0 to 3
GPIO 5 SD clk
GPIO 18 SD cmd

Now, if we want to use SPI mode only, need to map into a SPI instance
(DAT1 and DAT2 not used).
That means SD_CMD needs to transform into SPIO_RX. One pin that can do this
is GPIO16.

uSD Pinouts:
     uSD   SPI
1    Dat2  NC
2    Dat3  CS
3    CMD   DI  (MOSI)
4    VDD   VDD
5    SCLK  SCLK
6    VCC   VCC
7    Dat0  DO  (MISO)
8    Dat1  NC


uSD conn  RP GPIO Function
1 SD_DAT2   GPIO21  (not used)
2 SD_DAT3   GPIO22  (used as GPIO to do CS function)
3 SD_CMD    GPIO16  SPIO_RX
4 3V3 
5 SD_CLK    GPIO18  SPIO_SCK
6 GND
7 SD_DAT0   GPIO19  SPIO_TX
8 SD_DAT1   GPIO20  (not used)


29-mar-2023:
Unfortunately, we need to operate the uSD card at 3.3v I/O levels. A single
channel voltage translator is $0.39, and an 8 channel 110 MHz is $1.06

Using:
Using Ti TXS0108, which has several second sources, in QFN package.

30-mar-2023:
Using Hirose DMD3D uSD card socket, as there is a KiCad footprint available.
Not the cheapest socket, but not too bad: $1.69.


Ethernet:
RMII project: https://github.com/maximeborges/pico-rmii-ethernet
Uses:
MDC
CRS_DV
RXD1
RXD0
MDIO
R_RXCLK
TXD0
TXD1
TXEN

Wiring
RMII Module 	Raspberry Pi Pico 	Library Default
TX1 	TX0 + 1 	11
TX-EN 	TX0 + 2 	12
TX0 	any GPIO 	10
RX0 	any GPIO 	6
RX1 	RX0 + 1 	7
nINT / RETCLK 	   21/23/24/25 	         21
CRS 	RX0 + 2 	8
MDIO 	any GPIO 	14
MDC 	MDIO + 1 	15
VCC 	3V3 	
GND 	GND

So, we need 9 GPIOs. Have 11, without audio. If we use PWM audio
(2 pins), then we'd make it. Could give up CK#, to do I2S (3 pin) audio.
The LAN8720A does have variable I/O voltage, so no level translation
needed!

Also, it appears that MDIO uses I2C protocol, so could share this...

But, no pins left to do video...

Digikey has no stock on LAN8720A. Looking at eth board, it appears that
pin 9 (VDDIO) is brought out to a via, so may be possible to modify...

Will have to modify to accept external 50MHz clock input, so that
RP2040 can drive it directly.

Ethernet costs:
LAN8720A:   1.37
Jack w/mag: 2.14 (no LEDs)

Amazon:
DWEII 2PCS LAN8720 board: $11, so $5.50 per board.

For now, design in a connector. Digikey shows stock of LAN8720A in late July.

Could do both: footprint and connector...

No video for this pass. Also, may not have enough PIO space to drive
video in addition to Hyperbus, RMII, and SDIO.

Need to re-jigger SDIO, given need to use the 3.3v GPIO pins. Note: this
precludes the use of hardware SPI, since SD_DAT0 must be on GPIO26, and
this is assigned to SPI1 SCK. (Wish there was a GPIO30, then we could
start the SD data bus on GPIO27). 

So:

uSD conn  uSD SPI  RP GPIO Function
1 SD_DAT2   NC     GPIO28  SPI1_RX
2 SD_DAT3   CS     GPIO29  SPI1_CS
3 SD_CMD    DI
4 3V3       3V3
5 SD_CLK    SCLK
6 GND       GND
7 SD_DAT0   DO     GPIO26  SPI1_SCK
8 SD_DAT1   NC     GPIO27  SPI1_TX


Still need at least four channels of voltage translation:
2 for uSD (clk & cmd), and 2 for SWD/SWCLK.

Future pin reduction: PSRAM RESET#. Could be done as a power on reset via
external circuitry. Could also tie to RP2040 RUN pin.

LAN8720A module connector:
1) TX1      2) IOVDD (with mod)
3) TX_EN    4) TX0
5) RX0      6) RX1
7) RefClk   8) CRS
9) GND     10) GND
11) 3v3    12) 3v3

Note: Need to modify Waveshare LAN8720A board to make RefClk input
instead of output, and to add IOVDD to pin 2.

GPIO assignment:
RMII Module 	   RP2040
RX0 	any GPIO   GPIO15
RX1 	RX0 + 1    GPIO16
CRS 	RX0 + 2    GPIO17

TX0 	any GPIO   GPIO18
TX1 	TX0 + 1    GPIO19
TX-EN 	TX0 + 2    GPIO20

nINT / RETCLK 	   GPIO21
MDIO 	any GPIO   GPIO22  I2C1_SDA
MDC 	MDIO + 1   GPIO23  I2C1_SCL

Remaining GPIOS: 13 & 14. If we move RESET# to 14, then we could add a
uart on 12 & 13 (UART 0).

31-mar-2023:

If we take the CK# and RESET# from the PSRAM, then we could do mono video
and single channel PWM sound.

Not sure if there's enough PIO program space though.
SD card, sdio (4bit):
From: https://github.com/ZuluSCSI/ZuluSCSI-firmware
https://github.com/ZuluSCSI/ZuluSCSI-firmware/blob/main/lib/ZuluSCSI_platform_RP2040/rp2040_sdio.pio
_sdio.pio: sm0: 18, sm1: 5 + 9 = 14
 Exactly 32! No room for anything else on one state machine instance. It
 looks like there are actually two instances, each with their own 32 instruction
 memory. Yes, this is the case: pio0 has 32 locations and 4 sms, and pio1 the
 same.
Ethernet, RMII:
From: https://github.com/maximeborges/pico-rmii-ethernet
phy_tx.pio: 10 instructions
phy_rx.pio: 7 instructions
2 sm instances
Audio, PDM:
PDM.pio from https://github.com/tierneytim/Pico-USB-audio: 1 PIO instruction
I2S:
https://github.com/raspberrypi/pico-extras/blob/master/src/rp2_common/pico_audio_i2s/audio_i2s.pio
8 instructions
SPDIF:
4 instructions
Video: VGA:
https://github.com/raspberrypi/pico-extras/blob/master/src/common/pico_scanvideo/scanvideo.pio
32 instructions!
https://github.com/HughMaingauche/PICO-VGA-Micropython/blob/main/VGA.py
hsync: 9
vsync: 14
out: 8
total: 31
3 sm instances

If we used only hardware PWM for audio, that could help. 

Breakdown:
PIO/SMs  function #inst
0/0, 1   SDIO     32
1/0, 1   RMII     17
1/2      SPDIF    4
or
1/2      PWDM     1

Can we do video in 14 instructions?
Yes, with the help of DMA chaining! Use pixel out SM to do basic timing.
But, we'd most likely conflict with system timing, since we can't use
the fractional PIO clock divider (would lead to asymmetric pixels).

Could use the following system clocks:
MHz Enet Div
100 1
125 1.25
150 1.5
175 1.75
200 2

None of these are VGA pixel clocks. 150 is close to 148.5 (1920x1080p).

1-apr-2023:

Found:

Note that at Mouser, can get double density for the same price. So,
32 MB for $3 or 64 MB for $6? They are footprint compatible, so late
binding decision. (Digikey prices are 2x, and have limitied octal spi parts)
Octal SPI removes need for clk#, and reset# is optional, so gets back two
pins. Also, there are DQM, allowing for masked writes. Could be good for
graphics.

Etherenet repo:
https://github.com/maximeborges/pico-rmii-ethernet

5-apr-2023:
Going with the Octal SPI part, even though digikey doesn't have it. Arrow lists
it, but has no stock. $4.59 for 512Mbit. Only in-stock part is 128Mbit for 3.81.

Octal SPI frees up ck# pin, and reset# can be driven by an RC network.
This gives four pins available. If we use these as debug port, then
we can skip the 1.8v to 3.3v translator. $1.57 for TSSOP, $1.05 for VQFN
at digikey.

Going to keep this version simple, so no video/audio.

Oops! Re-reading the RP2040 datasheet:

It is safe to supply ADC_AVDD at a higher or lower voltage than IOVDD, e.g.
to power the ADC at 3.3V, for optimum performance, while supporting 1.8V
signal levels on the digital IO. But the voltage on the ADC analogue inputs must
not exceed IOVDD, e.g. if IOVDD is powered at 1.8V, the voltage on the ADC inputs should be limited to 1.8V. Voltages greater than IOVDD will result in leakage
currents through the ESD protection diodes. See Section 5.2.3, “Pin
Specifications” for details.

So, the scheme of using ADC I/O at 3.3v doesn't work. Do need the translator
for interfacing to the SD card. This will use 6 of the 8 available
translation circuits. Could use the remaining two for the SWD interface,
removing the need to have a 1.8v SWD programmer.

Need to re-jigger GPIO assignments, to allow SPI to drive SD card. (See above).

Think we should jumper SWD pins to enable selection between them and
UART. Then we can have a 1.8v UART, or 1.8v SWD. (Use one copy to debug
the other...)

Further refinements:
Put jumper on reset# to select between LED and reset#. Also enables use as
an external GPIO. Maybe GPIO25 for Pico compatibility. A green LED has a 2.0v
threshold, a rohm sample has 1.8v for yellow. Still seems like a good idea
to put a resistor in series (for current limiting), just in case. 

So:
SD card:
1 SD_DAT2   GPIO21  (not used)
2 SD_DAT3   GPIO22  (used as GPIO to do CS function)
3 SD_CMD    GPIO16  SPIO_RX
4 3V3 
5 SD_CLK    GPIO18  SPIO_SCK
6 GND
7 SD_DAT0   GPIO19  SPIO_TX
8 SD_DAT1   GPIO20  (not used)

and:

RMII Module 	Raspberry Pi Pico 	Library Default
TX1 	TX0 + 1 	11
TX-EN 	TX0 + 2 	12
TX0 	any GPIO 	10
RX0 	any GPIO 	6
RX1 	RX0 + 1 	7
nINT / RETCLK 	   21/23/24/25 	         21
CRS 	RX0 + 2 	8
MDIO 	any GPIO 	14
MDC 	MDIO + 1 	15
VCC 	3V3 	
GND 	GND

Rationalizing with PSRAM using GPIO0 to GPIO10:
TX0 	any GPIO 	13
TX1 	TX0 + 1 	14
TX-EN 	TX0 + 2 	15
nINT / RETCLK 	        24
RX0 	any GPIO 	25
RX1 	RX0 + 1 	26
CRS 	RX0 + 2 	27

MDIO 	any GPIO 	28 (I2C0 SDA)
MDC 	MDIO + 1 	29 (I2C0 SCL)

And
UART0 TX 12
UART0 RX 17


LED/reset# 23

6-apr-2023:

Ok, a layout attempt with the above gpio allocation really didn't look good.
The RMII TX0, 1, _EN are on the opposite side of the RP2040, and would
require circumnavigating the whole chip. These are high speed signals,
and would interfere with other signals. Also, the jumpering of SWD/UART0
creates routing problems...

Reorganizing GPIOs:
Push the SD card down, move the reset/led pin back.

SD card:
1 SD_DAT2   GPIO17  (not used)
2 SD_DAT3   GPIO18  (used as GPIO to do CS function)
3 SD_CMD    GPIO12  SPI1_RX
4 3V3 
5 SD_CLK    GPIO14  SPI1_SCK
6 GND
7 SD_DAT0   GPIO15  SPI1_TX
8 SD_DAT1   GPIO16  (not used)



7-apr-2023:

Finalizing layout. Need to align the three 3 pin jumper blocks:

JP2:
X: 113.11 mm
Y: 106.975

Conn J5 (gnd)
X: 115.65
Y: 106.975

JP1:
X: 118.19
Y: 106.975

Holes:
H1:
X: 73.19
Y: 74

H4:
X: 73.19
Y: 117.18

H2:
X: 117.29
Y: 74

H3:
X: 117.29
Y: 117.18

J6:
X: 78.25
Y: 118

J7:
X: 87.65
Y: 118

Move to:
X: 88.41

8-apr-2023:

Finalized board last night, and sent off to JLCPCB.com! Also submitted a fixed
version of the HP display driver board (addressed the swapped source/drains on
the column MOSFET drivers). Final cost was: $9.84 for 10 boards, including
$3.84 for shipping. Amazing!

Final GPIO assignment:
Ethernet:
Signal  Requirement    GPIO  Alternate function
TX0 	any GPIO 	0    UART0 TX/I2C0 SDA/SPI0 RX
TX1 	TX0 + 1 	1    UART0 RX/I2C0 SCL/SPI0 CSn
TX-EN 	TX0 + 2 	2    I2C1 SDA/SPI0 SCK

RX0 	any GPIO 	3    I2C1 SCL/SPI0 TX
RX1 	RX0 + 1 	4    UART1 TX/I2C0 SDA/SPI0 RX
CRS 	RX0 + 2 	5    UART1 RX/I2C0 SCL/SPI0 CSn

nINT / RETCLK 	        21 (Must be a RP2040 clock output, i.e. 21, 23, 24, 25)

MDIO 	any GPIO 	6    I2C1 SDA/SPI0 SCK
MDC 	MDIO + 1 	7    I2C1 SCL/SPI0 TX

SD Card:
Signal        
SDIO       SPI       Requirement   GPIO  Alternate function
1 SD_DAT2  (N/C)     SD_DAT1 + 1    13   SPI1 CSn
2 SD_DAT3  CS        SD_DAT2 + 1    14   SPI1 SCK
3 SD_CMD   RX (MOSI) any GPIO       8    SPI1 RX
4 3V3 
5 SD_CLK   SCK       any GPIO       10   SPI1 SCK
6 GND
7 SD_DAT0  TX (MISO) any GPIO       11   SPI1 TX
8 SD_DAT1  (N/C)     SD_DAT0 + 1    12   SPI1 RX

PSRAM:
Signal  Requirement    GPIO
DQ0     any GPIO       19
DQ1     DQ0 + 1        22 (FAIL! Violated the requirement)
DQ2     DQ1 + 1        23
DQ3     DQ2 + 1        24
DQ4     DQ3 + 1        25
DQ5     DQ4 + 1        26
DQ6     DQ5 + 1        27
DQ7     DQ6 + 1        28
CK      any GPIO       29
CS#
RWDS
CK#     (pulled down to gnd via 10K resistor)
RESET#  (pulled up to +1v8 via 10K resistor)

UART:
Signal  Requirement     GPIO   Function
TX      RP2040 UART TX  16     UART0TX
RX      RP2040 UART RX  17     UART0RX

GPIO
Signal  Requirement     GPIO   Function
0       any GPIO        9      UART1 Rx/I2C0 SDA
1       any GPIO        15     UART0 RTS/I2C1 SCL

OK, so two failures seen on the light of day:
1) SD Card SPI mode won't work: conflict between SPI RX and SD card SPI RX,
   and same for TX. Should have been RX->TX, and TX->RX.

2) PSRAM DQ0 not sequential with remaining DQS...

Need to do a spin...

First, reconfigure pinout:
Must use GPIO22 to 29 as DQ bus. CK will have to be on GPIO18. Messy.

SD Card:
Signal        
SDIO       SPI       Requirement   GPIO  Alternate function
1 SD_DAT2  (N/C)     SD_DAT1 + 1    14   
2 SD_DAT3  CS        SD_DAT2 + 1    15   SPI1 TX (Use as GPIO)
3 SD_CMD   RX (MOSI) any GPIO       11   SPI1 TX
4 3V3 
5 SD_CLK   SCK       any GPIO       10   SPI1 SCK 
6 GND
7 SD_DAT0  TX (MISO) any GPIO       12   SPI1 RX
8 SD_DAT1  (N/C)     SD_DAT0 + 1    13   


From: 
https://github.com/ZuluSCSI/ZuluSCSI-firmware/blob/main/lib/ZuluSCSI_platform_RP2040/ZuluSCSI_platform_gpio_BS2.h
// SD card pins in SDIO mode
#define SDIO_CLK 10
#define SDIO_CMD 11
#define SDIO_D0  12
#define SDIO_D1  13
#define SDIO_D2  14
#define SDIO_D3  15

// SD card pins in SPI mode
#define SD_SPI       spi0
#define SD_SPI_SCK   10
#define SD_SPI_MOSI  11
#define SD_SPI_MISO  12
#define SD_SPI_CS    15

(The SD_SPI #define looks questionable - should be spi1, according to the
RP2040 datasheet).

Note: was able to modify the Waveshare LAN8720 board to put IOVDD on pin 2 (the
previous NC pin), and change the clocking to external (remove the two 33 ohm
resistors, and put one across the two vacated pads next to the chip).

9-apr-2023:

Using https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico.git as a test
with a ltm board wired up as above.

git clone -b sdio --recurse-submodules https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico.git no-OS-FatFS


from the README:
Customize:

    Configure the code to match the hardware: see section Customizing for the Hardware Configuration, below.
    Customize ff14a/source/ffconf.h as desired
    Customize pico_enable_stdio_uart and pico_enable_stdio_usb in CMakeLists.txt as you prefer. (See 4.1. Serial input and output on Raspberry Pi Pico in Getting started with Raspberry Pi Pico and 2.7.1. Standard Input/Output (stdio) Support in Raspberry Pi Pico C/C++ SDK.)

Figured out how to change default UART pins:

Put this in the CMakeLists.txt, just before "target sources", changing exe name:


# Enable different UART pin definitions
target_compile_definitions(simple_example PRIVATE
  PICO_DEFAULT_UART_TX_PIN=16
  PICO_DEFAULT_UART_RX_PIN=17
)

Success! Running command_line example:
> mount
> getfree                                                                       
    258095 KiB total drive space.                                               
    202925 KiB available.                                                       
                                                                                
> cat LICENCE.broadcom                                                          
Copyright (c) 2006, Broadcom Corporation.                                       
Copyright (c) 2015, Raspberry Pi (Tradary form, without                         
modification, are permitted provided that the following condiy only be used for 
  running or using a Raspbeivative                                              
  device manufactured via the element14 Raspberry Pi Customization Serv* Rediste
  following rovided with the distribution.                                      
* Neither the name of Broadcom Corporation nor t this software                  
  without specific prior written permission.                                    
                                                                                
DISCLAIMER.  THDED BY THE COPYRIGHT HOLDERS AND                                 
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIUDING,                             
BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND               
FITNESS FOR A NT SHALL THE                                                      
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECTNSEQUENTIAL D,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GODS OR SERVICES; LOSS            
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEIN CONTRACT, STRICT LIAR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISUSE OF THIS SOFTWARE, EVEN IF ADVIH
DAMAGE.                                                                         
                                                                                
                                                                                
> 

Now to try the SDIO mode...

11-apr-2023:
Finally, success! Not sure what it took - perhaps powercycling all of the
components?

Oturing date: 11/2013

FILE_SIZE_MB = 5
BUF_SIZE = 20480
Starting write test,latency
speed,max,min,avg
KB/Sec,usec,usec,usec
                                                           
2849.4,17019,6457,7181
                                                          
2858.7,14090,6583,7160
Starting read test, please wait.
read speed and late4761.9,4702,4070,4300
4766.3,4696,4063,4298
Done

Really need to get a better version of picoprobe - apparently, servicing
the USB uart and the SWD port leads to dropped characters.
(Maybe use both cores?!)

29-apr-2023:


Rev 1.1 Final pinouts:
Ethernet:
Signal  Requirement    GPIO  Alternate function
TX0 	any GPIO 	0    UART0 TX/I2C0 SDA/SPI0 RX
TX1 	TX0 + 1 	1    UART0 RX/I2C0 SCL/SPI0 CSn
TX-EN 	TX0 + 2 	2    I2C1 SDA/SPI0 SCK

RX0 	any GPIO 	3    I2C1 SCL/SPI0 TX
RX1 	RX0 + 1 	4    UART1 TX/I2C0 SDA/SPI0 RX
CRS 	RX0 + 2 	5    UART1 RX/I2C0 SCL/SPI0 CSn

nINT / RETCLK 	        21 (Must be a RP2040 clock output, i.e. 21, 23, 24, 25)

MDIO 	any GPIO 	6    I2C1 SDA/SPI0 SCK
MDC 	MDIO + 1 	7    I2C1 SCL/SPI0 TX

SD Card:
Signal        
SDIO       SPI       Requirement   GPIO  Alternate function
1 SD_DAT2  (N/C)     SD_DAT1 + 1    14   
2 SD_DAT3  CS        SD_DAT2 + 1    15   SPI1 TX (Use as GPIO)
3 SD_CMD   RX (MOSI) any GPIO       11   SPI1 TX
4 3V3 
5 SD_CLK   SCK       any GPIO       10   SPI1 SCK 
6 GND
7 SD_DAT0  TX (MISO) any GPIO       12   SPI1 RX
8 SD_DAT1  (N/C)     SD_DAT0 + 1    13   

PSRAM:
Signal  Requirement    GPIO
DQ0     any GPIO       22
DQ1     DQ0 + 1        23
DQ2     DQ1 + 1        24
DQ3     DQ2 + 1        25
DQ4     DQ3 + 1        26
DQ5     DQ4 + 1        27
DQ6     DQ5 + 1        28
DQ7     DQ6 + 1        29
CK      any GPIO       18
CS#     any GPIO       19
RWDS    any GPIO       20
CK#     (pulled down to gnd via 10K resistor)
RESET#  (pulled up to +1v8 via 10K resistor)

UART:
Signal  Requirement     GPIO   Function
TX      RP2040 UART TX  16     UART0TX
RX      RP2040 UART RX  17     UART0RX

GPIO
Signal  Requirement     GPIO   Function
0       any GPIO        8      UART1 TX/I2C0 SDA
1       any GPIO        9      UART1 RX/I2C0 SCL

20-may-2023:


Figured out how to build custom stage two rp2040 boot loader. CMakfile:

# Select different boot_stage2 file
#set(PICO_DEFAULT_BOOT_STAGE2_FILE $ENV{PICO_SDK_PATH}/src/rp2_common/boot_stage2/boot2_usb_blinky.S)
#set(PICO_DEFAULT_BOOT_STAGE2_FILE $ENV{PWD}/boot_stage2/boot2_usb_blinky.S)
set(PICO_DEFAULT_BOOT_STAGE2_FILE $ENV{PWD}/boot_stage2/w25q80.S)
pico_define_boot_stage2(slower_boot2 ${PICO_DEFAULT_BOOT_STAGE2_FILE})
#target_compile_definitions(slower_boot2 PRIVATE PICO_FLASH_SPI_CLKDIV=4)
pico_set_boot_stage2(blink slower_boot2)

Verified with modified boot2_usb_blinky.S:
.thumb_func
_stage2_boot:
    add r0, r0, #2	
    b _stage2_boot

telnet devel0 4444

Trying 192.168.1.54...
Connected to devel0.light.com.
Escape character is '^]'.
Open On-Chip Debugger
> halt
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x20041f00 msp: 0x20041ee8
> reg r0
r0 (/32): 0x79db8072

> resume
> halt
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00000138 msp: 0x20041f00
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x20041f00 msp: 0x20041ee8
> reg r0
r0 (/32): 0x7f80ff40

OpenOCD memory read commands
mrb address
      Returns value of byte in memory. (command valid any time)
mrh address
      Returns value of halfword in memory. (command valid any time)
mrw address
      Returns value of word in memory. (command valid any time)

Before mod:
> mrw 0x40020000
0
> 

After adding at line 120:
    movs r0, #PADS_QSPI_VOLTAGE_SELECT_VALUE_1V8
    str r0, [r3, #PADS_QSPI_VOLTAGE_SELECT_OFFSET]

> mrw 0x40020000
1
>

Still doesn't boot. Trying the boot2_generic_03h.S file... Hurray, works!
Now have figure out why our W25Q64JW part doesn't work with the W25q080
rpi boot2 code. FYI, we did boot with a W25Q40CLSNIG (after modifying the
board to use 3.3v).

Modifying boot2_generic_03h.S to set threshold to 1.8v:
Before:
> mrw 0x40020000
0

Adding at line 22:
#include "hardware/regs/pads_qspi.h"

Adding at line 67:
    // Set pad configuration:
    // - 1.8v threshold for VDD of 1.8v	(20-may-2023 RS)
    ldr r3, =PADS_QSPI_BASE
    movs r0, #PADS_QSPI_VOLTAGE_SELECT_VALUE_1V8
    str r0, [r3, #PADS_QSPI_VOLTAGE_SELECT_OFFSET]

After mod:
> mrw 0x40020000
1
>

21-may-2023:

Found in picoboot sources:
#define ROM_START   0x00000000
#define ROM_END     0x00004000
#define FLASH_START 0x10000000
#define FLASH_END   0x11000000 // this is maximum
#define XIP_SRAM_BASE 0x15000000
#define XIP_SRAM_END 0x15004000

Apparently bricked board - didn't respond to openocd. Rebooting board in
dfu mode and reprogramming with standard blink allowed openocd to work
once again.

Ok, finally figured out problem: The W25Q64JW does not support "Continuous
Read Mode", while the W25Q64FW does. Digikey shows no stock for the F variant.

Phrase to look for is something like:
Allows XiP (eXecute In Place) Operation
- High speed Read reduce overall XiP instruction fetch time
- Continuous Read with Wrap further reduce data latency to
fill up SoC cache 

In stock digikey part is: GD25Q64E (has above phrase in datasheet). But it
is 2.7 to 3.6V supply. The GD25LQ64E is 1.65 to 2.0V, and is in stock.
Placed order for 10 parts. Will use boot2_generic_03 to do debugging for
now.


Also, we can support other boards via:
 cmake -DPICO_BOARD=shawns_board_name ..
See also:
https://github.com/raspberrypi/pico-sdk/blob/master/src/boards/include/boards/adafruit_feather_rp2040.h

Still having problems with board, even with generic flash code. Learning how
to use RAM only builds, and load with openocd load_image command.

Magic needed:
CMakeLists.txt:
cmake_minimum_required(VERSION 3.12)
include($ENV{PICO_SDK_PATH}/pico_sdk_init.cmake)

project(blink)

pico_sdk_init()

# source goes here
add_subdirectory(./src)

# Enable SRAM only executable
pico_set_binary_type(blink no_flash)

And a shell script with:
echo -e "reset halt\nload_image /home/rscott/$filename\nresume 0x20000000" | ncat devel0 4444

(with openocd running on devel0, of course...)

Works on both boards. Can also leave flash boot jumper installed, as openocd
doesn't care...

22-may-2023:
Got ID reads to work:

ID0: 0e860e86                                                                   
ID0.Row Address Bit Count: 01110                                                
  15 row address bits                                                           
ID0.Column Address Bit Count: 1000                                              
  9 column address bits                                                         
ID0.Manufacturer: 0110                                                          
  Windbond                                                                      

Thus, many of the PSRAM pins were toggled, so maybe the BGA soldering
was successful. Need to do an acutal read/write test to be sure...

One interesting thing to note: register reads are MSByte first:
// From the data sheet, pg. 13:
//   For register read, the output data Dn A is RG[15:8], Dn B is RG[7:0],
//   Dn+1 A is RG[15:8], Dn+1 B is RG[7:0]
// So, we must byte swap the returned data

23-may-2023:
Got PSRAM memory reads and writes working.

FYI:
32K Rows of 1KB = 32 MB.

Full 32MB memory test passing:

Pass: 0 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 1 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 2 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 3 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 4 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 5 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 6 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 7 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 8 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 9 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR        
Pass: 10 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR       
Pass: 11 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR

Coding bugs encountered:
1) Didn't realize that latency during writes affected when the writes begin. I.e.
when the latency count expires, writes will be performed! Also had a bug where
the latency counter reversed clock high and low assertions, causing the
first write to be delayed.
2) Masked too much of the PSRAM address. Caused half of memory to not be
available.
3) Didn't fully realize that PSRAM addresses memory as words. It assumes
that 16 bits are always transferred per clock.

Enabled variable latency mode, and shortened latency count. Still passes
memory test.

So, while wondering about how the HyperRAM deals with row crossings during
writes, this popped up from the datasheet:

During the write data transfers, RWDS is driven by the host master interface
as a data mask. When data is being written and RWDS is High the byte will be
masked and the array will not be altered. When data is being written and RWDS is
Low the data will be placed into the array. Because the master is driving RWDS
during write data transfers, neither the master nor the HyperRAM device is able
to indicate a need for latency within the data transfer portion of a write
transaction. The acceptable write data burst length setting is also shown in
configuration register 0.

Strictly speaking then - we must limit bursts to 128 B, as shown in
config 0. (Probably should also program this as well). I'm guessing there's
a 128 B write buffer in the PSRAM.

25-may-2023


So, reading the data sheet shows that commands/data  must have setup/hold times
around the clock. For 133 MHz parts, this is 0.8 ns. Also, read data
is strobed by RWDS, which driven by the part. It has setup/hold times of:
0.6 ns. The delay from clock to RWDS is 1 to 5.5ns.

So, order of operations for read data:
Generate clock rising edge
Sample RWDS
If set:
  Read databus for this edge (ph0)
  Generate clock falling edge
  Read databus (ph1)
  Done with read
else
  Generate clock falling edge
  Go back to start

So, with input pin mapping set to RWDS, side set RWDS, CD, CLK

  nop             1
sample:
  in pins, 1      1  ; Get RWDS
  mov X, ISR      1  ; Set up to test it
  jmp !X, DV      1  ; If not zero, data is valid
  jmp sample      0  ; Zero, so assert clock and sample again
DV:
  mov X, pins     1  ; Use output mapping to fetch data bus pins
  in X, 8         0  ; Accumulate them, setup to get ph1
  mov X, pins     0  ; Get ph1
  in X, 8         0

If we assume that burst length is limited, and we don't cross PSRAM row
boundaries, then can sample RWDS at beginning of cycle. The data read
routine would then look like:

  nop             1   ; Set up clock for ph0
  mov X, pins     1   ; Get ph0 data <31:24>
  in X, 8         0   ; Accumulate data, setup for ph1
  mov X, pins     0   ; Get ph1 data <23:16>
  in X, 8         1   ; Accumulate, set up for next ph0
  mov X, pins     1   ; Get ph0 data <15:08>
  in X, 8         0   ; Accumulate data, setup for ph1
  mov X, pins     0   ; Get ph1 data <07:00>
  in X, 8         2   ; Accumulate, and rase CE with clock low to end cycle


This gives setup from clock edge to data sample. Presumably, RP2040 can deal
with effectively no data hold time...

So, if we use the wrap around read mode, we'd never cross a row boundary. But
we'd always have to use a "cache-fill" model for block reads.

29-may-2023:


Reading more PIO code on the net, discovered that the JMP instruction can
jump on the state of a pin set via: EXECCTRL_JMP_PIN. This provides
a more convienent method of monitoring the RWDS pin...

So:
; In/Out/Mov instruction GPIO pin mapping
; <7:0> - PSRAM data

; SET instruction GPIO pin mapping
; 0 - RDWS

; EXECCTL GPIO pin mapping
; 0 - RWDS
psram:
    pull           side 2     ; Wait for input with clock low, CE high
    out ISR, 1     side 0     ; Get R/W flag, assert CE (1 = read)
    mov Y, ISR     side 0     ; Save flag
    out NULL, 5    side 0     ; Skip over unused address bits
    set X, 0x1     side 0     ; Set linear operation bit
    in X, 2        side 0     ; Should now have either 0x04 (rd) or 0x5 (wr)
    in NULL, 5     side 0     ; Make into 0xA0 or 0x20
    mov PINS, ISR  side 0     ; Output CR0, ph0
    out X, 7       side 1     ; Get address bits 25:19, latch ph0
    mov PINS, X    side 1     ; Output CR0, ph1
    out X, 8       side 0     ; Get address bits 18:11, latch ph1
    mov PINS, X    side 0     ; Output CR1, ph0
    out X, 8       side 1     ; Get address bits 10:03, latch ph0
    mov PINS, X    side 1     ; Output CR1, ph1
    set X, 0       side 0     ; Set up CR2, ph0, latch ph1
    mov PINS, X    side 0     ; Output CR2, ph0
    out X, 3       side 1     ; Get address bits 02:00, latch ph0
    mov PINS, X    side 1     ; Output CR2, ph1
    mov X, 13      side 1     ; Set up for extended latency
    jmp !Y, read   side 1     ; Go to read trans, based on saved flag
    jmp RWDS, lat  side 1     ; Get extended latency input before falling clk
    pull           side 1     ; Wait for write data
    mov X, 6       side 1     ; Set up for normal latency
lat:
    nop            side 0     ; Tick off latency count
    jmp X--, lat   side 1
write:
    set PINDIR, 1  side 0     ; Make RWDS output, bump latency count
    set PINS, 0    side 1;    ; Don't mask PSRAM data, 
    mov PINDIR, ~NULL side 0  ; Make PSRAM data bus pins output
    out PINS, 8    side 1     ; 
    out PINS, 8    side 0
    out PINS, 8    side 1
    out PINS, 8    side 0	
    set PINDIR, 0  side 2     ; Make RWDS input, done with write
    set PINDIR, NULL side 2
    jmp psram

read:
    jmp RWDS, next side 1     ; Wait for latency pin to go high
    jmp read       side 0

next:
    in PINS, 8     side 0     ; Accumulate ph0 data, setup for ph1
    in PINS, 8     side 1     ; Accumulate ph1 data, setup for ph0
    in PINS, 8     side 0     ; Accumulate ph0 data, setup for ph1
    in PINS, 8     side 1     ; Accumulate ph1 data, setup for ph0
    push           side 2     ; Done with transaction
    jmp psram      side 2


Here's something interesting:
https://github.com/Wren6991/PicoDVI.git
There's a sub-project that includes hyperRAM support! Let's give it a shot...
Weird - git clone doesn't pickup all of the software subdirectory, but
downloading a zip does.
  
7-jun-2023:

Experimented with the Wren project (above) - a memtest showed intermittent
failures, even with reduced clock speed. Re-writing code now. Currently,
can read config registers and memory correctly, up to a clock divisor of 5.

8-jun-2023:

Note for the read/write packet format above: could make byte 9/8 (read/write
data length) a word to word align the packet header, as follows:

cfg-wr:
bytes:
0: <7:0> - next pc: 0 to go back to start
1: <7:0> - command length - 1: 3 for CMD/ADR and 16 bit data, so 4 uint16
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-9: cfg write data 0, 1
10-11: padding to fill out last uint32

write:
bytes:
0: <7:0> - next pc: "w_lat" to start write latency timer
1: <7:0> - command length - 1: 2 for CMD/ADR (3 uint16)
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-11: <31:0> - write data length -1 in 16 bit units
12 + len:  data to write to memory

read:
bytes:
0: <7:0> - next pc: "r_lat" to start write latency timer
1: <7:0> - command length - 1: 2 for CMD/ADR (3 uint16)
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-10: <23:0> - read data length -1 in 16 bit units
11: <7:0> - I/O Pad data direction (should be zero for input)

11-jun-2023:

Discovered problem with scheme to change the data direction of the data bus:
it doesn't account for write data in the FIFO getting pushed into the OSR
after a PIO program has completed. The problematic routine is:

public start: ;                  |||
     set PINDIRS, 0       side 0b100       ; Make RWDS pin input
     mov OSR, ~NULL       side 0b100
     out PINDIRS, 32      side 0b100       ; Set CMD/Data pins to output
     pull ifempty         side 0b100       ; Get length and next pc command

So, if the FIFO isn't empty when start is encountered (which might happen
if a PIO routine is executing and the processor pushes in the next PIO
command), then the word in the OSR will be overwritten by the MOV OSR
instruction.

Solutions:
1) Put explicit pull commands into code.
2) Put a byte in the command stream to control data bus direction at
the beginning of a command.
3) Break up into seperate state machines: one to do DDR writes, one for reads.

Thoughts on above:
1) Blows up code - would have to count bytes in inner DDR loops to know when
to do a 32 bit pull...
2) This is what Wren's code does. The thinking was that this caused the
occasional memory errors.
3) Doesn't lend itself to being DMA driven - e.g. would need seperate DMA
channels for reads/writes, and attendant synchronization issues.

I guess (2) seems like the best approach for now. New packet format:

cfg-wr:
bytes:
0: <7:0> - Data Direction: must be 0xff to write CMD/ADR
1: <7:0> - <7:5> - cmd len -1 (3), <4:0> next pc: 0 to go back to start
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-9: padding to align write data
10-11: cfg write data 0, 1 (big endian)

write:
bytes:
0: <7:0> - Data Direction: must be 0xff to write CMD/ADR
1: <7:0> - <7:5> - cmd len -1 (2), <4:0> next pc: "w_lat" to start write lat tmr
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-11: <31:0> - write data length -1 in 16 bit units
12 + len:  data to write to memory

read:
bytes:
0: <7:0> - Data Direction: must be 0xff to write CMD/ADR
1: <7:0> - <7:5> - cmd len -1 (2), <4:0> next pc: "r_lat" to start read lat tmr
2: <7:0> - CA 0
3: <7:0> - CA 1
4: <7:0> - CA 2
5: <7:0> - CA 3
6: <7:0> - CA 4
7: <7:0> - CA 5
8-10: <23:0> - read data length -1 in 16 bit units
11: <7:0> - I/O Pad data direction (should be zero for input)

Seems to work for reg reads/writes. Note, however, that we must
always write 32 bit words, otherwise, the OSR has data left over, and
that causes the next command to start with whatever was left (bad!).

A hack for the CMD writes would be to add a NOP to re-align the OSR.
Or, we could just write the same data twice. The latter should(!) be ok...

Sigh. There's some problem with the output fifo that causes repeated
write commands to go awry. So, let's refactor a bit:

Commands are composed of a command/address phase, followed by (optional)
latency phase, followed by data read or data write phase. Proposal:
make 32 bit FIFO commands that follow this. Must accomodate changing pin dirs.
Could also fix endian issue by re-formatting the cmd/adr phase from big to
little endian.

Once FIFO command is done, it returns to start

Note: all below assumes byte 0 is 31:24 (big endian)

Possible sequences are:
reg read:  idle -> cmd -> r_latency -> read data
reg write: idle -> cmd -> idle 
mem read:  idle -> cmd -> r_latency -> read data
mem write:  idle -> cmd -> w_latency -> write data

So from idle, we need the following:

Word 0:
byte 0: data pin dir
byte 1: cmd len (8 bits) [2 or 3]
byte 2: CA 0
byte 3: CA 1

Word 1:
byte 0: CA 2
byte 1: CA 3
byte 2: CA 4
byte 2: CA 5

<if len == 3>
Word 2:
byte 0: write data 0
byte 1: write data 1
byte 2: write data 2
byte 3: write data 3

Word 2/3:
byte 0: PIO address (8 bits) [idle, latency]
byte 1: padding
byte 2: padding
byte 3: padding

For latency command:
Word 0: 
byte 0: Data direction
byte 1: xfer length
byte 2: xfer pc [idle]
byte 3: next PIO address (8 bits) [w_data, r_data]

For data write:
none

Word 1 to length: data
none

So a register/memory read command looks like (big endian):
word 0: 0xff, <cmd_wr>, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: 0xff, <latency>, long, short
word 3: 0x00, <data_rd>, len h, len l

So a memory write command looks like (big endian):
word 0: 0xff, <cmd_wr>, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: 0xff, <latency>, 0, 0
word 3: 0xff, <data_wr>, len h, len l
word 4 to len: write data

So a register write command looks like (big endian):
word 0: 0xff, <cmd_wr>, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: 0xff, <data_wr>, len h, len l
word 3 to len: write data

12-jun-2023:

Finally fixed PIO code, and enabled the memory test to pass. Above
packet formats did change; will log them here, once I've tuned them
a bit further.

Now attempting to use 3 vs. default 7 latency timing.
Currently PIO latency clock is 11, giving 14 total latency clocks.
So, we have a fixed overhead of 3 clocks, so to get to a total of 6,
2x latency clock should be 3.

Wow! Changing the latency PIO value to 3 actually worked!

Debugged variable latency mode - memtest still passes.

With above changes, now down to 5us per 32 bit read, 4us per 32 bit write.

Leaving long memtest to run, at 2:00 pm. 5:30 pm, pass 164, no errors.

Optimizing packet formats:

So a register/memory read command looks like (big endian):
word 0: 0xff, cmd_len, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: xfer_len, 0x00, 0x00, r_lat

So a memory write command looks like (big endian):
word 0: 0xff, cmd_len, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: xfer_len, 0xff, 0xff, w_lat

So a register write command looks like (big endian):
word 0: 0xff, <cmd_wr>, CA 0, CA 1
word 1: CA 2, CA 3, CA 4, CA 5
word 2: write data (16 bits), write data (16 bits)
word 3: 0x00, 0x00, 0x00, start

Got to pass 310 without errors.

13-jun-2023:

After optimization, at clkdiv = 5:
Op size time    MB/s
rd 1    4 us    
wr 1    3 us
rd 8    5.5 us
wr 8    4.6 us

wd/us * 4 B/1 wrd * 1us/1e-6s * 1e-6MB/1B
1/4 wd/us = 4/4 = 1 MB/s
1/3 wd/us = 4/3 = 1.33 MB/s
8/5.5 wd/us = 8 * 4/5.5 = 5.82 MB/s
8/4.6 wd/us = 8 * 4/4.6 = 6.96 MB/s

This is at stock rp2040 clock. Using Wren's Pico DVI clock settings:
  vreg_set_voltage(VREG_VOLTAGE_1_20);
  sleep_ms(1);
  set_sys_clock_khz(252 * 1000, true);

Minimum clkdiv for passing memtest: 6
Op size time    MB/s
rd 1    1.1 us    
wr 1    0.872 ns
rd 8    2.5 us
wr 8    2.2 us

1/1.1 wd/us = 4/1.1 = 3.63 MB/s
1/0.872 wd/us = 4/0.872 = 4.58 MB/s
8/2.5 wd/us = 8 * 4/2.5 =  12.80 MB/s
8/2.2 wd/us = 8 * 4/2.2 =  14.54 MB/s

Falls well short of the potential 500 MB/s (peak, at 250 MHz) of the PSRAM.

With the above conditions, the cycle time of the RDWS read is: 100ns.
Thus we get a new byte every 50ns, or 20 MB/s

The board is populated with: Windbond W958D8NBYA4I. This is the highest perf
part: 250 MHz.

Decreasing the clk div with clk speed set to 250 shows that the RWDS stops
with a clkdiv of 2. Using default clk speed, clkdiv of 1 works.

CLK  DIV   RWDS
133  1     32ns
250  2     32ns
300  2     26.4ns
325  2     ---

So, it seems like we can send commands at these higher rates, but
can't read the response correctly.

Also note that the I/O level at 300 MHz is observed to be 1.0v. Should be 1.8v.

Experimenting with slew rate and drive strength...
 gpio_set_slew_rate(pin + off, GPIO_SLEW_RATE_SLOW)
 GPIO_SLEW_RATE_FAST GPIO_DRIVE_STRENGTH_8MA

No observed difference.

Experimenting with PSRAM drive strength... Very slight changes observed,
between nominal (34) and maximum drive (19 ohms).

Also saw that 315 MHz was one person's maximum RP2040 clock rate. Tried 325,
no response, but 315 does work, even with vreg not boosted. Leaving at
300 for now, so that the above measurements will be valid going forth.

Reading ID reg 1 to see where data shows up. ID1 is 0x0001, with address
0xc0000001.

Had to reflow the RP2040 pins, after too much probing of DQ0. Discovered
that the vreg boost really is needed after re-connecting the board, as
it wouldn't boot until the vreg was boosted.

Also soldered in W25Q80EWSSIG. Programmed/verified blink just fine (with
modified second stage boot loader), but blink failed to run.
Errors found when attempting to re-flash blinky via SWD:
Warn : target was in unknown state when halt was requested
Info : SWD DPIDR 0x0bc12477
Info : SWD DLPIDR 0x00000001
Error: error executing cortex_m crc algorithm
Error: checksum mismatch - attempting binary compare
Polling target rp2040.core0 failed, trying to reexamine
Info : SWD DPIDR 0x0bc12477
Info : SWD DLPIDR 0x00000001
Info : rp2040.core0: hardware has 4 breakpoints, 2 watchpoints
** Verify Failed **

Searching the config space shows that:
  // Works at 300 RP2040 clk speed, PSRAM latency 5, LATENCY = 5, LAT_SHORT = 2
  clkdiv = 7;

Clocks look clean on the scope as well.
Setting latency to 3 or 4 and LATENCY = 3 results in no RWDS when reading memory.
Setting latency to 3 or 4 and LATENCY = 4 results in one cycle delay RWDS.

Rejiggering the read data routine to sample when clock changes, vs.
one instruction after, allows us to run with clkdiv = 5, and 3 PSRAM latency.
Going further... 4 works, 3 works, 2 fails, with no RWDS. Increasing
LATENCY to 8/5 enables RWDS, but sampling is now mid-clock.

So, apparently the PSRAM has logic that saturates the requested
latency to the lowest acheivable. When experimenting above, 3-6
operate the same as 7. Which, actually, the datasheet indicates:
0000b - 5 Clock Latency @ 133MHz Max Frequency
0001b - 6 Clock Latency @ 166MHz Max Frequency
0010b - 7 Clock Latency @ 200MHz Max Frequency (default)
0010b - 7 Clock Latency @ 250MHz Max Frequency

So, it looks like clkdiv 3 is the max.

300/3 = 100, 100/4 = 25 MHz. => 50 MB/sec. (Peak, of course).

At this freq, PSRAM latency works as expected.

Starting long memtest at 9:20 pm.

14-jun-2023:


Long memtest failed:
Pass:   60 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRR                
RAM failure at 01405770 exp/act: 08ff7708 08ff7700                              
08ff7708 25de84e8 5d3c376a a1f24ac3 fde18c57 410a4623 300a7a45 971e5965         
00fbe7bd fd834edc 1f481af1 9ed0abbb ff564369 d0546675 cfc7ef39 763a130a   

Interesting to note that the second read does match the expected value. Perhaps
we need to lower the clock rate just a bit?

Fixing the short RAM test, and playing with buffer sizes, made the error
more prevailent:
Pass:    0 WRWRWRWRWRWR                                                         
RAM failure at 00500384 exp/act: 957c93c6 957c93e7                              
957c93e7 e78e58c5 be4b3f4f edf4c05f ca1c4ea1 3ac1a7e6 c9917ff9 2babb50f         
WR                                                                              
RAM failure at 00600150 exp/act: ec5b32ea ec5b32ca                              
ec5b32ca cac0caca a0a583c7 0b701e8a 1c8a019b cb90b728 73ceebd3 782f4daa         
WRWRWR                                                                          
RAM failure at 00900168 exp/act: 8a8413af 8a841316                              
8a841316 16cf0d38 1a66a70d 1e6b698f 180cb463 5e92f744 0f34985a 1bcd5ee6         
WR                                                                              
RAM failure at 00a003e4 exp/act: 1bc70014 1bc70083                              
1bc70083 837a4337 a884119a 7c5fdce2 7fb83f64 72c4ea8f 1d3ad5e6 00084043

Going to sysclk 250 didn't help. Nor did reverting to default (PSRAM clk: 10 MHz)

It's always the last byte. Is it the write or the read? Let's do a write once,
then read repeatedly test. Definitely read problem:

Pass:    0 WRR                                                                  
RAM failure at 0000028c exp/act: a3a48027 a3a48047                              
a3a48047 47af4718 46ce077f 42152990 03cc1a64 909b9ea5 8aa6af43 b692fc65         
a3a48027 47af4718 46ce077f 42152990 03cc1a64 909b9ea5 8aa6af43 b692fc65         
                                                                                
RAM failure at 000002c0 exp/act: 10e727c6 10e72777                              
10e72777 77ec24ea 9d52b713 bda6ebac 7ab82366 a44f5d8d b0259433 56dd5923         
10e727c6 77ec24ea 9d52b713 bda6ebac 7ab82366 a44f5d8d b0259433 56dd5923         
                                                                                
RAM failure at 00000360 exp/act: 9832deeb 9832debe                              
9832debe be143c9d 09778b9f f886e43e a427f1ff 191fa294 44e7d273 6b9449c8         
9832deeb be143c9d 09778b9f f886e43e a427f1ff 191fa294 44e7d273 6b9449c8         
                                                                                
RAM failure at 000003c0 exp/act: f9b837a8 f9b83716                              
f9b83716 16e449cf 64612202 44090053 e4691813 2a086f67 db770e36 6c8bbeaf         
f9b837a8 16e44964 64612202 44090053 e4691813 2a086f67 db770e36 6c8bbeaf

Second read shows that the bits were properly written. So, the last
byte is marginal for some reason...

Experimenting with burst size shows that for an 8 word (32 byte, 16 short),
errors present. 1, 2, 4 word bursts do not. Going to 4, increasing sysclk...
300 MHz works. Testing again at 8 fails, as does 5, 6, 7.

15-jun-2023:

Test failed yesterday:
Pass: 2778423 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR              
RAM failure at 019003bc exp/act: f7089b01 f7009b01                              
f7009b01 00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f         
f7009b01 00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f         
WRWRWRWRWRWR

Interesting that it was the 3rd byte this time.

Looks like falling edge sampling doesn't fully work.

Next, let's try using all of the available clocks, via clkdiv = 1. If we
use three instructions per phase, that'll allow us to move the sample
period a bit. So, 50 MHz PSRAM clk, or 100 MB/s peak.

So:
Entered with clock high for 2 ticks, 1 away from falling edge
public r_data:
     in PINS, 8           side 0b000       ; Get ph 0 data
     nop                  side 0b010   [1] ; Setup for ph 1
     in PINS, 8           side 0b010       ; Get ph 1 data
     jmp X--, r_data      side 0b000   [1] ; Setup for ph 0

So, further experimentation shows that pushing the in as far from
the leading clock edge is the most successful. Hold time must not
be the issue here.

Currently running long memtest with 300 MHz sysclk, divisor = 3, so
100 MHz effective, with each phase using 3 instructions, so 33 MB/s.

Fails with 200 MHz sysclk, div = 2, which should yeild the same 100 MHz
instruction rate. Weird...

public r_lat:
     nop                  side 0b000 [2]
lat_cnt:
     nop                  side 0b010 [2]
     jmp Y--, lat_cnt     side 0b000 [2]
     nop                  side 0b010
public r_data:
     nop                  side 0b010 
     in PINS, 8           side 0b011 ; Get data
     nop                  side 0b000    ; CA phase 0 
     nop                  side 0b000    ; CA phase 0 
     in PINS, 8           side 0b001  
     jmp X--, r_data      side 0b010    ; CA phase 1 write
     jmp start            side 0b000

Should try with each phase = 4 instructions, divisor = 2, sys

16-jun-2023:

Test ran overnight. Also thought of why it fails when running at 200 MHz/
div = 2: the processor is running 1/3 slower every time it gets a clock tick.
This means the time between assertion of clock and capture of data is shorter.

Re-wrote code to use more delay slots. Still can't get above 33 MB/s reliably.
Noted that a delay between CS assertion and command output is needed.

Trying to get 300 MHz sysclk with 6 ticks/phase to work. Experimented
with latency, but no difference. Seems like there's phase delay somewhere:

5 lat PSRAM, PIO LATENCY = 5/2 
id 0: 000e860e                                                                  
id 1: 86000100                                                                  
cfg 0: 01ff00ff                                                                 
cfg 1: 00ffddff                                                                 
00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f 6dc6a546         
01000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5         
a9000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5

4 lat PSRAM, PIO LATENCY = 4/1 
id 0: f00e860e                                                                  
id 1: 86000100                                                                  
cfg 0: 01fff0ff                                                                 
cfg 1: f0ffddff                                                                 
00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f 6dc6a546         
01000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5         
a9000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5

3 lat PSRAM, PIO LATENCY = 3/0 
id 0: e00e860e                                                                  
id 1: 86000100                                                                  
cfg 0: 01ffe0ff                                                                 
cfg 1: e0ffddff                                                                 
00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f 6dc6a546         
01000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5         
a9000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5         

In the above reading the written data portion, we see that the read
bytes are delayed by one byte from the written. Test with GPIO writes:

From GPIO psram_test:
Did not enter power down mode. CFG_0 act/exp: 8f2f 0000                         
ID0: 00000e86                                                                   
ID1: 00000001                                                                   
CFG0: 00008f2f                                                                  
CFG1: 0000ffc1                                                                  
Original CFG0: 0x8f2f                                                           
Writing to CFG0: 0xf0e0                                                         
Updated  CFG0: 0xffe0                                                           
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6

From psram_wren:
id 0: e00e860e                                                                  
id 1: 86000100                                                                  
cfg 0: 01ffe0ff                                                                 
cfg 1: e0ffc1ff                                                                 
00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f 6dc6a546         
01000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5         
a9000840 430804ac 242d8c3e 65e259a3 e6128416 75991534 51cc7e78 5f6dc6a5

So read problem, then.
PIO or PSRAM? Try returning a constant. Seems OK:
    set Y, 15             side 0b01 [3]
public r_data:
;     nop                  side 0b01 
     set pins, 2          side 0b01 
;     in PINS, 8           side 0b01        ; CA phase 0 
     in Y, 8           side 0b01        ; CA phase 0 
;     nop                  side 0b00 [2]    ; Setup for phase 1
     set pins, 0          side 0b00 [4] 
;     in PINS, 8           side 0b00        ; CA phase 1
     in x, 8           side 0b00        ; CA phase 0 
     jmp X--, r_data      side 0b01 [3]    ; Continue until all data captured 
     jmp start            side 0b00

id 0: 0f010f00                                                                  
id 1: 0f010f00                                                                  
cfg 0: 0f010f00                                                                 
cfg 1: 0f010f00

Also, passes at default clk freq, and 200 MHz. At 250 MHz, we see:

id 0: 08860e86                                                                  
id 1: 00010100                                                                  
cfg 0: 01e0e0e1                                                                 
cfg 1: e0c1c1c1                                                                 
00084043 0804ac24 2d8c3e65 e259a3e6 12841675 99153451 cc7e785f 6dc6a546         
005f1ddd d17806d0 00f34b22 0ad20a1a 081418c3 0b898166 20c6a655 49aa08a4         
475f1ddd d17806d0 00f34b22 0ad20a1a 081418c3 0b898166 20c6a655 49aa08a4
Pass:    0 WR                                                                   
RAM failure at 00000000 exp/act: 00084043 01084042                              
01084042 09040424 2c8c0c64 625823e6 12840474 19153450 417e785e 6dc6a446         
a1084042 09040424 2c8c0c65 625823e6 12840474 19153450 407e785e 6dc6a446

So, I think we're seeing the limitations of overclocking: the input
pads can't keep up with the incoming data past 33 MHz or so. I wonder
if I threw away the first pad read?

Verified that it's a read problem, by writing memory with PIO (big endian),
then reading back with GPIO (byte swapping):
Reading cfg 0: b6ffe0ff                                                         
Writing f0e0 to CR0 register                                                    
Reading cfg 0: e0ffe0ff                                                         
id 0: e00e860e                                                                  
id 1: 86000100                                                                  
cfg 0: 01ffe0ff                                                                 
cfg 1: e0ffc1ff                                                                 
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
01000840 4208008c 022998d8 826398b9 06e3b028 1a30d073 23e83583 59538f61         
b6000840 4208008c 022998d8 826398b9 06e3b028 1a30d073 23e83583 59538f61         
                                                                                
****Setup done                                                                  
Did not enter power down mode. CFG_0 act/exp: 8f2f 0000                         
ID0: 00000e86                                                                   
ID1: 00000001                                                                   
CFG0: 00008f2f                                                                  
CFG1: 0000ffc1                                                                  
Original CFG0: 0x8f2f                                                           
Writing to CFG0: 0xf0e0                                                         
Updated  CFG0: 0xffe0                                                           
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6

Perhaps going to the last edge sampling will help? As done above.
Certainly better:

id 0: 0e860e86                                                                  
id 1: 00010001                                                                  
cfg 0: ffe0ffe0                                                                 
cfg 1: ffc1ffc1                                                                 
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
Pass:    0 WR                                                                   
RAM failure at 000003d8 exp/act: e46ea3e9 e46ea332                              
e46ea332 3260e7e0 00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323         
e46ea3e9 3260e7e0 00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323         
WRWRWR                                                                          
RAM failure at 003002b4 exp/act: 869c6985 869c697e                              
869c697e 7e354633 089ae40a 00084042 08008c02 2998d882 6398b906 e3b0281a         
869c6985 7e354633 089ae40a 00084042 08008c02 2998d882 6398b906 e3b0281a         
WRWR                                                                            
RAM failure at 00500290 exp/act: ae2f2ba4 ae2f2b20                              
ae2f2b20 202a4f29 5024220e 58d48fbc 00084042 08008c02 2998d882 6398b906         
ae2f2ba4 202a4f29 5024220e 58d48fbc 00084042 08008c02 2998d882 6398b906

Now fails on last byte. See if we can move last byte sampling. Ok, this
shouldn't work, but marginally does:

     nop                  side 0b01 [5]

public r_data:
     in PINS, 8           side 0b00 [4]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [4]    ; Continue until all data captured 
     jmp start            side 0b00

Increasing the 4 to 5 enables passing short memtest. Clock is 23 MHz,
according to the scope. Pushing sysclk to 315 fails. Starting long
memtest @12:30 pm with 300 MHz... Failed at pass 11.

With the following code, gets 130 passes with long memtest:
;     nop                  side 0b01 [5]
; Trigger for scope
;     set pins 2           side 0b01
;     nop                  side 0b01 [3]
;     set pins 0           side 0b01
public r_data:
     set pins 2           side 0b01
     nop                  side 0b01 [4]
     set pins 0           side 0b01
     in PINS, 8           side 0b00 [5]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b00        ; Continue until all data captured 
     jmp start            side 0b00

Clock is 20 MHz, according to scope.

With previous code, changing 4 to 6, clk rate 21.37 MHz, long memtest running...
200 passes without error.

Optimizing...
public r_lat:
     nop                  side 0b00 [5]
lat_cnt:
     nop                  side 0b01 [5]
     jmp Y--, lat_cnt     side 0b00 [5]


;     nop                  side 0b01 [5]
; Trigger for scope
     set pins 2           side 0b01
     nop                  side 0b01 [3]
     set pins 0           side 0b01
     nop                  side 0b00 
public r_data:
     in PINS, 8           side 0b00 [5]    ; CA phase 0 
     in PINS, 8           side 0b01 [6]    ; CA phase 1
     jmp X--, r_data      side 0b00        ; Continue until all data captured 
     jmp start            side 0b00


17-jun-2023:

Long memory test ran overnight: pass 6094 as of 6:57 am.

PSRAM clock is 21.37 MHz, measured. So 42 MB/s peak.

Tried moving latency loop counter into main cmd code, but this isn't a
good idea: it'll cause extra writes when doing config register writes.

Ok, so ran short mem test, now fails:

cfg 1: ffc1ffc1                                                                 
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
Pass:    0 WRWR                                                                 
RAM failure at 00100278 exp/act: 03895500 0389550c                              
0389550c 0c017314 00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323         
03895500 0c017314 00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323         
WRWRWRWR                                                                        
RAM failure at 00500274 exp/act: 38ea6478 38ea64f8                              
38ea64f8 f8ce970a 6fd781bd 00084042 08008c02 2998d882 6398b906 e3b0281a         
38ea6478 f8ce970a 6fd781bd 00084042 08008c02 2998d882 6398b906 e3b0281a         
WRWR

Reverting back to earlier:

public r_data:
     in PINS, 8           side 0b00 [5]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [6]    ; Continue until all data captured 
     jmp start            side 0b10

enables passing short memory test once again. Mostly: failed at pass 45001.

Pass: 45001 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR                                  
RAM failure at 01000060 exp/act: 08fff788 08fff780                              
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e         
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e

Increased delay times by one tick, re-running. PSRAM clk is now: 18.66 MHz.

Looking at the above, perhaps this was a write failure?

Memtest is up to pass 1023000.

18-Jun-2023:

Memory test is up to 3611300. Too bad it's only 37 MB/s. 

750 ns between word reads.

Managed to boost speed just a tich: sysclk is now 21.2 MHz (scope).
Code:

; Trigger for scope
     set pins 2           side 0b00 [6]    ; Burn a latency clock
     set pins 0           side 0b01 [5]

public r_data:
     in PINS, 8           side 0b01 [0]    ; CA phase 0 
     nop                  side 0b00 [5]    ; Burn a latency clock
     in PINS, 8           side 0b00 [0]       ; CA phase 1
     jmp X--, r_data      side 0b01 [5]    ; Continue until all data captured 
     jmp start            side 0b10

The speed up is because we don't change the clock during the IN instruction.

So, now we get 42 MB/s.

Nope, fails at pass 45001 consistently:

d 0: 0e860e86                                          
id 1: 00010001                                          
cfg 0: ffe0ffe0                                         
cfg 1: ffc1ffc1                                         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
Pass: 45000 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 45001 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 01000060 exp/act: 08fff788 08fff780
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e
WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRSet sysclk to 300 MHz
pad bank0 voltage select addr/data: 4001c000 00000001
Loading program
Initialising state machine
Setting clock divisor to 1
Reading cfg 0: ffe0ffe0
Writing f0e0 to CR0 register
Reading cfg 0: ffe0ffe0
id 0: 0e860e86
id 1: 00010001
cfg 0: ffe0ffe0
cfg 1: ffc1ffc1
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
Pass: 45000 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 45001 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 01000060 exp/act: 08fff788 08fff780
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e
08fff780 37df1d6f 5a207d96 e7c07cbf e2aafa14 00ecb8e0 69ee9018 c654702e
WRWRWRWRWRWRWRWRWRWRWRWRWRWRWR

(Set the pass to 45000 in main.c)

Sigh. See note from 17-jun: same failure at 45001, with code that
changes clk during IN instruction, so above is simply wrong. There must be
some timing path we're hitting with this particular sequence of read data.

So, this works:
     in PINS, 8           side 0b01 [0]    ; CA phase 0 
     nop                  side 0b00 [6]    ; Burn a latency clock
     in PINS, 8           side 0b00 [0]       ; CA phase 1
     jmp X--, r_data      side 0b01 [5]    ; Continue until all data captured 
     jmp start            side 0b10

but this doesn't:
     in PINS, 8           side 0b01 [0]    ; CA phase 0 
     nop                  side 0b00 [5]    ; Burn a latency clock
     in PINS, 8           side 0b00 [0]       ; CA phase 1
     jmp X--, r_data      side 0b01 [6]    ; Continue until all data captured 
     jmp start            side 0b10

This also works, at 21 MHz sysclk:
     in PINS, 8           side 0b00 [6]    ; CA phase 0 
     in PINS, 8           side 0b00 [0]       ; CA phase 1
     jmp X--, r_data      side 0b01 [5]    ; Continue until all data captured 
     jmp start            side 0b10

19-jun-2023:

Overnight test failed:
Pass: 1985416 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 00f0021c exp/act: 7ff708f7 7ff700f7
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
7ff708f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR

Second byte failure... and it's repeatable:

d 0: 0e860e86
id 1: 00010001
cfg 0: ffe0ffe0
cfg 1: ffc1ffc1
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
Pass: 1985400 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985401 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985402 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985403 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985404 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985405 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985406 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985407 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985408 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985409 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985410 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985411 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985412 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985413 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985414 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985415 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985416 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR

Set pass to 1985415:

RAM failure at 00f0021c exp/act: 7ff708f7 7ff700f7
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
fg 1: ffc1ffc1
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
Pass: 1985415 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 1985416 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 00f0021c exp/act: 7ff708f7 7ff700f7
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR

And another one:
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6
Pass: 2001799 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Pass: 2001800 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 00e0021c exp/act: 7ff708f7 7ff700f7
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496

More:
Pass: 2009992 WRWRWRWRWRWRWRWRWRWRWRWRWRWR
RAM failure at 00d0021c exp/act: 7ff708f7 7ff700f7
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496
7ff700f7 43dd57e3 cd092d13 fdcc1186 80612178 2d8018bf fc6a1174 76dd0496

So:
1985416: RAM failure at 00f0021c exp/act: 7ff708f7 7ff700f7
2001800: RAM failure at 00e0021c exp/act: 7ff708f7 7ff700f7

Lowering clock speed to 266 enable memtest to pass. 280 also works. 290 won't
boot.

So, attempting to restructure for shorter code size. Thought: try to make
a subroutine threaded engine.
Use Y as count/next PC


start:
     set PINDIRS, 2       side 0b10 [3]
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
     out Y, 16            side 0b00       ; Get long lat next PC
     jmp PIN, next        side 0b00       ; Skip if RWDS set for max latency
     out Y, 8             side 0b00       ; Get short lat next PC
     out NULL, 8          side 0b00       ; Pop off extra bits
next:
     out X, 8             side 0b00       ; Get CMD/Data word count
     jmp ddr              side 0b00       ; Do command phase
;8

public reg_w:
     out NULL, 16         side 0b00       ; Dump last 16 bits of command
     jmp start                            ;   since we only write 16 bits
;+2 = 10

public write_l:
     set Y, write_lat_long
     jmp lat
;+2 = 12

public write_s:
     set Y, write_lat_short
     jmp lat
;+2 = 14

ddr:
     out PINS, 8          side 0b00 [4]   ; Setup write of cmd/adr
     nop                  side 0b01       ; CA phase 0 write
     out PINS, 8          side 0b01 [4] 
     jmp X--, adr         side 0b00       ; CA phase 1 write
     jmp Y                side 0b01 [4]   ; Jump to command [start, r/w_lat]
;+5 = 19

public read_l:
     set Y, read_lat_long
     jmp lat
;+2 = 21

public read_s:
     set Y, read_lat_short
;+1 = 22

public lat:
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
lat_cnt:
     nop                  side 0b00 [5]   ; Wait for latency to expire
     jmp Y--, lat_cnt     side 0b01 [5]
     out X, 16            side 0b00       ; Get transfer word count
     out PC, 8            side 0b00       ; Get next PC
;+5 = 27

public r_data:
     in PINS, 8           side 0b00 [6]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [5]    ; Continue until all data captured 
     jmp start            side 0b10
;+4 = 31

Current count is 27. Could maybe eliminate the reg_w: -2 for 29

What about using the pop pc stuff above to directly get to the Y lat value?
     out Y, 16            side 0b00       ; Get long lat
     jmp PIN, next        side 0b00       ; Skip if RWDS set for max latency
     out Y, 8             side 0b00       ; Get short lat
     out NULL, 8          side 0b00       ; Pop off extra bits

That would save one instruction from the original: 26 instructions.
Can't use it with the above, since we need to serve as the nextPC reg.

orig:
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
     set Y, LATENCY       side 0b00       ; Assume maximum latency     
     jmp PIN, setup       side 0b00       ; Skip if RWDS set for max latency
     set Y, LAT_SHORT     side 0b00       ; Short latency

setup:
     out X, 8             side 0b00       ; Set length for CMD/ADR phase

proposed:
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
     out Y, 5             side 0b00       ; Assume maximum latency     
     jmp PIN, setup       side 0b00       ; Skip if RWDS set for max latency
     out Y, 2             side 0b00       ; Short latency
     out Y, 3

setup:
     out X, 3             side 0b00       ; Set length for CMD/ADR phase (2 or 4)

so: 2 bits for short latency, 3 for long. Currently: 0, 1 and 3, 4. Just fits.
For a one instruction slot savings. Perhaps we'll keep this in reserve for now.
Time to bike!

20-jun-2023

Soldered on PSRAM onto second board. Had interesting time trying to get it
to boot afterwards: it would show up on the Windows file manager when plugged
in, but upon replugging, wouldn't. Downloaded blinky with scope loop, and
observed that the 500 kHz waveform wasn't. Decided to replace crystal, and
that solved the booting problem. Also replaced the GD flash device with a
new one, and now flashing blinky actually works! Have to test further - I
manually flashed/verified via OpenOCD when debugging the crystal problem.

Yay! Second board passes mem_test! Had to remove PSRAM, manually "re-ball"
(by which I mean "run the soldering iron over the chip") and solder down.
Turns out that there was a solder short between two balls.

Debugging the flash issue:
openocd flash commands
flash write_image <full path to elf file>
flash verify_image <full path to elf file>
flash md{b,h,w} count - display bytes/halfwords/words from flash

Flash was working, now it's not. I wonder if the reflow process popped it?

21-jun-2023:

Memory test still running on second board.

Replaced flash on first board, was able to copy flash.ufl and reboot into it
successfully. Also shows up when probing with picotool on Linux. Had to switch
USB ports, though.

Ok, this is weird - can reload blink and get it to show up /dev/ttyACM0, but
not mem_test. All with picotool. At least flash appears to work, though.

Time to do gardening...trimmed three shrubs, prepped more bird blockers for
later installation.

Replaced flash on second board, now flashes via drag and drop on the HW lab
PC. Attempting to reprogram on the SW lab RPI0: devel0. Was able to re-flash
blink, and mem_test. Mem_test fails to execute, however. Perhaps the flash
doesn't work when sysclk is 280 MHz? Trying default clkfreq...Yes, mem_test
is now running. So, there's a CMakefile directive to slow down flash speed...


target_compile_definitions(slower_boot2 PRIVATE PICO_FLASH_SPI_CLKDIV=4)

The PICO_FLASH_SPI_CLKDIV is used by "boot stage 2" which is not actually part of your TARGET (from cmake's point of view)

Create yourself your own "board header" - basically just set that define, then include your regular board header: e.g.

Code: Select all

// myboard.h

// setting first overrides the value in the default header
#define PICO_FLASH_SPI_CLKDIV 4

// pick up the rest of the settings
#include "boards/pico.h"

You can place that wherever, and pass a PICO_BOARD_HEADER_DIRS to cmake (or define at the top of your CMakeLists.txt), then do -DPICO_BOARD=myboard

// end web-capture

So, since we have to modify the second stage boot loader to change the I/O
voltage setting, we might as well change the SPI clock freq there as well.

Using blink (the modified boot loader version) as template.

While attempting to get blink to work at elevated clock rates, bricked the
flash. It programs and verifies fine, but fails to boot. Reading the GD25LQ64E
datasheet closely reveals that there's an non-volatile enable bit that
controls the QSPI mode:

QE bit
The Quad Enable (QE) bit is a non-volatile Read/Write bit in the Status
Register that allows Quad operation. When the QE bit is set to 0 (Default)
the WP# pin and HOLD# pin are enable. When the QE pin is set to 1, the
Quad IO2 and IO3 pins are enabled. (It is best to set the QE bit to 0 to
avoid short issues if the WP# or HOLD# pin is tied directly to the power
supply or ground.)

Further:
The GD25LQ64E supports Quad Peripheral Interface (QPI) operations only when
the device is switched from Standard/Dual/Quad SPI mode to QPI mode using the
“Enable the QPI (38H)” command. The QPI mode utilizes all four IO
pins to input the command code. Standard/Dual/Quad SPI mode and QPI mode are
exclusive. Only one mode can be active at any given times. “Enable the QPI
(38H)” and “Disable the QPI (FFH)” commands are used to switch between these two
modes. Upon power-up and after software reset using “Reset (99H)” command,
the default state of the device is Standard/Dual/Quad SPI mode. The QPI
commands require the non-volatile Quad Enable bit (QE) in Status Register set
to 1.

So my guess is that QE has been written to zero. Need to find code to
read flash status bits...

From sdk flash.c:
// Standard RUID instruction: 4Bh command prefix, 32 dummy bits, 64 data bits.
#define FLASH_RUID_CMD 0x4b
#define FLASH_RUID_DUMMY_BYTES 4
#define FLASH_RUID_DATA_BYTES 8
#define FLASH_RUID_TOTAL_BYTES (1 + FLASH_RUID_DUMMY_BYTES + FLASH_RUID_DATA_BYTES)

// Use standard RUID command to get a unique identifier for the flash (and
// hence the board)

static_assert(FLASH_UNIQUE_ID_SIZE_BYTES == FLASH_RUID_DATA_BYTES, "");

void flash_get_unique_id(uint8_t *id_out) {
#if PICO_NO_FLASH
    __unused uint8_t *ignore = id_out;
    panic_unsupported();
#else
    uint8_t txbuf[FLASH_RUID_TOTAL_BYTES] = {0};
    uint8_t rxbuf[FLASH_RUID_TOTAL_BYTES] = {0};
    txbuf[0] = FLASH_RUID_CMD;
    flash_do_cmd(txbuf, rxbuf, FLASH_RUID_TOTAL_BYTES);
    for (int i = 0; i < FLASH_RUID_DATA_BYTES; i++)
        id_out[i] = rxbuf[i + 1 + FLASH_RUID_DUMMY_BYTES];
#endif
}

So we should be able to use the flash_do_cmd to fetch the status register.
From the datasheet:
Command Name Byte 1    Byte 2   Byte 3   Byte 4  Byte 5 Byte 6 Byte 7 Byte 8
Read Status Register-1  05H     (S7-S0)  (cont.)
Read Status Register-2  35H     (S15-S8) (cont.)
Read Unique ID          4BH     00H      00H     00H    dummy  UDD7-0 (cont.)


For the command of Read, Fast Read, Read Status Register or Release
from Deep Power-Down, and Read Device ID, the shifted-in command sequence
is followed by a data-out sequence. All read instruction can be
completed after any bit of the data-out sequence is being shifted out,
and then CS# must be driven high to return to deselected status.

So, using the get_unique as a template:

// Standard RUID instruction: 4Bh command prefix, 32 dummy bits, 64 data bits.
// Status instruction: 35h command prefix, 16 data bits
#define FLASH_READ_STATUS_CMD 0x35
#define FLASH_STATUS_DUMMY_BYTES 0
#define FLASH_STATUS_DATA_BYTES 2
#define FLASH_STATUS_TOTAL_BYTES (1 + FLASH_STATUS_DUMMY_BYTES + FLASH_STATUS_DATA_BYTES)

void flash_get_status_reg(uint8_t *status_out) {
    uint8_t txbuf[FLASH_STATUS_TOTAL_BYTES] = {0};
    uint8_t rxbuf[FLASH_STATUS_TOTAL_BYTES] = {0};
    txbuf[0] = FLASH_READ_STATUS_CMD;
    flash_do_cmd(txbuf, rxbuf, FLASH_STATUS_TOTAL_BYTES);
    for (int i = 0; i < FLASH_STAUTS_DATA_BYTES; i++)
        status_out[i] = rxbuf[i + 1 + FLASH_STATUS_DUMMY_BYTES];
}

Above didn't work - the XIP controller and flash aren't initialized in a
NO_FLASH binary. Searching on the internet yeilded a solution (see flash.c)
Results:

id: 33 32 36 34                                                                 
status1: 00                                                                     
status2: 02

So the QE bit is, in fact, set to one. Still don't know why continuous
read mode fails...

Tried changing the boot2 file in blink to generic_03, now boots. As does
generic_03_mod. Note that the build directory does neet to be removed,
and cmake re-run after changing boot file. Otherwise, make complains about
not finding the boot file. Changed to boot2_w25q080.S, and still boots.
Sigh. I don't know what's going on. There must be some weirdness in
programming/flash formatting.

Going back to getting over-clocking to work. Ok, so the 080_mod.S file
appears to brick the boot process. It looks the previous debugging
efforts left this in a weird state. Restoring from un-modified version,
and adding the pad voltage selects resulted in a booting state.

Proceeding incrementally:
1) vreg_set_voltage succeeded.
2) frequency set to 175 hangs, no output to USB or monitoring GPIO.
   reverting back succeeds.
3) 170 works, 180, 190, 200. Maybe 175 is unreable by the PLL?
4) 220, 240, 260, and finally, 280 works.

Now to try the same with mem_test. Sigh. "Handler HardFault"
Reverting back to no overclock didn't work. Reprogramming with overclocked
blink brought board back to life.

Found problem: forgot to copy fixed 080_mod.S to psram_wren/boot_stage2
directory. Now boots with 280MHz sysclock, from flash! Updated board 1,
also works. Confirmed via scope that we're getting 40 MB/s. (RWDS frequency
of 20 MHz).


22-jun-2023:

Discovered that I'd reversed the opening of the sd card connector. Nearly
impossible to insert card. Not sure if I was successful or not - the
test program indicates failure.

So, rev 1.2 fixes:
1) 180 rotation of SD card socket.
2) Add reset push button.
3) Add LED with jumper to GPIO 8 or 9.
4) Add male connector foot print in parallel with J3.
5) Add jumpers to reclaim unused SDIO pins: SD_DAT1/2 (GPIO 13/14).
6) Possibles: tune length of PSRAM IO vs clk, additional J3 with serial xover.

Wandering off-target for the moment:
Current hyperram.pio code size:
  27, leaving 5 instruction slots.
Ethernet (see 31-mar):
phy_tx.pio: 10 instructions
phy_rx.pio: 7 instructions
And SDIO:
_sdio.pio: sm0: 18, sm1: 5 + 9 = 14

So, we can either do ethernet or SDIO...

Back on target:
It looks like the SD card is fully inserted - it just barely clears
the level translator.

Debugging - probing the SD card connector:
1) pin 5 has clock of 403 kHz. This matches SPI mode clock.
2) pin 2 has low going pulse. This is chip select.
3) all other pins have no signal.

Ok, using modified blink.c to toggle 11, found that only a very small signal
on pin 3. Reflowed U5 (level translator) and now full swing signal observed.
Putting SD card in socket, running simple.c now works.

Defining USE_SPI in examples/command_line/hw_config.c enabled that
example to work:


> mount 0:                                                                      
                                                                                
> ls                                                                            
Directory Listing: 0:/                                                          
System Volume Information [directory] [size=0]                                  
RT11_V5_MUBasic.RL01 [writable file] [size=5242880]                             
Rsts_DL.RL01 [writable file] [size=5242880]                                     
RT11_V5_CFB.RL02 [writable file] [size=10486272]                                
MINC_BASIC.RK05 [writable file] [size=573440]                                   
RSX_31_Fortran.RK05 [writable file] [size=2457600]                              
Unix_V6.RK05 [writable file] [size=2091520]                                     
filename.txt [writable file] [size=28]                                          
                                                                                
> cat filename.txt                                                              
Hello, world!                                                                   
Hello, world!

Enabling SDIO mode via undefining USE_SPI:
> mount 0:                                                                      
sd_sdio_begin,110 SDIO not responding to CMD8 SEND_IF_COND, status 0x2 reply 0x0
f_mount error: The physical drive cannot work (3)                               
                                                                                
>

Time to prune!

Wandering again: Tried reducing the flash speed:
target_compile_definitions(boot2_mod PRIVATE PICO_FLASH_SPI_CLKDIV=8)
This works for the blink and mem_test projects.

Back on target: modified blink to toggle all of the SD socket pins - all
successfully toggled.

Refreshing git source:
git clone -b sdio --recurse-submodules https://github.com/carlk3/no-OS-FatFS-SD-SPI-RPi-Pico.git no-OS-FatFS

Didn't work - same results.

Some debugging shows that the receive pio never gets anything.

Given that we don't have enough PIO instruction slots for PSRAM, Ethernet
and SDIO, I think I'll put this aside for the moment, and go to Ethernet debug.

23-jun-2023:

Debugging pico-rmii-ethernet. To get it to build, changed CMakeLists.txt:
#set(LWIP_PATH ${CMAKE_CURRENT_LIST_DIR}/lib/lwip)
set(LWIP_PATH "${PICO_SDK_PATH}/lib/lwip")

Also made sram build via: /examples/httpd/CMakeLists.txt
# Enable SRAM only executable
pico_set_binary_type(pico_rmii_ethernet_httpd no_flash)

Updated pin assignments:
#ifdef ORIG
  struct netif_rmii_ethernet_config netif_config = {
      pio0, // PIO:            0
      0,    // pio SM:         0 and 1
      6,    // rx pin start:   6, 7, 8    => RX0, RX1, CRS
      10,   // tx pin start:   10, 11, 12 => TX0, TX1, TX-EN
      14,   // mdio pin start: 14, 15   => ?MDIO, MDC
      21,   // rmii clock:     21, 23, 24 or 25 => RETCLK
      NULL, // MAC address (optional - NULL generates one based on flash id)
  };
#else
  struct netif_rmii_ethernet_config netif_config = {
      pio0, // PIO:            0
      0,    // pio SM:         0 and 1
      3,    // rx pin start:   6, 7, 8    => RX0, RX1, CRS
      0,   // tx pin start:   10, 11, 12 => TX0, TX1, TX-EN
      6,    // mdio pin start: 14, 15   => ?MDIO, MDC
      21,   // rmii clock:     21, 23, 24 or 25 => RETCLK
      NULL, // MAC address (optional - NULL generates one based on flash id)
  };
#endif

And the results from minicom attached to the USB serial port:
pico rmii ethernet - httpd                              
netif status changed 0.0.0.0
netif link status changed up
netif status changed 192.168.1.178

nmap:
Starting Nmap 7.80 ( https://nmap.org ) at 2023-06-23 09:46 PDT
Nmap scan report for 192.168.1.178
Host is up (0.094s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
80/tcp open  http

And pointing a browser to the IP shows the lwIP intro page.

That was too easy :-)

Will need to figure out how to set sysclk to 280 or so, and maintain
a 50 MHz clock on GPIO21.

280/50
5.6000

Can we do a divisor like this? 56/10 or 2.8/5...
Perhaps:
Orig:

// Temporarily switch to crystal clock
  clock_configure(clk_sys,
                  CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX,
                  CLOCKS_CLK_SYS_CTRL_AUXSRC_VALUE_XOSC_CLKSRC,
                  12 * MHZ,
                  12 * MHZ);

  // Configure PLL sys to 1500 / 5 / 3 = 100MHz
  pll_init(pll_sys, 1, 1500 * MHZ, 5, 3);

  // Switch back to PLL
  clock_configure(clk_sys,
                  CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX,
                  CLOCKS_CLK_SYS_CTRL_AUXSRC_VALUE_CLKSRC_PLL_SYS,
                  100 * MHZ,
                  100 * MHZ);

  // Configure clock output on GPIO21 at (100MHz) / 2 = 50MHz
  clock_gpio_init(netif_config.retclk_pin, CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_VALUE_CLK_SYS, 2);

Proposed:
// Temporarily switch to crystal clock
  clock_configure(clk_sys,
                  CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX,
                  CLOCKS_CLK_SYS_CTRL_AUXSRC_VALUE_XOSC_CLKSRC,
                  12 * MHZ,
                  12 * MHZ);

  // Configure PLL sys to 1500 / 5 / 3 = 100MHz
  // Configure PLL sys to 2800 / 5 / 3 = 100MHz
  pll_init(pll_sys, 1, 1500 * MHZ, 5, 3);

  // Switch back to PLL
  clock_configure(clk_sys,
                  CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX,
                  CLOCKS_CLK_SYS_CTRL_AUXSRC_VALUE_CLKSRC_PLL_SYS,
                  100 * MHZ,
                  100 * MHZ);

  // Configure clock output on GPIO21 at (100MHz) / 2 = 50MHz
  clock_gpio_init(netif_config.retclk_pin, CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_VALUE_CLK_SYS, 2);

Clk architecture:
xtal -> system pll --> divider -> clk_gpio0-3
                   +-> divider -> clk_sys

The divider uses a 24.8 fixed point format.
Further, we have the PIO clock divider, which has 16.8 fixed point format.

Need to have 50 MHz GPIO clk, 100 MHz PIO clk, and 280 MHz sysclk.

280/x = 100, x = 2.8
280/x = 50, x = 5.6

Using https://www.exploringbinary.com/binary-converter/

2.8 converts to a repeating binary fraction, unfortuanely.

10.110011 converts to 2.796875

The result of PLL_SYS_VCO_FEEDBACK_SCALE * CLOCK_XOSC must be in the range of 400 MHz to 1600 MHz

24-jun-2023:

Updating memory test to do random addresses, random transfer lengths. Check
after every megabyte.

While testing, discovered that the long test no longer passes:
ad bank0 voltage select addr/data: 4001c000 00000001                           
Loading program                                                                 
Initialising state machine                                                      
Setting clock divisor to 1                                                      
Reading cfg 0: ffe0ffe0                                                         
Writing f0e0 to CR0 register                                                    
Reading cfg 0: ffe0ffe0                                                         
id 0: 0e860e86                                                                  
id 1: 00010001                                                                  
cfg 0: ffe0ffe0                                                                 
cfg 1: ffc1ffc1                                                                 
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00000000 c1c10008 40420800 8c022998 d8826398 b906e3b0 281a30d0 7323e835         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
Pass:    1 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWR                                    
RAM failure at 00001a7c exp/act: 7a0f32d1 aafc00a8                              
aafc00a8 16fec39b 1f355f7d 2f8e0710 02e26466 83bee971 8c8c2119 1d4fac8e         
R                                                                               
RAM failure at 00101998 exp/act: face0611 1cb7a826                              
1cb7a826 7b8b59f7 0603840d a6c1f6cc 9b1f62c0 9fac7503 308fad25 604699b0         
R

Tested on both boards, both fail similarly. Short test passes fine.
Zeroing in on the inital read, after the id/cfg reads. The data
is very consistent across boards/reboots. Slowing sysclk didn't help.
Leads me to believe that it's an address/cmd phase problem.
Sure was - the delay between CS high and low wasn't long enough:
old:
     set PINDIRS, 0       side 0b10 [3]   ; Make RWDS pin input
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction

new:
     set PINDIRS, 0       side 0b10       ; Make RWDS pin input
     out PINDIRS, 8       side 0b00 [3]   ; Set CMD/Data pins direction

Anything less that [3] causes failures.

Long test now passes. Updating main to call all available tests.

Debugging random test shows failures:

Pass:    0 WR01234567891011121314                                               

RAM failure at 01b88a29 exp/act: b5997941 ca504f18                              
ca504f18 a7c127f5 ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153         
ca504f18 a7c127f5 ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153         
                                                                                
RAM failure at 01b88a2a exp/act: cc939739 a7c127f5                              
a7c127f5 ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a         
a7c127f5 ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a         
                                                                                
RAM failure at 01b88a2b exp/act: 70e9e863 ec11d487                              
ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a 26dd33f5         
ec11d487 a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a 26dd33f5         
                                                                                
RAM failure at 01b88a2c exp/act: f1507cb1 a46a2154                              
a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a 26dd33f5 c49de7a2         
a46a2154 798f62dc 191dde06 f5a216e4 0a9b6153 09400f1a 26dd33f5 c49de7a2         

Ok, so the failure arises because we can have multiple write requests to the
same area in memory:
Pass:    0 W                                                                    
Req at addr/len: 01b88800 0090                                                  
                                                                                
Req at addr/len: 01b88800 009c   

(This is without the write-to-middle offset added). Without implementing a
1 MB buffer to capture the final state, we would have to check the state
of memory after each write. Or an array that captures how many writes
to a buffer during the 1 MB write phase.
Or, an array that captures if a buffer has been written to or not. If to,
then generate a new address...

so if the address size is 32MB, and buf is 1k, then we'd need 32k entries.

Updated random test works. Now running: long, short and random in succession.

Boosted system clock to 300 MHz on board 1 and 2, let's see if they'll run
overnight. Did change the pass count to 45000 on board 1, left at 0 on board 2.

25-jun-2023:

The memory test was still running. Assuming it continues to do so, this will
make generating Ethernet clocks so much easier...

Changed test on board 1 to run only random. Tried to tickle previous failure
cases with pass 45000, etc. No failures. Left running...Failed at pass 2119015.
Doesn't repeat, however. Re-started from failed pass...Another transitory
failure:

Pass: 4362778 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR                                  
RAM failure at 00f00120 exp/act: 79f708a8 79f700a8                              
79f700a8 84aadff9 35e79a33 1292b503 c26c145a 5c09f109 2734e3bd d320dd9c         
79f708a8 84aadff9 35e79a33 1292b503 c26c145a 5c09f109 2734e3bd d320dd9c

So, it seems like something is slightly marginal on the read side, since
the second read was correct.

Pass: 4393498 WRWRWRWRWRWRWRWRWRWRWRWR                                          
RAM failure at 00b00120 exp/act: 79f708a8 79f700a8                              
79f700a8 84aadff9 35e79a33 1292b503 c26c145a 5c09f109 2734e3bd d320dd9c         
79f708a8 84aadff9 35e79a33 1292b503 c26c145a 5c09f109 2734e3bd d320dd9c  


Increasing the jmp in the read loop delay from 5 to 6. Restarted board 1
from 4362778 running only short test, board 2 from 0, running all tests.

So, what to do with the remaining 4 instructions in PIO 0? Let's see
if we can squeeze in video! Use the two pins freed up from SDIO to output
sync and video.

26-jun-2023:

Memory test still running on both boards.

Found a good candidate for first emulation:

https://github.com/tvlad1234/pico-rv32ima.git

Checkout via:
git clone  --recurse-submodules https://github.com/tvlad1234/pico-rv32ima.git

27-jun-2023:

Converting hyper mem routines from big endian to little endian. The PIO
routines remain the same; only the driver/setup c code differs.

Also need to add byte handling capabilities. Should be sufficient to
add write high/low byte and drop high/low byte reads operations.

Write byte requires controlling RWDS during the write phase.

E.g.
write start address odd:
Need to pad the first byte, with masking (or just not pop the
byte).

write length odd:
need to mask last byte.

read start address odd:
Need to decrement address, and drop first byte

read length odd:
Need to drop last byte

For PIO, perhaps provide 8 bit operations? A write high/low?


write low:
     out PINS, 8          side 0b00        ; Setup write of cmd/adr
     set PINS, 1          side 0b00 [3]    ; Mask low byte
     nop                  side 0b01        ; CA phase 0 write
     out PINS, 8          side 0b01        ; 
     set PINS, 1          side 0b01 [3]    ; Enable high byte 

as a secondary state machine write:
w_lat_cnt:
     set PINDIRS, 3       side 0b00 [5]      ; Make RWDS pin output 
     jmp Y--, w_lat_cnt   side 0b01 [5]
     irq clear 1          side 0b00        ; Signal RWDS state machine

public w_data:
     out PINS, 8          side 0b00 [4]    ; Setup write of cmd/adr
     irq clear 1          side 0b01        ; CA phase 0 write & signal RWDS
     out PINS, 8          side 0b01 [4] 
     jmp X--, w_data      side 0b00        ; CA phase 1 write

RWDS SM:
     set X, 0                              ; Assume no masking
     irq wait 1                            ; Wait for signal
     pull noblock                          ; Get mask, if available
     out PINS                              ; apply, and wait for next mask


If we use above, c code:


void hyperram_write_byte)(const hyperram_inst_t *inst, uint32_t addr, const uint32_t *src, uint len) {
	hyperram_cmd_t cmd;
	uint32_t mask, word;

	// Setup to write one 32 bit word
	_hyperram_cmd_init(&cmd, inst, HRAM_CMD_WRITE, addr, 1);

	pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd0);
	pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd1);
	pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd2);

	// replicate byte to be written
	word = (*src << 24) | (*src << 16) | (*src << 8) | *src;

	// generate mask
	for (int i = 0; i < 4; i++) {
	   mask = ((addr & 0x3) == i) ? -1 : 0;
	   pio_sm_put_blocking(inst->pio, inst->sm_RWDS, &mask);
        }

	// Now write the replicated byte
	pio_sm_put_blocking(inst->pio, inst->sm, &word);

}


void hyperram_write_stream_byte(const hyperram_inst_t *inst, uint32_t addr, const uint8_t *src, uint len) {
	hyperram_cmd_t cmd;
	uint32_t mask, word, i;
	uint32_t align;
	uint8_t *align_src;
	uint align_len, first_len;
	uint align_len_word;

	// Write up to first three bytes
	align = addr & 0x3;
	align_src = src;
	first_len = (len > 4) 4 : len;
	
	if (align) {
	  // Generate aligned word from starting bytes
	  word = 0;
	  for (i = align; i < first_len; i++) {
	    word |= (*align_src++) << (8 * i));
	    // Update remaining write parameters
	    len--;
	    addr++;
	  }

	  // generate masks
	  for (int i = 0; i < 4; i++) {
	    mask = (i <= align) ? 0 : -1;
	    pio_sm_put_blocking(hram->pio, hram->sm_RWDS, &mask);
	  }
	  
	  // Now write the masked bytes
	  pio_sm_put_blocking(inst->pio, inst->sm, &word);
	}

	// Write whole words
	if (len > 4) {
	  _hyperram_cmd_init(&cmd, inst, HRAM_CMD_WRITE, addr, len >> 2);

	  pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd0);
	  pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd1);
	  pio_sm_put_blocking(inst->pio, inst->sm, cmd.cmd2);
	  
	  for (i = 0; i < (len >> 2); i++) {
	    pio_sm_put_blocking(inst->pio, inst->sm, (uint32_t *)align_src);
	    (uint32_t *)align_src++;
	    addr += 4;
	  }
	  // Update write parameters
	  len -= (i << 2);
	}

	// If there are any remaining bytes, write partial word
	if (len > 0) {
	  // Generate aligned word from remaining bytes
	  word = 0;
	  for (i = 0; i < len; i++) {
	    word |= (*align_src++) << (8 * (i - 1));
	  }

	  // generate masks
	  for (int i = 0; i < 4; i++) {
	    mask = (i <= align) ? 0 : -1;
	    pio_sm_put_blocking(inst->pio, inst->sm_RWDS, &mask);
	  }
	  
	  // Now write the masked bytes
	  pio_sm_put_blocking(inst->pio, inst->sm, &word);

	}

}

29-jun-2023:

Good news: The memory tests on both boards were running when I returned home.
Board 1 short mem test was on pass 66388557 before I interrupted it.

Of course, running the new code results in a hang :-) Trying to debug
config register reads first...

Shift direction debug:
PIO code:
     out ISR, 24          side 0b10 [3]
     out NULL, 8          side 0b10 [3]
     push                 side 0b10 [3]

Setting:
 sm_config_set_in_shift(&c, false, true, 32);
  sm_config_set_out_shift(&c, false, true, 32);

gives:
Writing e0f0 to CR0 register
rd: 0000c002
cmd0: 00c002ff

Setting:
sm_config_set_in_shift(&c, true, true, 32);
  sm_config_set_out_shift(&c, true, true, 32);
Gives
Writing e0f0 to CR0 register                                                    
rd: 00c002ff                                                                    
cmd0: 00c002ff 

Further debug:
     set PINDIRS, 0       side 0b10       ; Make RWDS pin input
     out PINDIRS, 8       side 0b10 [3]   ; Set CMD/Data pins direction
;     out NULL,          side 0b10 [3]
     out ISR, 8          side 0b10 [3]
     out NULL,16        side 0b10 [3]
     push                 side 0b10 [3]
     jmp start            side 0b10 [3]

Done PIO init                                                                   
Writing e0f0 to CR0 register                                                    
rd: 00000002                                                                    
cmd0: 00c002ff

So, this shows that we correctly get the length after the direction from
the command. Question: does the PSRAM correctly get the right CA bytes?

30-jun-2023:

Little endian:
cmd0: 00c002ff                                                                  
cmd1: 01000000                                                                  
cmd2: 14000001  

Big endian:
cmd0: ff02c000                                                                  
cmd1: 01000000                                                                  
cmd2: 00010011

Ok, so fix cmd 1...
cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 14000001

Little endian:

Reading cfg 0: e0ffe0ff                                                         
cmd0: 00c002ff                                                                  
cmd1: 00000000                                                                  
cmd2: 11000001                                                                  
id 0: 860e860e                                                                  
cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 11000001                                                                  
id 1: e0ffe0ff                                                                  
cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 11000001                                                                  
cfg 0: e0ffe0ff                                                                 
cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 11000001                                                                  
cfg 1: e0ffe0ff

Big endian:
cmd0: ff02c000                                                                  
cmd1: 01000000                                                                  
cmd2: 00010011                                                                  
Reading cfg 0: ffe0ffe0                                                         
cmd0: ff02c000                                                                  
cmd1: 00000000                                                                  
cmd2: 00010011                                                                  
id 0: 0e860e86                                                                  
cmd0: ff02c000                                                                  
cmd1: 00000001                                                                  
cmd2: 00010011                                                                  
id 1: 00010001                                                                  
cmd0: ff02c000                                                                  
cmd1: 01000000                                                                  
cmd2: 00010011                                                                  
cfg 0: ffe0ffe0                                                                 
cmd0: ff02c000                                                                  
cmd1: 01000001                                                                  
cmd2: 00010011                                                                  
cfg 1: ffc1ffc1


Failure:
Pass:    0 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    1 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    2 WRWRWR                                                               
RAM failure at 00200000 exp/act: 0018c0c6 69861801                              
69861801 cb0a7aa9 782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998         
69861801 cb0a7aa9 782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998         
                                                                                
RAM failure at 00200004 exp/act: 18019406 cb0a7aa9                              
cb0a7aa9 782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f         
cb0a7aa9 782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f         
                                                                                
RAM failure at 00200008 exp/act: 7aa96986 782ea4a9                              
782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f 48d37b0d         
782ea4a9 154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f 48d37b0d         
                                                                                
RAM failure at 0020000c exp/act: a4a9cb0a 154424d0                              
154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f 48d37b0d 5e227c78         
154424d0 28a05160 a7e52adf ef8a36a2 027e2998 3036b95f 48d37b0d 5e227c78

2nd run:
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
00084042 08008c02 2998d882 6398b906 e3b0281a 30d07323 e8358359 538f61b6         
Pass:    0 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    1 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    2 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    3 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    4 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR     
Pass:    5 WRWRWRWRWRWRWRWR                                                     
RAM failure at 00700000 exp/act: 0204b12d 00000000                              
00000000 b12d1818 3c9d0204 5d71100a 04d1a4af 3229af2a 871619ba f20ba018         
0204b12d 100a3c9d a4af5d71 af2a04d1 19ba3229 a0188716 afb9f20b aee38417         
WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR

Debugging:
1) Swapped IRQ clears for nops to eliminate RWDS state machine interactions.
Still errored out:

Pass:   67 WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR                   
RAM failure at 01800000 exp/act: 20047827 009f4f19                              
009f4f19 e5b0664c 0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283         
009f4f19 e5b0664c 0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283         
                                                                                
RAM failure at 01800004 exp/act: 4f193b47 e5b0664c                              
e5b0664c 0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d         
e5b0664c 0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d         
                                                                                
RAM failure at 01800008 exp/act: 664c009f 0a9d2dad                              
0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d 98b7c72e         
0a9d2dad f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d 98b7c72e         
                                                                                
RAM failure at 0180000c exp/act: 2dade5b0 f363b26e                              
f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d 98b7c72e c5468974         
f363b26e 2452148f e658b69f ac0310bc 07c20283 dc00977d 98b7c72e c5468974

Different than previous, as 2nd read didn't fix the problem.

2) Revert back to original, add only little endian changes.

cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 11000001                                                                  
Reading cfg 0: e0e00000                                                         
cmd0: 00c002ff                                                                  
cmd1: 00000000                                                                  
cmd2: 11000001                                                                  
id 0: f0f00000                                                                  
cmd0: 00c002ff                                                                  
cmd1: 01000000                                                                  
cmd2: 11000001                                                                  
id 1: 86860101                                                                  
cmd0: 00c002ff                                                                  
cmd1: 00000001                                                                  
cmd2: 11000001                                                                  
cfg 0: 01010000                                                                 
cmd0: 00c002ff                                                                  
cmd1: 01000001                                                                  
cmd2: 11000001                                                                  
cfg 1: f0f00101

Ok, need to add le init code:
  uint16_t cfgreg_be =
    (0x1u << 15) | // Do not enter power down
    //(0x1u << 12) | // 115R drive strength
    //(0x0u << 12) | // Default drive strength (34R)
    //(0x5u << 12) | // 27R drive strength
    (0x7u << 12) | // 19R drive strength
    (0xeu << 4)  | // 3 latency cycles (in bias -5 format)
    //(0xfu << 4)  | // 4 latency cycles (in bias -5 format)
    //(0x0u << 4)  | // 5 latency cycles (in bias -5 format)
    //(0x1u << 4)  | // 6 latency cycles (in bias -5 format)
    //(0x2u << 4)  | // Default 7 latency cycles (in bias -5 format)
    //(0x1u << 3);   // Fixed 2x latency mode
    (0x0u << 3);   // Variable latency mode
    
  // Don't care about wrap modes, we're always linear

  // Need to byte swap init value
  uint16_t cfgreg_init = cfgreg_be << 8 | ((cfgreg_be >> 8) & 0xff);

Runs fine at 133 MHz. Reverting back to 300...still runs. Now going to have
a snack, to give it some run time. Still running...

Adding byte swap to cfg_write routine. And cfg_read routine. Now matches
big endian version. Short memtest runs succesfully.

Now add byte masking. First, update PIO file...

Test code, showing that we masked writing the 7th byte:

ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         
ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff         
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000         
00000000 00ff0000 00000000 00000000 00000000 00000000 00000000 00000000      
PIO code:
w_lat_cnt:
     set PINDIRS, 3       side 0b00 [5]      ; Make RWDS pin output 
     jmp Y--, w_lat_cnt   side 0b01 [5]


public w_data:
     irq clear 4          side 0b00        ; Setup RWDS pin
     out PINS, 8          side 0b00 [4]    ; Setup write of cmd/adr
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     out PINS, 8          side 0b01 [4] 
     jmp X--, w_data      side 0b00        ; CA phase 1 write

Combo memtest still passes.

Now add byte enabled mem write...

1-jul-2023:

Finished prototype byte masked write code - discovered that RP2040 doesn't
support unaligned memory 32 bit reads. Now need to refactor code to handle
this. Should be doable - read RP2040 words, and align to PSRAM writes.

Memory test still running on board 2. Up to pass 35722. Took down board
to bring on trip.

Needed to do:
sudo fuser -k 6666/tcp

before running the start openocd script. Under VMware.
Process is crtmpserver.


Need PIO method to skip variable number of pulls when writing data. This
would enable aligning write data to addresses generated internally by
the PSRAM.

So, could add clocks with mask asserted at the beginning of a write cycle.
Could just add clocks to write latency counter. Need to pass in
latency counter value. Oh, except that this only works for whole clock
cycles (i.e. 16 bits).

One approach is to call fragments to do the unaligned write. E.g.

Orig:
w_lat_cnt:
     set PINDIRS, 3       side 0b00 [5]    ; Make RWDS pin output 
     jmp Y--, w_lat_cnt   side 0b01 [5]

public w_data:
     irq clear 4          side 0b00        ; Setup RWDS pin
     out PINS, 8          side 0b00 [4]    ; Setup write of cmd/adr
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     out PINS, 8          side 0b01 [4] 
     jmp X--, w_data      side 0b00        ; CA phase 1 write

Skip first phase:

nowrite:
     irq clear 4          side 0b00 [4]       ; Setup RWDS pin
     jmp nextPC

write:
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     out PINS, 8          side 0b01 [4] 

nextPC:
     IN ISR, 8            side 0b00        ; Get next PC
     mov PC, ISR          side 0b00        ; Go there


Actually, could use the RWDS state machine to run the clock - but would
have to have the main SM wait for RWDS completion.
Or use another SM entirely. Probably not - alreay hard to trigger RWDS
machine.

3-jul-2023:

Had a though about PSRAM control: seperate SMs for data and control, much
like networking does. So, data SM transmits/captures data independent of
PSRAM clock, when signalled to do so by the control SM.

Data SM pio code:
;
; Make RWDS pindir side setable
; 
public start: ;                  
     out PINDIRS, 8       side 0b0       ; Set CMD pins direction; RWDS input
     out X, 3                            ; Get CMD xfer count
     out Y, 5                            ; Get next PC after CMD/DATA xfer
     jmp out
;4

preamble:
     out PINDIRS, 8                       ; Setup for read/write
     out X, 4                             ; Get data delay count
;+2=6
pwait:
     irq wait 4                          
     jmp X--, pwait
     out X, 12                            ; Get xfer count
     out PC, 12                           ; Go to read/write 
;+4=10
public w_data:
     set PINDIRS, 1                       ; RWDS output
out:
     out PINS, 8                          ; Setup data
     irq wait 4                           ; Wait until signalled
     jmp X--, out                         ; 
     mov PC, Y            side 0b0        ; Next is start, or preamble
;+5=15
public r_data:
in:
     irq wait 4                           ; Wait to get data
     in  PINS, 8                          ; Do so when signalled
     jmp X--, in                          ; And do until no more data
;+3=18                                    ; Always return to start when done

Control SM pio code
start:
     pull                                 ; Wait for data (no autopull!)
     out Y, 4                             ; Next PC: start or lat
data:
     out X, 9             side 0b00       ; Get cmd/data word count
;3
cmd:     
     irq 4               side 0b01       ; 
     out PINS, 1
     irq 4               side 0b00
     out PINS, 1
     jmp X--, cmd        side 0b00
     mov PC, Y                           ; jump to start or lat
+6=9
lat:
     set X, LONG_LAT  ; long lat count
     jmp PIN, LONG       side 0b00       ; Jump if PSRAM signals long latency
     set X, SHORT_LAT  ; short lat count
+3=12
short:
next:
     nop                  side 0b01       ; RWDS will be low via cmd phase
     jmp X--, next        side 0b00
     irq 4                                ; Allow for lat cnt == 0
+3=15                                     ; (aligns with start of data)
     set Y, start                         ; next pc: Start
     jmp data
+2=17
17 instr

18+17=35 Oh well!

(Note that RWDS must be low before the end of initial latency to prove
a data mask preamble - timing paramete Tdmv. Though the minimum value
is 0ns. So does that mean it doesn't need to be low?).


Note that we use latency count to do both latency and byte alignment.
But, need to have RWDS high during byte alignment phase, but needs to be
low during latency time. So this doesn't work.

Note that PIO in/out opcodes differ only by bit 13 clear/set.

We do 16 bits per cmd loop, and a register write takes 4 long words = 8 loops,
thus count = 7, or 3 bits.

For reg write:
4 bits next pc (after cmd/data) - go to idle
9 bits cmd count
8 bits of cmd/data masking

For read/write:
CA phase:
4 bits next pc - go to lat
9 bits cmd count 
6 bits of cmd masking
19 bits

Data phase:
9 bits data count
4 bits data masking
13 bits

32 bits
With a 9 bit data count = 512 16 bit words, or 1KB 

Note that RWDS tristates after 1 (min) or 5.5 (max) ns after falling edge of
last CA clock.

Just found this:
 Whether to use the most significant of these bits as an enable.
 Side-set takes place on instructions where the enable
 is high. If there is no enable bit, every instruction on that state
 machine will perform a side-set, if SIDESET_COUNT is
 nonzero. This is configured by EXECCTRL_SIDE_EN.

4. Whether side-set writes to GPIO levels or GPIO directions.
   Configured by EXECCTRL_SIDE_PINDIR

So, we can make RWDS pindir controllable via side set. Modifying above.

Still over by 3 instructions. Can we re-factor somehow?
Incorporate the delay of data operations somehow. Common latency
routine, with data delay...


public start: ;                  ||
     out PINDIRS, 8       side 0b10       ; Set CMD pins direction
     out X, 3             side 0b00       ; Set length for CMD/ADDR phase
     out Y, 5             side 0b00       ; Next PC after CMD: [start, lat]
;3
adr:
     irq clear 4          side 0b00       ; Signal RWDS SM
     out PINS, 8          side 0b00 [4]   ; Setup write of cmd/adr/data
     irq clear 4          side 0b01       ; CA/data phase 0 write
     out PINS, 8          side 0b01 [4] 
     jmp X--, adr         side 0b00       ; CA/data phase 1 write
     jmp PIN, lat_max     side 0b00       ; Skip if RWDS set for max latency
     out X, 4             side 0b00       ; Get min latency
lat_max:
     mov PC, Y            side 0b00       ; Either latency or start
;+8=11
latency:
     out PINDIRS, 8       side 0b00       ; Set xfer pin dir
     mov Y, ~X                            ; Test if X was -1
     jmp !Y, next                         ; Jump if so
     out NULL, 4                          ; Skip min lat OSR bits
     out Y, 4             side 0b00       ; Get max latency



lat_cnt:
     nop

     jmp Y--, next
next:
     jmp !Y, no_pull
     out NULL, 4      ; skip max lat OSR bits
no_pull:
     jmp X!=Y, lat_cnt

if Y was max latency, then X was min latency, and we'll exit when they equal
if Y was min latency, then X was -1, and we'll exit when Y goes to -1

So to count min latency:


     jmp X!=Y  ; if X == -1, (max lat), then Y was min, so we just did min lat
               ; so we need to do more lat
	       ; if X == min lat, then Y was max, so we just did max lat so fail







     mov Y, ~NULL         side 0b00       ; Test if min or max latency
     jmp X!=Y, set_max    side 0b00       ; Max...
     out Y, 4
     jmp lat_skip         side 0b00       ; Now continue
set_max:
     out X, 4             side 0b00       ; Set to min latency
lat_skip:
;+6=17
lat_next:
lat_cnt:



     jmp !X, no_rwds      side 0b00 [5]   ; Change RWDS at end of latency
     irq clear 4          side 0b00       ; Make RWDS high, if needed
;+2=19
no_rwds:
     jmp X--, lat_cnt     side 0b01 [5]   ; Continue latency interval

     out X, 15            side 0b00       ; Get transfer len
     out Y, 1             side 0b00       ; Either read (0) or write (1)
     jmp Y--, w_setup     side 0b00       ; Write, with return addr now 0
;+4=23
public r_data:
     in PINS, 8           side 0b00 [6]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [6]    ; Continue until all data captured 
;+3=26

; Make RWDS pindir a side set pin
.program hyperram_rwds
rwds_start:
     mov X, NULL          side 0b0         ; Assume no masking
     irq wait 4           side 0b0         ; Wait for signal
     pull noblock         side 0b0         ; Get mask, if available
     mov X, OSR           side 0b0         ; Test it
     jmp !X, rwds_start   side 0b0         ; If zero, then no action
     out PINS, 32         side 0b1         ; apply, and wait for next mask
;+6=32

Above probably doesn't work, as RWDS goes to input after the out PINS
instruction.

; Assuming we will always write a RWDS command word
rwds_start:
     pull                                  ; Get pin update command
     out Y, 4                              ; Do a max of 16 RWDS pin updates
cmd:
     irq wait 4
     out pindir, 1
     out pins, 1
     jump Y--, cmd     
;+6

Note that the above code fails to allow for write data alignment. To do this,
no data should be written after latency interval is completed, which means
two things: 1) RWDS must be high, 2) no data should be pulled from the FIFO.

Let's try two routines: latency and alignment.
RWDS will tristate after last phase 1 of Command/Addres writes.

public start: ;                  ||
     set PINDIRS, 0       side 0b10       ; Make RWDS pin input
     out PINDIRS, 8       side 0b00 [3]   ; Set CMD/Data pins direction
     set Y, LATENCY       side 0b00       ; Assume maximum latency     
     jmp PIN, setup       side 0b00       ; Skip if RWDS set for max latency
     set Y, LAT_SHORT     side 0b00       ; Short latency
setup:
     out X, 8             side 0b00       ; Set length for CMD/ADR phase
; 6
adr:
     out PINS, 8          side 0b00 [4]   ; Setup write of cmd/adr
     nop                  side 0b01       ; CA phase 0 write
     out PINS, 8          side 0b01 [4] 
     jmp X--, adr         side 0b00       ; CA phase 1 write
     out X, 16            side 0b00       ; Get transfer len
     out PINDIRS, 8       side 0b00       ; Set data xfer pin dir
     out PC, 8            side 0b00       ; Jump to start, or latency count
;+7 = 13

public w_align:
     set PINDIRS, 1       side 0b00       ; Make RWDS pin output
     set PINS, 1          side 0b00       ; Mask writes prior to alignment
align:
     out Y, 16            side 0b00       ; align count
;+3 = 16
public count:                             ; First time through is latency
     jmp !Y, c_exit       side 0b00 [5]   ; Exit if count is zero
     jmp Y--, lat_cnt     side 0b01 [5]   ; Run down count
c_exit:
     out PC, 8            side 0b01 [5]   ; Now do align/next data
;+3 = 19

public r_data:
     in PINS, 8           side 0b00 [6]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [6]    ; Continue until all data captured 
     jmp start            side 0b10
;+4 = 23
public w_data:
     irq clear 4          side 0b00        ; Setup RWDS pin
     out PINS, 8          side 0b00 [4]    ; Setup write of cmd/adr
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     out PINS, 8          side 0b01 [4] 
     jmp X--, w_data      side 0b00        ; CA phase 1 write
;+5 = 28

; Control RWDS pin
; Uses pull noblock side effect: copy X to OSR if no data available
; This allows non-masked writes to be done without writing to
; this state machine.
.program hyperram_rwds
     mov X, NULL                           ; Assume no masking
     irq wait 4                            ; Wait for signal
     pull noblock                          ; Get mask, if available
     out PINS, 32                          ; apply, and wait for next mask

Format of control words:
Data transfer:
0:
  07:00 - cmd pindirs
  15:08 - cmd length
  23:16 - CA 0
  31:24 - CA 1
1:
  07:00 - CA 2
  15:08 - CA 3
  23:16 - CA 4
  31:24 - CA 5
2:
  15:00 - data length
  23:16 - data pindirs
  31:24 - next PC [count]
3: 
  07:00 - count: latency next PC [align, w_align]
  23:08 - align: data align count
  31:24 - align: next PC [r_data, w_data]

Cfg reg write:
0:
  07:00 - cmd pindirs
  15:08 - cmd length
  23:16 - CA 0
  31:24 - CA 1
1:
  07:00 - CA 2
  15:08 - CA 3
  23:16 - CA 4
  31:24 - CA 5
2:
  15:00 - Cfg data
  31:16 - Cfg data (copy of above)
3:
  15:00 - data length (not used, should be zero)
  23:16 - data pindirs (must be zero)
  31:24 - next PC [start]

Note that write alignment masks data until the alignment count is reached.
Once writing starts, masking can be done via writing to the rwds state machine.
Since RP2040 doesn't support unaligned reads, we always use full words, and
wait until the PSRAM has reached the right address/phase when performing
unaligned operations.

static inline void _hyperram_cmd_init(hyperram_cmd_t *cmd, const hyperram_inst_t *inst, hyperram_cmd_flags flags, uint32_t addr, uint len) {
  uint32_t next_pc, next_pc2;
  uint32_t cmd1_be;
  uint32_t align_adr;

	// HyperBus uses halfword addresses, not byte addresses.
	addr = (addr >> 1);
	
	// Get lower three bits for last phase of Cmd/Addr (CA)
	uint32_t addr_l = addr & 0x7u;

	// Add flags to addr_h upper bits for Command/Address 0
	uint32_t addr_h = (addr >> 3) | (flags << 24);
	
	// Convert transfer word len to uint16 len - 1
	len = (len * 2) - 1;

	// Little endian, so first byte is 31:24
	// Send big endian Command/Address values via to little endian PIO FIFO
	// (i.e. byte swap CA values)
	switch (flags) {
	case (HRAM_CMD_READ):
	case (HRAM_CMD_REGREAD):
	  // Will need to read an extra word if we're unaligned
	  align_count = addr & 0x3u;
	  len = len + (align_count) ? 1 : 0;

	  // Start command word
	  // Little endian: CA1, CA0, cmd len [2], 0xff
	  cmd->cmd0 = (((addr_h >> 16) & 0xff) << 24 |
		       ((addr_h >> 24) & 0xff) << 16 |
		       2 << 8 | 0xff);
	  // Little endian: CA5, 4, 3, 2
	  cmd1_be = (addr_h << 16) | addr_l;
	  cmd->cmd1 = (((cmd1_be >> 24) & 0xff) |
		       (((cmd1_be >> 16) & 0xff) << 8) |
		       (((cmd1_be >> 8) & 0xff) << 16) |
		       (((cmd1_be >> 0) & 0xff) << 24));

          // Goto latency count
	  next_pc = (inst->prog_offset + hyperram_offset_count);
	  // Little endian: PC, data dir, length
	  cmd->cmd2 = next_pc << 24 | 0x00 << 16| len;

          // Goto read align, then read data
	  // Little endian: after align PC, align count, next PC
	  next_pc  = (inst->prog_offset + hyperram_offset_align);
	  next_pc2 = (inst->prog_offset + hyperram_offset_r_data);
	  cmd->cmd3 = next_pc2 << 24 | align_count << 8| next_pc;
	  break;

	case (HRAM_CMD_WRITE):
	  // Note that the caller will handle last unaligned write
	  // Little endian: CA1, CA0, cmd len [2], 0xff
	  cmd->cmd0 = (((addr_h >> 16) & 0xff) << 24 |
		       ((addr_h >> 24) & 0xff) << 16 |
		       2 << 8 | 0xff);

	  // Little endian: CA5, 4, 3, 2
	  cmd1_be = (addr_h << 16) | addr_l;
	  cmd->cmd1 = (((cmd1_be >> 24) & 0xff) |
		       (((cmd1_be >> 16) & 0xff) << 8) |
		       (((cmd1_be >> 8) & 0xff) << 16) |
		       (((cmd1_be >> 0) & 0xff) << 24));

          // Goto latency count
	  next_pc = (inst->prog_offset + hyperram_offset_count);
	  // Little endian: PC, data dir, length
	  cmd->cmd2 = next_pc << 24 | 0xFF << 16| len;

          // Goto write align, then write data
	  // Little endian: after align PC, align count, next PC
	  next_pc  = (inst->prog_offset + hyperram_offset_w_align);
	  next_pc2 = (inst->prog_offset + hyperram_offset_w_data);
	  cmd->cmd3 = next_pc2 << 24 | align_count << 8| next_pc;
	  break;

	case (HRAM_CMD_REGWRITE):
	  // Note: we do two extra CA cycles to write register data
	  // (Assumes 16 bit write data duplicated)
	  // Little endian: CA1, CA0, cmd len [4], 0xff
	  cmd->cmd0 = (((addr_h >> 16) & 0xff) << 24 |
		       ((addr_h >> 24) & 0xff) << 16 |
		       4 << 8 | 0xff);

	  // Little endian: CA5, 4, 3, 2
	  cmd1_be = (addr_h << 16) | addr_l;
	  cmd->cmd1 = (((cmd1_be >> 24) & 0xff) |
		       (((cmd1_be >> 16) & 0xff) << 8) |
		       (((cmd1_be >> 8) & 0xff) << 16) |
		       (((cmd1_be >> 0) & 0xff) << 24));

	  // Next command word (cmd2 is register data)
	  next_pc = (inst->prog_offset + hyperram_offset_start);
	  // Little endian: PC, data_dir (must be zero), len (should be zero)
	  cmd->cmd3 = next_pc << 24;
	  break;
	}
}


void hyperram_write_blocking_unaligned(const hyperram_inst_t *inst, uint32_t addr, uint8_t *src, uint len) {
  uint32_t mask, word, i, align_addr;
  uint32_t align;
  uint32_t *align_src;
  uint32_t first_len;
  uint32_t align_len;
  uint32_t align_len_word;

  // Convert byte quantities to words, then do initial write
  // We assume that the source is word aligned
  // Note that unaligned addesses are handled by write_blocking -
  // write will start with the address specified
  align_len = len >> 2;
  align_src = (uint32_t *)src;
  hyperram_write_blocking(inst, addr, align_src, len);  

  // See if there are remaining data bytes to be written
  // Could be due to:
  // length not word sized
  // unaligned data overflowed into next word
  // Calculate last destination address lsbs, and write up to that
  last_addr = (addr + len) & 0x3u;
  if (last_addr) {
    // Wait for aligned write to complete
    while (pio_sm_is_tx_fifo_empty(inst->pio, inst->sm) == false) {}

    // Make sure the last write is finished before writing byte masks
    sleep_us(1);

     // Write masks after last addr
     for (int i = 0; i < 4; i++) {
        mask = (i <= last_addr) ? 0 : -1;
        pio_sm_put_blocking(inst->pio, inst->sm_rwds, mask);
     }

     // Get last word
     last_src = (src + len - last_addr);
     for (int i = 0; i < last_addr; i++) {
        last_word = (*last_src++) << (8 * i);
     }

     // Write last word
     last_addr = (addr + len) & ~0x3u;
     hyperram_write_blocking(inst, last_addr, &last_word, 1);

     // Make sure it completes before continuing
     sleep_us(1);

   }

  
8-jul-2023:
Fixed syntax errors above, started memory test. Ran overnight without failures.
Now to try out the unaligned accesses...Bad news - we forgot that the unalign
count must be done in terms of half clocks, since we must be able to start
writing on either the rising edge or falling edge of the clock. Thus we
can't use the latency timer, since it counts whole clocks, and always exits
when the next data is to be written/read. So, the alignment task must be
part of the read/write task to correctly start pulling/pushing data at
the right clock phase.

Returning to layout for the moment: JLBPCB is having a $1/10 board special!
So, rev 1.2 fixes:
1) 180 rotation of SD card socket. Done.
2) Add reset push button. Skipped.
3) Add LED with jumper to GPIO 8 or 9. Skipped.
4) Add male connector foot print in parallel with J3. Done.
5) Add jumpers to reclaim unused SDIO pins: SD_DAT1/2 (GPIO 13/14). Done.
6) Possibles: tune length of PSRAM IO vs clk, additional J3 with serial xover.
   Skipped.

More radical changes for future board layouts:
1) Put RWDS next to DQ7. Allows out PINDIRS, 9 to change all of the pindirs,
   saving PIO instruction space.

Going back to coding:

datapump:

start: out pindirs, 8           ; cmd/xfer dir
       out X, 8                 ; cmd/xfer count
       out PC, 8                ; next pc
;3

align: out X, 16               ; Use remaining bytes as wait time
w_wait:
       set PINS, 1             ; Mask data
wait:  jmp !X, start
       irq wait 4
       jmp X--, wait
;+5=8

w_data:
       set PINS, 0              ; Unmask data
w_data_nm:
       out pins, 8  
       irq wait 4
       jmp X--, w_data_nm
       jmp !OSRE, align         ; Two bytes left after command
       jmp start
;+6=14

r_data:
       irq wait 4
       in pins, 8
       jmp X--, r_data
;       jmp start
;+3=17

ctl:

public start: ;                  ||
     mov ISR, NULL        side 0b10       ; Setup to read RWDS pin
next:
     out PINDIRS, 8       side 0b00       ; Make RWDS pin in/out
     out X, 16            side 0b00       ; Set length for CMD/ADR phase
;3
adr:
     wait 1 4                side 0b00       ; Signal data sm
     in PINS, 1           side 0b01 [6]   ; CA phase 0 write, get latency
     wait 1 4                side 0b00
     jmp X--, adr         side 0b00 [4]   ; CA phase 1 write
     out PC, 8                            ; Go to start or latency
;5+=8
latency:
     set Y, LAT_SHORT     side 0b01       ; Assume minimum latency     
     mov X, ISR           side 0b01       ; Get latency status
     jmp !X, count        side 0b01 [3]   ; Skip if RWDS set for min latency
     set Y, LAT_LONG      side 0b01       ; Max latency
;4+=12
count:
     jmp !Y,  next        side 0b00 [5]   ; Exit if count is zero
     jmp Y--, count       side 0b01 [5]   ; Run down count
;2+=14

; 17 + 14 = 31 
; Could save two instructions via side set of RWDS in datapump code

9-jul-2023:

I'm thinking about adding composite video and RS232 transceivers to the
board to make it a complete workstation. Or maybe a seperate board?
Six GPIOs are available:
One allocation:
1 - video
2 - composite sync
3/4 - UART 0 RX/TX (keyboard)
5/6 - UART 1 RX/TX (mouse)

Another:
1 - video
2/3 - H/V sync
4/5 - UART 0
6 - PWM/SPDIF audio

datapump/ctl FIFO format:
07:00 - RWDS/data pin dir
23:08 - cmd len (half words - 1 for ctl, bytes - 1 for data)
31:24 - next PC

CMD seq:
cfg reg write:  
0x00  (RWDS input to read latency flag)
1 (CA (6 bytes) + 2 data bytes)
address of start

datapump:
0xff (output cmd + data)
7 (byte count of cmd + data)
address of w_data_nm
2nd word:
CA 3, CA 2, CA 1, CA 0
3rd word:
data h, data l, CA 5, CA 4

mem rd:
first word:
0x00 (RWDS input)
1 (CA (6 bytes) + 2 wait count bytes)
address of latency
2nd word
0x00 (RWDS input)
<data xfer len - 1, in 16 bit halfwords, but must be multiple of 4>
address of start


datapump:
1st word: send CA cmd + CA data
0xff
7 
w_data_nm
2nd word:
CA 3, CA 2, CA 1, CA 0
3rd word:
0x00, 0x01, CA 5, CA 4 (use wait count to align with write data latency)
4th word: get read data
0x00
<xfer_len, in bytes, but must be multiple of 4>
r_data address

mem wr:
first word: send CA cmd + CA data
0xff
7 
w_data_nm
2nd word
0x00 (RWDS input)
<data xfer len - 1, in 16 bit halfwords, but must be multiple of 4>
address of start


datapump:
0xff
5
w_data_nm
2nd word:
CA 3, CA 2, CA 1, CA 0
3rd word:
0x00, 0x00, CA 5, CA 4
4th word:
0xff
<xfer_len - 1, in bytes, but must be multiple of 2>
w_data_nm

11-jul-2023:

Realized that we need a method of pulling/pushing data from the TX/RX fifos
to finish the transfer when doing unaligned operations.

Trial code:
public w_data:
       set PINS, 0              ; Unmask data
public w_data_nm:      
       out pins, 8     side 0b0  [7] ; send data
       irq wait 4      side 0b0         ; Signal control SM, and wait for data
       jmp X--, w_data_nm       ; Do all requested data
       jmp Y, start             ; if zero, don't empty OSR
       mov OSR, NULL            ; Push all zeros - null command
w_next:
       jmp start        side 0b0   ; Otherwise, wait for new command
;+6=14
;+7
public r_data:
       irq wait 4      side 0b0 [3] ; Wait for control SM
       in pins, 8      side 0b1     ; Get data from PSRAM
       jmp X--, r_data          ; Continue until request completed
       jmp Y, start
       push
;       jmp start
;+3=17
;+5

Reworking:

public start: ;                  ||
     set PINDIRS, 0       side 0b10 [5]   ; Make RWDS pin input 
     set Y, LATENCY       side 0b00       ; Assume maximum latency     
     jmp PIN, next        side 0b00       ; Skip if RWDS set for max latency
     set Y, LAT_SHORT     side 0b00       ; Short latency
;4
next:
     out X, 16            side 0b00       ; Set length for CMD/ADR phase
     jmp !OSRE, aligned   side 0b00       ; If we're empty here, then unaligned
     jmp lat_cnt          side 0b00       ; Use unaligned data as count
aligned:
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
     out PC, 8            side 0b00       ; Jump to command [addr, start, rw]
;+5=9
;w_data:
;     mov Y, NULL          side 0b00       ; Set length for CMD/ADR phase
;     set PINDIRS, 1       side 0b00 [5]   ; Make RWDS pin output 
adr:
     out PINS, 8          side 0b00 [4]   ; Setup write of cmd/adr
     nop                  side 0b01       ; CA phase 0 write
     out PINS, 8          side 0b01 [4] 
     jmp X--, adr         side 0b00       ; CA phase 1 write
;+6=11
count:
     mov X, Y             side 0b00       ; Setup to re-use latency counter
lat_cnt:
     jmp !X, next         side 0b00 [5]   ; Wait for latency to expire
     jmp X--, lat_cnt     side 0b01 [5]
;+3=14

; Pipelined read data sampling
public r_data:
     in PINS, 8           side 0b01 [6]    ; CA phase 0 
     in PINS, 8           side 0b00 [5]    ; CA phase 1
     jmp X--, r_data      side 0b00        ; Continue until all data captured 
     jmp start            side 0b10
;+4=18

public w_data:
     set PINDIRS, 1       side 0b00        ; Make RWDS pin output 
w_loop:
     irq clear 4          side 0b00        ; Setup RWDS pin
     jmp PIN, w_next_l    side 0b00 [3]    ; If RWDS is high, don't pull
     out PINS, 8          side 0b00
w_next_l:
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     jmp PIN, w_next_h    side 0b01 [4]    ; If RWDS is high, don't pull
     out PINS, 8          side 0b01  
w_next_h:
     jmp X--, w_loop      side 0b00        ; CA phase 1 write

;+5=23
; Control RWDS pin
; Uses pull noblock side effect: copy X to OSR if no data available
; This allows non-masked writes to be done without writing to
; this state machine.
start:
    mov X, NULL                           ; Assume no masking
    pull noblock                          ; Get mask, if available
    out PINS, 8
    out Y, 24
count:
    irq wait 4                            ; wait for signal
    jmp Y--, count
;6
;23+6 = 29


Above uses the following:
Thought experiment:
   RWDS Control word:
   pin state 8 bits
   count 24 bits
Only active when writing
Seperate state machine, triggered by IRQ

in/out pins set to rwds

In the data writing portion
jump pin set to RWDS
     irq 4
     jmp PIN, next ; If RWDS is high, don't pull from FIFO
     out PINS, 8
next_l:
     irq 4
     jmp PIN, next_h ; If RWDS is high, don't pull from FIFO
     out PINS, 8
next_h:




Note: make one big program, and choose carefully were to start each SM.
The side set stuff will be interesting. Delays should also be interesting.
Or maybe just hack the pio header file? Does the assembler replace
jump target addresses with post-linked values? I.e. if I put zero as
a target, will it change it?

Actually, can we integrate RWDS with mainline? No, not enough resources
to hold high/low/high counts.

12-jul-2023:

Sent out rev 1.2 board for fabrication, as well as the hot plate reflow
controller (reflow964)

Thought for size reduction: re-use the addr loop (with RWDS output enable)
as latency counter.

Fails - need to account for zero, one or latency count delays...

Try again, replacing adr loop with write loop - doesn't work, as
RWDS is high or low, depending on latency, during addr/cmd portion of
transaction.

Re-thinking data/control plane. Sharing common dispatch code, requires
side set pin allocation commonality between state machines.


start: out pindirs, 8           ; cmd/xfer dir
       out X, 8                 ; cmd/xfer count
       out PC, 8                ; next pc
;3

align: out X, 16               ; Use remaining bytes as wait time
w_wait:
       set PINS, 1             ; Mask data
wait:  jmp !X, start
       irq wait 4
       jmp X--, wait
;+5=8

w_data:
       set PINS, 0              ; Unmask data
w_data_nm:
       out pins, 8  
       irq wait 4
       jmp X--, w_data_nm
       jmp !OSRE, align         ; Two bytes left after command
       jmp start
;+6=14

r_data:
       irq wait 4
       in pins, 8
       jmp X--, r_data
;       jmp start
;+3=17

ctl:

public start: ;                  ||
     mov ISR, NULL        side 0b10       ; Setup to read RWDS pin
next:
     out PINDIRS, 8       side 0b00       ; Make RWDS pin in/out
     out X, 16            side 0b00       ; Set length for CMD/ADR phase
;3
adr:
     wait 1 4                side 0b00       ; Signal data sm
     in PINS, 1           side 0b01 [6]   ; CA phase 0 write, get latency
     wait 1 4                side 0b00
     jmp X--, adr         side 0b00 [4]   ; CA phase 1 write
     out PC, 8                            ; Go to start or latency
;5+=8
latency:
     set Y, LAT_SHORT     side 0b01       ; Assume minimum latency     
     mov X, ISR           side 0b01       ; Get latency status
     jmp !X, count        side 0b01 [3]   ; Skip if RWDS set for min latency
     set Y, LAT_LONG      side 0b01       ; Max latency
;4+=12
count:
     jmp !Y,  next        side 0b00 [5]   ; Exit if count is zero
     jmp Y--, count       side 0b01 [5]   ; Run down count
;2+=14





15-jul-2023:

Common start routines:
start: out pindirs, 8           ; cmd/xfer dir
       out X, 8                 ; cmd/xfer count
       out PC, 8                ; next pc

for data machine, pins are db7:0
                  side pins: none
                  jump pin: RWDS

for ctl machine, pin is RWDS
                  side pins: CE, CLK

So:
ctl:

data machine:
;w_data:
     mov Y, NULL          side 0b00       ; No latency when data is done
     set PINDIRS, 1       side 0b00 [5]   ; Make RWDS pin output 

w_loop:
     irq clear 4          side 0b00        ; Setup RWDS pin, phase 0
     jmp !Y, out_l        side 0b00 [3]    ; No latency counter, so pull
     jmp PIN, w_next_l    side 0b00        ; If RWDS is high, don't pull
out_l:
     out PINS, 8          side 0b00
w_next_l:
     irq clear 4          side 0b01        ; CA phase 0 write, setup RWDS ph 1
     jmp !Y, out_h        side 0b01 [4]    ; No latency counter, so pull
     jmp PIN, w_next_h    side 0b01        ; If RWDS is high, don't pull
out_h:
     out PINS, 8          side 0b01  
w_next_h:
     jmp X--, w_loop      side 0b00        ; CA phase 1 write

count:
     mov X, Y             side 0b00       ; Setup to re-use latency counter
lat_cnt:
     jmp !X, next         side 0b00 [5]   ; Wait for latency to expire
     jmp X--, lat_cnt     side 0b01 [5]

Can we use the side set enable feature to minimize the repeated instruction
sequence? We'll lose a bit, though:
en, side <1:0>, del: <1:0>
Could make CE output bit only, and lose two instructions.
Actually, use mov PINS, ~PINS to toggle CLK, and no side-set pins
Has to be done on a seperate SM, with only CLK as an input/output pin



start:
    set PINDIRS, 0       side 0b10 [5]   ; Make RWDS pin input 
    set Y, LATENCY       side 0b00 [3]   ; Assume maximum latency     
    jmp PIN, next        side 0b00       ; Skip if RWDS set for max latency
    set Y, LAT_SHORT     side 0b00       ; Short latency
;4

next:
     out PINDIRS, 8       side 0b00       ; Set CMD/Data pins direction
     out X, 16            side 0b00       ; Set length for CMD/ADR phase
     out PC, 8            side 0b00       ; Jump to command [addr, start, rw]
;+3=7

w_data:
     set PINDIRS, 1       side 0b00 [5]   ; Make RWDS pin output 
     mov Y, NULL                          ; No latency when loop is done
w_loop:
     wait 1 irq 5                  ; Wait until delay counter ready
     irq clear 4                 ; Setup RWDS
;+4=11
     jmp PIN, w_next             ; If RWDS is high, don't pull
w_out:
     out PINS, 8            
w_next:
;+2=13
     wait 0 irq 5              ; Stall until delay counter is done
     jmp X--, w_loop             
     jmp !OSRE, unaligned side 0b00       ; If not empty, then cmd phase
     jmp lat_cnt
;+4=17
unaligned:
     out Y, 16            side 0b00       ; Use unaligned data as count
lat_cnt:
     jmp !Y, next         side 0b00 [5]   ; Wait for latency to expire
     jmp Y--, lat_cnt     side 0b01 [5]
;+4=21

r_data:
; Pipelined read data sampling
public r_data:
     in PINS, 8           side 0b01 [6]    ; CA phase 0 
     in PINS, 8           side 0b00 [5]    ; CA phase 1
     jmp X--, r_data      side 0b00        ; Continue until all data captured 
     jmp start            side 0b10
;+4=25

toggle:
    irq wait 1 irq 5    [7]       ; Wait until request to start clock change
    mov PINS, ~PINS              ; Toggle clock after above delay
;+2=27

start:
    mov X, NULL                           ; Assum no count
    pull noblock                          ; Get mask, if available
    out PINS, 8
    out Y, 24
count:
    jmp !Y, start
    irq wait 4                            ; wait for signal
    jmp Y--, count
;7
;27+7 = 34


Rules for PIO outputs, from the datasheet:
For each individual GPIO output (level and direction separately), PIO 
considers all 8 writes that may have occurred on that cycle, and applies
the write from the highest-numbered state machine. If the same state
machine performs a SET/OUT and a side-set on the same GPIO simultaneously,
the side-set is used. If no state machine writes to this GPIO output, its value
does not change from the previous cycle.

So, we can clear clk from SM0 sideset, and toggle it via mov instruction
from SM>0. Would have to use the enable side-set feature.

Could also use the toggle SM as a pacing machine via wait/irq instructions.



26-jul-2023:

Built rev 1.2 board successfully. Now making rev 1.1 into picoprobe:

From: https://github.com/raspberrypi/picoprobe
cd psram_wren/apps
git clone https://github.com/raspberrypi/picoprobe.git
git submodule update --init

cmake -B build
make -C build

Need to define custom board config, based on board_example_config:
board_custom_config.h:

#ifndef BOARD_CUSTOM_H_
#define BOARD_CUSTOM_H_

/* Direct connection - SWCLK/SWDIO on two GPIOs */
#define PROBE_IO_RAW

/* Include CDC interface to bridge to target UART. Omit if not used. */
#define PROBE_CDC_UART

#define PROBE_SM 0
// Use emu board 3v3 I/Os for SWD: J7, select GPIO16/17 via jumpers 1 & 2
#define PROBE_PIN_OFFSET 16

/* PIO config for PROBE_IO_RAW */
#if defined(PROBE_IO_RAW)
#define PROBE_PIN_SWCLK (PROBE_PIN_OFFSET + 0)
#define PROBE_PIN_SWDIO (PROBE_PIN_OFFSET + 1)
#endif

#if defined(PROBE_CDC_UART)
#define PICOPROBE_UART_TX 8
#define PICOPROBE_UART_RX 9

#define PICOPROBE_UART_INTERFACE uart1
#define PICOPROBE_UART_BAUDRATE 115200
#endif

/* LED config - some or all of these can be omitted if not used */
//#define PICOPROBE_USB_CONNECTED_LED 2
//#define PICOPROBE_DAP_CONNECTED_LED 15
//#define PICOPROBE_DAP_RUNNING_LED 16
//#define PICOPROBE_UART_RX_LED 7
//#define PICOPROBE_UART_TX_LED 8

#define PROBE_PRODUCT_STRING "Custom board as Pico Probe"

#endif




Add to picoprobe/CMakeLists:

option (CUSTOMPROBE "compile for a custom board" OFF)
if (CUSTOMPROBE)
    target_compile_definitions (picoprobe PRIVATE 
	CUSTOMPROBE=1
    )
    set_target_properties(picoprobe PROPERTIES 
        OUTPUT_NAME "customprobe"
    )
endif ()

build with:
cmake -B build -DCUSTOMPROBE=1
make -C build
sudo picotool load build/customprobe.elf

 This is a CMSIS protocol board, so have to start via:

#!/bin/bash
source $PWD/source_this
export OPENOCD_PATH=$PICO_SDK_PATH/../../openocd
cd $OPENOCD_PATH; sudo src/openocd -f /home/rscott/bindto.cfg -f interface/cmsis-dap.cfg -f target/rp2040.cfg -c "adapter speed 5000" -s tcl

note: bindto.cfg contents:
bindto 0.0.0.0


Once started, behaves the same as with old picoprobe, i.e. telnet localhost
4444 works, as does ncat...

Tested picoprobe UART port. Seems to work ok, but wonder if it can handle
higher throughput vs. the old version.

Note: Add to CMakeLists to enable UART output (e.g. blink):
# enable usb output, disable uart output
pico_enable_stdio_usb(blink 0)
pico_enable_stdio_uart(blink 1)

target_compile_definitions(blink PRIVATE
  PICO_DEFAULT_UART=1
  PICO_DEFAULT_UART_TX_PIN=8
  PICO_DEFAULT_UART_RX_PIN=9
)

Tried the SD card command_line example - SPI mode works, SDIO doesn't (same
as before).

Tested ethernet port, using the http server example. Still works.

28-jul-2023:

Using new picoprobe with VMware workstation. It detected the probe as a
VMware virtual mouse. To fix this, close the VMware session, delete the USB
controller, then re-add it, and restart the virtual machine. Should fix
the problem:
lsusb
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 004: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 003 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 003 Device 005: ID 2e8a:000c Raspberry Pi Custom board as Pico Probe
Bus 003 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 002: ID 0e0f:0002 VMware, Inc. Virtual USB Hub
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

Also needed to do:
fuser -k 6666/tcp
prior to starting openocd.

29-jul-2023:

Laptop failed to connect to USB devices. Google search showed two solutions:
1) Press the pinhole reset button.
2) Go to the BIOS and disable the internal battery.

Did (1), no difference. Did (2), the ports sprang to life!

Now trying to get pico-rv32ima to work. Did a
git clone  --recurse-submodules https://github.com/tvlad1234/pico-rv32ima.git
in the psram_wren/apps subdir to start.

Edited apps/CMakeLists:
add_subdirectory(pico-rv32ima)

Edited psram_wren/apps/pico-rv32ima/pico-rv32ima/CMakeLists.txt:
# Enable SRAM only executable
pico_set_binary_type(mem_test no_flash)

#pico_set_binary_type(pico-rv32ima copy_to_ram)

Project built successfully. Now editing:
pico-rv32ima/pico-rv32ima/rv32_config.h
Changed SD card interface
Disabled PS2 & LCD interface
Ifdef'd out the original PSRAM interface

30-jul-2023:

Thinking about variable voltage dac arch for composite video out:

https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Composite_Video.svg/300px-Composite_Video.svg.png

Blanking goes from 0 to 0.285v
Ref black starts at 0.339v
Ref white is 1.00v
Max white is 1.073v

So video ranges from 1.0 to 0.339v or 0.661v swing

1 bit video dac:
00 - 0.0v
01 - 0.285v
10 - 0.339v
11 - 1.0v

So: bit 0 switches either:
0.285v or 0.661v

2 bit video dac:
000 - 0.0v
0x1 - 0.285v
100 - 0.339v
101 - 0.339 + .333  * 0.661 = 0.559
110 - 0.339 + .667  * 0.661 = 
111 - 0.339 + 1.000 * 0.661 = 

1280p pixel time is 13.5 ns +/- 0.5%
pixel clk is 74.250 MHz

Modify typical DAC structure.

1-aug-2023:

Debugging strange character output when using serial port:
index: 14                                                                       
strlen: 20                                                                      
EF0123456789ABCDEF                                                              
                  index: 13                                                     
strlen: 21                                                                      
index: 126789ABCDEF                                                             
strlen: 22                                                                      
CDEF0123456789ABCDE                                                             
                   index: 11                                                    
strlen: 23

Changed in console.c:
void console_putc(char c)
{
#if CONSOLE_CDC || CONSOLE_UART
  //queue_try_add(&ser_screen_queue, &c);
  queue_add_blocking(&ser_screen_queue, &c);
#endif

This fixed the problem:
index: 13                                                                       
strlen: 21                                                                      
DEF0123456789ABCDEF                                                             
index: 12                                                                       
strlen: 22                                                                      
CDEF0123456789ABCDEF                                                            
index: 11                                                                       
strlen: 23                                                                      
BCDEF0123456789ABCDEF                                                           
index: 10

There are other try_add calls in console.c - may affect console input.
Note that the try_add calls didn't allow for retries when add failed.


2-aug-2023:

So, added hyperram routines to pico-rv32ima. Observed failures, instrumented
loadimage routine:
while (imageSize >= 4096)
    {
        fr = f_read(&imageFile, buf, 4096, NULL);
        if (FR_OK != fr)
            return fr;
        accessPSRAM(addr, 4096, true, buf);

        accessPSRAM(addr, 4096, false, ver_buf);
	for (int i = 0; i < 4096; i++) {
	  if (buf[i] != ver_buf[i]) {
	    console_printf("%04d Fail exp/act: %02x %02x\n\r",
			   i, buf[i], ver_buf[i]);
	    fail_count++;
	    if (fail_count > 10) {
	      for (int j = 100; j < 128; j+=4) {
		console_printf("%02x%02x%02x%02x ",
			       buf[j+3], buf[j+2], buf[j+1], buf[j]);
	      }
	      while(1) {sleep_ms(1000);}
	    }
	  }
	}

Results:
0000 Fail exp/act: 6f 67                                                        
0018 Fail exp/act: 2c 24                                                        
0049 Fail exp/act: 49 41                                                        
0071 Fail exp/act: ae a6                                                        
0088 Fail exp/act: 6f 67                                                        
0090 Fail exp/act: df d7                                                        
0091 Fail exp/act: ff f7                                                        
0100 Fail exp/act: 0f 07                                                        
0104 Fail exp/act: ef e7                                                        
0107 Fail exp/act: 0a 02                                                        
0123 Fail exp/act: ff f7                                                        
0000100f 0a8000ef 00000517 01c50513 30551073 fff00513 3b051073

Put into mem_test/main.c:
uint32_t wdata[] = {
    0x0000100f, 0x0a8000ef, 0x00000517, 0x01c50513,
    0x30551073, 0xfff00513, 0x3b051073, 0xdeadbeef};

  hyperram_write_blocking(&hram, 0x0, wdata, 8);
  hyperram_read_blocking(&hram, 0x0, rdata, 8);
  printdataint(wdata, 8);
  printdataint(rdata, 8);

Results:
0000100f 0a8000ef 00000517 01c50513 30551073 fff00513 3b051073 deadbeef         
0000100f 0a8000ef 00000517 01c50513 30551073 fff00513 3b051073 deadbeef

So, why does it fail under rv32ima, but not mem_test? One difference
is rv32ima runs on core 1, and mem_test runs on core 0. Also, SDcard
SPI port is active on rv32ima...

Did try on both rev 1.1 and 1.2, same results observed. Repeated writes
and reads make no difference. Nor does changing the address.

So, it looks like bit 3 is always zero:
0000 Fail exp/act: ff f7                                                        
0001 Fail exp/act: ff f7                                                        
0002 Fail exp/act: ff f7                                                        
0003 Fail exp/act: ff f7                                                        
0004 Fail exp/act: ff f7                                                        
0005 Fail exp/act: ff f7                                                        
0006 Fail exp/act: ff f7                                                        
0007 Fail exp/act: ff f7                                                        
0008 Fail exp/act: ff f7                                                        
0009 Fail exp/act: ff f7                                                        
0010 Fail exp/act: ff f7 

Need to check that GPIO25 (bit 3) isn't allocated somewhere else! This is
the default LED pin, and it may be grabbed by SPI. There's this little
gem in spi.h:


#ifndef NO_PICO_LED
#  define USE_LED 1
#endif

#if USE_LED
#  define LED_PIN 25
#  define LED_INIT()                     \
    {                                    \
        gpio_init(LED_PIN);              \
        gpio_set_dir(LED_PIN, GPIO_OUT); \
    }
#  define LED_ON() gpio_put(LED_PIN, 1)
#  define LED_OFF() gpio_put(LED_PIN, 0)
#else
...

So, how to pass in NO_PICO_LED to the spi driver compile?
Add to pico-rv32ima/pico-rv32ima/CMakelists:
target_compile_definitions(pico-rv32ima PUBLIC NO_PICO_LED)

Once this was done:
r: 002aa000 4096                                                                
w: 002ab000 4096                                                                
r: 002ab000 4096                                                                
w: 002ac000 4096                                                                
r: 002ac000 4096                                                                
w: 002ad000 440                                                                 
Image loaded sucessfuly!                                                        
w: 00fffa00 1536

So, fixed the problem.
First boot:

PSRAM init OK!                                                                  
SD mount OK!                                                                    
Image loaded sucessfuly!                                                        
dtb loaded sucessfuly!                                                          
Linux version 6.1.14mini-rv32ima (user@buildvm) (riscv32-buildroot-linux-uclibc3
Machine model: riscv-minimal-nommu,qemu                                         
Zone ranges:                                                                    
  Normal   [mem 0x0000000080000000-0x0000000080ffefff]                          
Movable zone start for each node                                                
Early memory node ranges                                                        
  node   0: [mem 0x0000000080000000-0x0000000080ffefff]                         
Initmem setup node 0 [mem 0x0000000080000000-0x0000000080ffefff]                
riscv: base ISA extensions aim                                                  
riscv: ELF capabilities aim                                                     
Built 1 zonelists, mobility grouping off.  Total pages: 4063                    
Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0     
Unknown kernel command line parameters "earlycon=uart8250,mmio,0x10000000,10000.
Dentry cache hash table entries: 2048 (order: 1, 8192 bytes, linear)            
Inode-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)             
mem auto-init: stack:off, heap alloc:off, heap free:off                         
Memory: 13340K/16380K available (1445K kernel code, 269K rwdata, 146K rodata, 8)
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1                      
NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
riscv-intc: 32 local interrupts mapped                                          
clint: clint@11000000: timer running at 1000000 Hz                              
clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df4s
sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns 
Console: colour dummy device 80x25                                              
printk: console [hvc0] enabled                                                  
Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00)
pid_max: default: 4096 minimum: 301                                             
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)             
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)        
devtmpfs: initialized                                                           
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 191s
clocksource: Switched to clocksource clint_clocksource                          
workingset: timestamp_bits=30 max_order=12 bucket_order=0                       
Freeing unused kernel image (initmem) memory: 872K                              
This architecture does not have kernel memory protection.                       
Run /init as init process                                                       
Machine model: riscv-minimal-nommu,qemu                                         
Zone ranges:                                                                    
  Normal   [mem 0x0000000080000000-0x0000000080ffefff]                          
Movable zone start for each node                                                
Early memory node ranges                                                        
  node   0: [mem 0x0000000080000000-0x0000000080ffefff]                         
Initmem setup node 0 [mem 0x0000000080000000-0x0000000080ffefff]                
riscv: base ISA extensions aim                                                  
riscv: ELF capabilities aim                                                     
Built 1 zonelists, mobility grouping off.  Total pages: 4063                    
Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0     
Unknown kernel command line parameters "earlycon=uart8250,mmio,0x10000000,10000.
Welcome to pico-rv32ima Linux
Jan  1 00:00:07 login[32]: root login on 'console'

dmesg
Linux version 6.1.14mini-rv32ima (user@buildvm) (riscv32-buildroot-linux-uclibc3
Machine model: riscv-minimal-nommu,qemu
Zone ranges:
  Normal   [mem 0x0000000080000000-0x0000000080ffefff]
Movable zone start for each node
Early memory node ranges
  node   0: [mem 0x0000000080000000-0x0000000080ffefff]
Initmem setup node 0 [mem 0x0000000080000000-0x0000000080ffefff]
riscv: base ISA extensions aim
riscv: ELF capabilities aim
pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
pcpu-alloc: [0] 0 
Built 1 zonelists, mobility grouping off.  Total pages: 4063
Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0
Unknown kernel command line parameters "earlycon=uart8250,mmio,0x10000000,10000.
Dentry cache hash table entries: 2048 (order: 1, 8192 bytes, linear)
Inode-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
mem auto-init: stack:off, heap alloc:off, heap free:off
Memory: 13340K/16380K available (1445K kernel code, 269K rwdata, 146K rodata, 8)
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
riscv-intc: 32 local interrupts mapped
clint: clint@11000000: timer running at 1000000 Hz
clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df4s
sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns
Console: colour dummy device 80x25
printk: console [hvc0] enabled
Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00)
pid_max: default: 4096 minimum: 301
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
devtmpfs: initialized
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 191s
clocksource: Switched to clocksource clint_clocksource
workingset: timestamp_bits=30 max_order=12 bucket_order=0
Freeing unused kernel image (initmem) memory: 872K
This architecture does not have kernel memory protection.
Run /init as init process
  with arguments:
    /init
  with environment:
    HOME=/
    TERM=linux
    earlycon=uart8250,mmio,0x10000000,1000000
~ # 

rebooting with rv32_config.h ram size increased to 32MB:
                           PSRAM init OK!
SD mount OK!
Image loaded sucessfuly!
dtb loaded sucessfuly!
Linux version 6.1.14mini-rv32ima (user@buildvm) (riscv32-buildroot-linux-uclibc3
Machine model: riscv-minimal-nommu,qemu
Zone ranges:
  Normal   [mem 0x0000000080000000-0x0000000081ffefff]
Movable zone start for each node
Early memory node ranges
  node   0: [mem 0x0000000080000000-0x0000000081ffefff]
Initmem setup node 0 [mem 0x0000000080000000-0x0000000081ffefff]
riscv: base ISA extensions aim
riscv: ELF capabilities aim
Built 1 zonelists, mobility grouping on.  Total pages: 8127
Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0
Unknown kernel command line parameters "earlycon=uart8250,mmio,0x10000000,10000.
Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)
Inode-cache hash table entries: 2048 (order: 1, 8192 bytes, linear)
mem auto-init: stack:off, heap alloc:off, heap free:off
Memory: 29584K/32764K available (1445K kernel code, 269K rwdata, 146K rodata, 8)
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
riscv-intc: 32 local interrupts mapped
clint: clint@11000000: timer running at 1000000 Hz
clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df4s
sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns
Console: colour dummy device 80x25
printk: console [hvc0] enabled
Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00)
pid_max: default: 4096 minimum: 301
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
devtmpfs: initialized
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 191s
clocksource: Switched to clocksource clint_clocksource
workingset: timestamp_bits=30 max_order=13 bucket_order=0
Linux version 6.1.14mini-rv32ima (user@buildvm) (riscv32-buildroot-linux-uclibc3
Machine model: riscv-minimal-nommu,qemu
Zone ranges:
  Normal   [mem 0x0000000080000000-0x0000000081ffefff]
Movable zone start for each node
Early memory node ranges
  node   0: [mem 0x0000000080000000-0x0000000081ffefff]
Initmem setup node 0 [mem 0x0000000080000000-0x0000000081ffefff]
riscv: base ISA extensions aim
riscv: ELF capabilities aim
Built 1 zonelists, mobility grouping on.  Total pages: 8127
Kernel command line: earlycon=uart8250,mmio,0x10000000,1000000 console=hvc0
Unknown kernel command line parameters "earlycon=uart8250,mmio,0x10000000,10000.
Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)
Inode-cache hash table entries: 2048 (order: 1, 8192 bytes, linear)
mem auto-init: stack:off, heap alloc:off, heap free:off
Memory: 29584K/32764K available (1445K kernel code, 269K rwdata, 146K rodata, 8)
SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
riscv-intc: 32 local interrupts mapped
clint: clint@11000000: timer running at 1000000 Hz
clocksource: clint_clocksource: mask: 0xffffffffffffffff max_cycles: 0x1d854df4s
sched_clock: 64 bits at 1000kHz, resolution 1000ns, wraps every 2199023255500ns
Console: colour dummy device 80x25
printk: console [hvc0] enabled
Calibrating delay loop (skipped), value calculated using timer frequency.. 2.00)
pid_max: default: 4096 minimum: 301
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
devtmpfs: initialized
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 191s
clocksource: Switched to clocksource clint_clocksource
workingset: timestamp_bits=30 max_order=13 bucket_order=0
Freeing unused kernel image (initmem) memory: 872K
This architecture does not have kernel memory protection.
Run /init as init process

from dmesg:
Memory: 29584K/32764K available (1445K kernel code, 269K rwdata, 146K rodata, 8)

I wonder why it's not 32768?

So, now on to R3000 emulation!
From: http://dmitry.gr/?r=05.Projects&proj=33.%20LinuxCard

Originial sources stored in:
~/misc/hw/raspi/pico/projects/linuxCard/ref/LinuxCard/

We will skip making a boot loader, as we'll use the RP2040 infrastructure to
update the firmware image. 

The emulator is contained in cpuAsm.S, and ARMv6-M specific parts are in
cpuMO.inc.

First, let's try to compile the emulator in the wren app environment.

3-aug-2023:
Had to replace timebase.c with version that uses RP sdk. Old version
used CMSIS, which isn't supported by RP2040 sdk.

Stubbed out ucHw.h functions, in ucHwRP2040.c
Also did this for:
#  spiRamAtsamd21.c
  timebase_rp2040.c
#  ucHwAtsamd21.c
  ucHwRP2040.c
  sd.c
#  usartAtsamd21.c
  usartRP2040.c
#  ds1287atsamd21.c
  ds1287RP2040.c
#  usbDev.c
  usbDevRP2040.c  
  cpuAsm.S
#  sdHwAtsamd21spi.c
  sdHwRP2040spi.c  


6-aug-2023:

Bought 7" NTSC/VGA/HDMI monitor.

Driving VGA requires 0.7v across 75 ohms. We'll use the 1.8v outputs,
saving the 3.3v outputs for H/V syncs. (On rev 1.2, use the SD_DAT_1,2_3v3 pins)

Assuming double termination, and driving all three colors:
1/(1/75 + 1/75 + 1/75 + 1/75) = 18.75 ohms.

---- R1 ----+---- VGA
            |
            R2 18.75
	    |
	   GND

So, to get 0.70 v across 18.75 ohms:
v = ir, 0.7 = i*18.75, or 0.7/18.75 = 37.3 mA. Too high for RP2040 to drive
directly.
If we drive just the monitor termination:
0.7/75 = 9.3 mA.

Computing R1:
(1.8 - 0.7) = 1.1v
1.1 = 0.0093 * R1, R1 = 118.3 ohms

Checking:
i = 1.8/(118.3 + 75) = .0093 A

Using 120 ohms, as the closest value.

7-aug-2023:

Measured 1.54 V at green output port
Measured 620 mV at vga green output.

Default rp2040 drive strength is 4 mA. Change to 12 mA.

2ma:  1.30v 504mV  
4ma:  1.54v 592mV
8ma:  1.62v 624mv
12ma: 1.68v 656mv

With cable and monitor plugged int:
Rise time measured at connector is 35 ns.
Fall time measured at connector is 25 ns.

No cable/monitor:
P-P Voltage is: 1.86v
Rise time measured at connector is 14 ns.
Fall time measured at connector is 13 ns.


1024x768 @ 60 Hz timing:

Screen refresh rate	60 Hz
Vertical refresh	48.363095238095 kHz
Pixel freq.	65.0 MHz
Horizontal timing (line)
Polarity of horizontal sync pulse is negative.

Scanline part	Pixels	Time [µs]
Visible area	1024	15.753846153846
Front porch	24	0.36923076923077
Sync pulse	136	2.0923076923077
Back porch	160	2.4615384615385
Whole line	1344	20.676923076923
Vertical timing (frame)
Polarity of vertical sync pulse is negative.

Frame part	Lines	Time [ms]
Visible area	768	15.879876923077
Front porch	3	0.062030769230769
Sync pulse	6	0.12406153846154
Back porch	29	0.59963076923077
Whole frame	806	16.6656

So:
65 MHz is 15.384 ns
Rise + fall: 35+25ns = 60ns or 16 MHz. (With cable)
Rise + fall: 14+13ns = 27ns or 37 MHz. (No cable)

Also, tried setting slew rate to fast, but didn't notice any difference.

Found that H/V sync only go to 1v or so. The RP VGA example has 47 ohm
resistors in series; will add them.

640 x 480 @60 Hz
Screen refresh rate	60 Hz
Vertical refresh	31.46875 kHz
Pixel freq.	25.175 MHz
Horizontal timing (line)
Polarity of horizontal sync pulse is negative.

Scanline part	Pixels	Time [µs]
Visible area	640	25.422045680238
Front porch	16	0.63555114200596
Sync pulse	96	3.8133068520357
Back porch	48	1.9066534260179
Whole line	800	31.777557100298
Vertical timing (frame)
Polarity of vertical sync pulse is negative.

Frame part	Lines	Time [ms]
Visible area	480	15.253227408143
Front porch	10	0.31777557100298
Sync pulse	2	0.063555114200596
Back porch	33	1.0486593843098
Whole frame	525	16.683217477656

800x600 @ 72 Hz
General timing
Screen refresh rate	72 Hz
Vertical refresh	48.076923076923 kHz
Pixel freq.	50.0 MHz
Horizontal timing (line)
Polarity of horizontal sync pulse is positive.

Scanline part	Pixels	Time [µs]
Visible area	800	16
Front porch	56	1.12
Sync pulse	120	2.4
Back porch	64	1.28
Whole line	1040	20.8
Vertical timing (frame)
Polarity of vertical sync pulse is positive.

Frame part	Lines	Time [ms]
Visible area	600	12.48
Front porch	37	0.7696
Sync pulse	6	0.1248
Back porch	23	0.4784
Whole frame	666	13.8528

1024 x 768 @ 70 Hz

Screen refresh rate	70 Hz
Vertical refresh	56.475903614458 kHz
Pixel freq.	75.0 MHz
Horizontal timing (line)
Polarity of horizontal sync pulse is negative.

Scanline part	Pixels	Time [µs]
Visible area	1024	13.653333333333
Front porch	24	0.32
Sync pulse	136	1.8133333333333
Back porch	144	1.92
Whole line	1328	17.706666666667
Vertical timing (frame)
Polarity of vertical sync pulse is negative.

Frame part	Lines	Time [ms]
Visible area	768	13.59872
Front porch	3	0.05312
Sync pulse	6	0.10624
Back porch	29	0.51349333333333
Whole frame	806	14.271573333333

Targetting above, at 300 MHz, we have 4 clocks per pixel.
Note that 1328/32 = 41.5, so we'll have to do 16 pixels per loop, and
dump the last 16 bits, assuming we want the pixel SM to pace DMA.

Or, more interestingly:

Front porch	24	0.32
Sync pulse	136	1.8133333333333
Back porch	144	1.92

So total blanking time is: 

Pixel s/r pio code:

1328 = 0x530
/16 groups: 0x53

start:
     mov x, 0x05
     in x, 4
     mov x, 0x2     ; Group count - 1
     in x, 4
     mov x, ISR
     
outo:
     mov y, 15      ; 16 pixels per group
     jmp !x, outl
     mov OSR, NULL  ; Blank remaining pixels
     mov x, 0x05    ; Setup group count
     in x, 4
     mov x, 0x0     ; Group count - 3
     in x, 4
     mov x, ISR
outl:
     out pins, 1    ; mono pixel group
     jmp y--, outl  ; spin until group done
     jmp x--, outo  ; spin until group count done

     
This should generate 0x51/2 ( 32 bit requests, with the last request actually
generating 16 + 32 pixels

While biking, thought of a better technique: sync/blank machine that signals
a video output machine. The SBSM can operate on a pixel basis, while the
VOSM operates on a 32 bit basis. This enables finer granularity of sync/blank,
and enables maximum SM FIFO throughput. (Assumes that active time is a
multiple of 32 pixels for 1 bpp output).

So:
SBSM:

start: out Y, 16    ; Get set/clear blank IRQ instruction
       mov EXEC, Y  ; Do it
       out PINS, 2  ; Do syncs
       out Y, 14    ; Get wait time
wait:  jmp y--, wait [3]  ; Do wait time in pixels (4 clk/pixel)

VOSM:

; Note: have to wait on zero, as wait on one will clear the flag
start:
	wait 0 IRQ 5  ; Wait until signalled
pixout:	out PINS, 1   ; Empty the shift register
	jmp !OSRE, pixout

So, a scan line would be done via:
Visible area	1024	13.653333333333
Front porch	24	0.32
Sync pulse	136	1.8133333333333
Back porch	144	1.92

Sequence of events:
front porch
active
back porch
sync

for v_fp lines:
  <set irq 5 inst>
  vsync_inactive
  hsync_inactive
  hfp_count + hactive_count + hbp_count

  <set irq 5 inst>
  vsync_inactive
  hsync_active
  hsync_count

for v_active lines:
per line push to SBSM:
  <set irq 5 inst>
  vsync_inactive
  hsync_inactive
  hfp_count

  <clr irq 5 inst>
  vsync_inactive
  hsync_inactive
  hactive_count

  <set irq 5 inst>
  vsync_inactive
  hsync_inactive
  hbp_count

  <set irq 5 inst>
  vsync_inactive
  hsync_active
  hsync_count

for v_bp lines:
  <set irq 5 inst>
  vsync_inactive
  hsync_inactive
  hfp_count + hactive_count + hbp_count

  <set irq 5 inst>
  vsync_inactive
  hsync_active
  hsync_count

for v_sync lines:
  <set irq 5 inst>
  vsync_active
  hsync_inactive
  hfp_count + hactive_count + hbp_count

  <set irq 5 inst>
  vsync_active
  hsync_active
  hsync_count

Alternatively, keeping the hline sequence constant:
hline:
per line push to SBSM:
hline(vsync, active) {
  <set irq 5 inst>
  vsync
  hsync_inactive
  hfp_count

  conditionalize on active: <clr irq 5 inst> or <set irq 5 inst>
  vsync
  hsync_inactive
  hactive_count

  <set irq 5 inst>
  vsync
  hsync_inactive
  hbp_count

  <set irq 5 inst>
  vsync
  hsync_active
  hsync_count

Then, using above:

vfp: hline(0, 0)
vactive: hline(1, 0)
vbp: hline(0, 0)
vsync: hline (0, 1)

debugging:
observed hsync: 126.0 us
Should be: 17.706666 us

fp command: 0x2062c005
timing = 0x2062 >> 2;

observed: 25.3 total
9.28 us sync assertion
Should be: 1.81333

8-aug-2023:

VGA 640 x 480 @ 60Hz:
creen refresh rate	60 Hz
Vertical refresh	31.46875 kHz
Pixel freq.	25.175 MHz
Horizontal timing (line)
Polarity of horizontal sync pulse is negative.

Scanline part	Pixels	Time [µs]
Visible area	640	25.422045680238
Front porch	16	0.63555114200596
Sync pulse	96	3.8133068520357
Back porch	48	1.9066534260179
Whole line	800	31.777557100298
Vertical timing (frame)
Polarity of vertical sync pulse is negative.

Frame part	Lines	Time [ms]
Visible area	480	15.253227408143
Front porch	10	0.31777557100298
Sync pulse	2	0.063555114200596
Back porch	33	1.0486593843098
Whole frame	525	16.683217477656

14-aug-2023:

Realized that the NOP instructions in the sync event commands could be
used to signal a system interrupt. Added a function to replace/restore
NOPs at a specific line in the sync event stream array.

 //pio"I"->inte"J" = PIO_IRQ0_INTE_SM"K"_BITS
 -> signal on the J interrupt line(2 in total)
 when a SM in PIO I raises irq K.

 pio0->inte0 = PIO_IRQ0_INTE_SM0_BITS; 

void pio_irh() {
  if (pio0_hw->irq & 1) {
    pio0_hw->irq = 1;
    // PIO0 IRQ0 fired
  } else if (pio0_hw->irq & 2) {
    pio0_hw->irq = 2;


For reference, the fb_mono pixel PIO code trials:

; Note: have to wait on zero, as wait on one will clear the flag
; This code has swimminess when displaying a diagnoal line
;start:
;     mov PINS, NULL	  ; Turn off video output
;     wait 1 IRQ 6	  ; Wait for enable
;pixoutL:
;     nop
;pixoutS:
;.wrap_target
;     pull ifempty
;     out PINS, 1           ; Empty the shift register
;     jmp !OSRE, pixoutL
;     wait 0 IRQ 5        ; Execute as long as IRQ 5 is zero
;.wrap


;      mov PINS, NULL	  ; Turn off video output
;      set X, 31           ; Set active pixels/32
;      set X, 19           ; Set active pixels/32
;      wait 1 IRQ 5        ; Wait until signalled
;pixoutL:
;     nop 
;pixoutS:
;     pull ifempty
;     out PINS, 1           ; Empty the shift register
;     jmp !OSRE, pixoutL
;     jmp X--, pixoutS      ; Next group of 32 pixels


;      mov PINS, NULL	  ; Turn off video output
;      set X, 0
;      mov OSR, ~X
;      wait 1 IRQ 5        ; Wait until signalled
;waitl:
;      nop
;waits:
;      out PINS, 1 [1]     
;      jmp !OSRE, waitl
;      mov OSR, X
;      jmp x--, waits

;      mov PINS, NULL	  ; Turn off video output

;      wait 1 IRQ 6        ; Wait until signalled

And the final code:

.program fb_sync
; Generate syncs and signal video out state machine
; Pin mapping:
; out pins are mapped to H/V sync
; set pin is mapped to vga green
;
; Burn one pixel to execute output commands
; Two pixels minimum time (wait == 0)
start:
       out EXEC, 16       ; Two clks to do video sm req or clear video out
       out PINS, 2        ; Do syncs
       out Y, 14          ; Get wait time
pwait:
       jmp Y--, pwait [3] ; Do wait time in pixels (4 clk/pixel)

.program fb_video
; Generate 1 bpp video out
; Pin mapping:
; out pin is mapped to pixel output
;
; Note have to change active pixel counts below, depending on format
start:
      mov PINS, NULL	  ; Turn off video output
PUBLIC set_active:
      set X, 31           ; Set active pixels/32 for 1024 active
      wait 1 IRQ 5        ; Wait until signalled
pixoutL:
     nop 
pixoutS:
     pull ifempty         ; Get pixels into shift register, when empty
     out PINS, 1          ; Output a pixel
     jmp !OSRE, pixoutL   ; Loop until shift count exhausted
     jmp X--, pixoutS     ; Next group of 32 pixels

Found this gem today:
   pio_sm_exec(el_pio, sm, pio_encode_pull(false, false));
   pio_sm_exec(el_pio, sm, pio_encode_out(dst, 32));

21-aug-2023:

Thinking of how do PSRAM framebuffer access:

1) There doesn't seem to be a method of requesting a DMA from PIO directly,
so write an IRQ triggered by a system PIO.

2) DMA command sequence:
  a) PSRAM command to fetch scan line into internal scan buffer. SM RX FIFO.
  b) Copy from PSRAM SM to SRAM. SM TX FIFO to SRAM.
  c) Copy from SRAM to FB SRAM RX FIFO.

22-aug-2023:

Thinking of how to share PSRAM between emulation/frame buffer. Came up
with scheme to use all four state machines, and SM relative IRQ addressing.
Pass a one across all SMs - when a SM has work, don't pass it on until done.

start:
;	mov X, ~NULL        ; Flag to indicate work/no work
	// Assume that X is -1 after previous PSRAM operation
	wait 1 irq 0x10     ; Wait for another SM to set this SM's IRQ
	pull noblock        ; Will be either X or new value
	out x, 1            ; If bit clear, then work to be done
	jmp x--, passOn     ; Otherwise, signal next SM to do work

// Now add PSRAM control code

        
passOn:
	irq  nowait 4 rel   ; Set next SM irq bit

Sigh. PSRAM control code is 28 instructions, and above needs 5 instructions.

Let's try yet another refactoring:

.... deleted junk ....

23-aug-2023:

Found a way to elminate two instructions: viz:
.define public LATENCY 4
.define public LAT_SHORT 1

public r_lat:
lat_cnt:
     nop                  side 0b00 [5]   ; Wait for latency to expire
     jmp Y--, lat_cnt     side 0b01 [5]

public r_data:
     in PINS, 8           side 0b00 [6]    ; CA phase 0 
     in PINS, 8           side 0b00        ; CA phase 1
     jmp X--, r_data      side 0b01 [6]    ; Continue until all data captured 
     jmp start            side 0b10


w_lat_cnt:
     set PINDIRS, 1       side 0b00 [5]    ; Make RWDS pin output 
public w_lat:
     jmp Y--, w_lat_cnt   side 0b01 [5]

Above elminates two nops from the r_lat counter, and changes the w_lat
jump from w_lat_cnt to above. Increasing the latency constants finishes
the alterations.

Now can add full change.

Thought: do we need to dump the rest of the null command pulled? Hopefully not,
as we do a new pull when polling for irq...

24-aug-2023:

Finished changes, with some optimizations. But, after firing up all the SMs,
realized that there's a pin conflict betweent the idle SMs and the active
ones. So, need to free up a delay/sideset bit to make side sets optional.

Currently, we use 3 delay bits, and 2 side set bits. The bit field is 5 bits
wide. We have one instruction slot left. Let's see if we can use this,
plus the RWDS set command to control CS...

RWDS is GPIO 20, CSn is GPIO 19. First, expand the set bits, and change
RWDS.

Well, first bug found: left the irq 4 instructions in for signalling the
RWDS SM. Removing those made no difference.

We are currently using the default value of the out register to make
RWDS low during writes.

Hah! Found an extra nop in the write data loop!
public w_data:
;     nop                  side 0b00        ; Setup RWDS pin
     out PINS, 8          side 0b00 [4]    ; Setup write of cmd/adr
     nop                  side 0b01        ; CA phase 0 write, setup RWDS ph 1
     out PINS, 8          side 0b01 [4] 
     jmp X--, w_data      side 0b00        ; CA phase 1 write

Commenting out (as above), still allows the memory test to pass. Can now
set/clear CS via set commands.

Changing the SM code, hyperram.c and enabling all the SMs still enables the
memory test to pass!!!

Now to test the memory ports. Subdivide into four chunks and run the
memory test on each. Interleave the diffent subtests on each SM...

25-aug-2023:

Decided to learn more about DMA by starting with the control blocks example.
Will use to test mult-channel PSRAM controller as well.

26-aug-2023:

So, we'll build code to do generalized DMAs, so that we can program the
FB SM and PSRAM SMs from one DMA command list. This will ensure that the
timing and scan line filling operations are synchronized.

Note: since the FB SM can buffer up to two scanlines, we need to scanlines
worth of FB buffer to ensure we don't unnecessarily block the FB SM.

For now, we're going to leave the FB pixel DMA mechanism in place (though
only allocate two scanlines, instead of the full FB).

Sequence of events:
scanline 0 up to vbp - 2:
  write hline parameters to FB SM

scanline vbp-2 (i.e. second to last blank line)
  write "read first scan line from PSRAM" command to PSRAM SM
  copy first scan from PSRAM SM to scan line buffer 0
  write hline parameters to FB SM

Question: Do we need to reset the FB Pixel scanline DMA engine at top
of screen? 

28-aug-2023:

Thinking about how to optimize PSRAM accesses for random pixels:
perhaps make a corner-change DMA engine.
This would fetch 32 words sequentially, place them in a vertically striped
temporary FB. Thus, from a pixel drawing point of view, a sequential fetch
would actually get a 32x32 array of pixels. This would make vertical/horizontal
lines equal cost (ish - horizontal pixels are in the same word, whereas
vertical pixels are in ajacent words. But this is more equivalent than
paying a memory fetch for vertical pixels...)

29-aug-2023:

A milestone day: a framebuffer in PSRAM is on the display! Uses the four
port PIO PSRAM SM, display refresh PIO SMs, and four channels of DMA.

Need to make it a library, so that other projects can use it easily.

30-aug-2023:

Make FB into a somewhat hacked library, made a memory test with frame
buffer enabled. Ran into fb starvation with default memory test buffer
sized of 256 words. Reduced to 32 words, all works. Did notice a
fairly significant slowdown of test time during the short test. And a hard
fault with the random test enabled...

Here's a question: is it possible for the fb dma to stall the psram? I.e.
is it possible that the psram read buffer isn't getting emptied at full rate?
Or is the command stream getting stalled?

Might be worth an experiment: seperate out the hsync and psram dma streams
to ensure one isn't blocking the other. (Theoretically, this shouldn't
be possible, as each DMA command is atomic, and the psram empty command
follows directly after the setup command. But! I read somewhere that
starting a new DMA takes 12 usec. A whole line is 17 usec, so this is
a long time to hold an PSRAM channel.

So, I think it's worth burning DMA channels to get back perf. Have to chain
to a psram read channel after the psram setup. Could also make this a
ring buffer, to minimize the setup requirements. Then it looks like
our familiar two channel setup. With this, we'll have essentially zero
delay between psram output fifo ready and the transfer to memory. Should
make things much faster...

31-aug-2023:

Made modifications as above. Still debugging. As an aside, added timing
info.
Time without initializing FB: 60.91 sec
Time with shared DMA: 160.96 sec
Time with seperate DMA: 66.66 sec

Ok, so above speculation was correct! Happy to take a 10% hit when
the FB is enabled.

Left in a define to enable the old behavior, with the following note:
// WARNING: only enable this if there's no other alternative!
// Reduces DMA channel usage by two, but decreases PSRAM performance
// by 2.4 times (141%). This is because it takes a significant
// amount of time to start up a DMA.
// The actual critical path is the DMA to start the PSRAM command
// and the DMA to empty the PSRAM RX FIFO of pixel data. Once the PSRAM
// read command is started, all other PSRAM accesses will wait until it's
// done.
#define SHARED_DMA

Investigating the effect of enabling the FB with access types:
FB enabled:
Single 32 bit read/write test time:  15.45 sec
Burst 32 words read/write test time: 51.20 sec
FB disabled:
Single 32 bit read/write test time:  9.70 sec
Burst 32 words read/write test time: 51.20 sec

So, enabling the FB mainly affects single word read/writes. Which is good,
since we expect to be doing mostly cache fills/spills.

Attempted to re-enable BUF_SIZE 1024/4 - but this caused the memtest to
hang, and the screen to display stripes. (I.e. PSRAM SM is locked up).
1024/8 seems to work.

Sigh. I'd forgotten to remove a sleep_ms(100) in the short test
read/write lines. New measurements:
FB disabled:
Full: 9.70
Short: .003115
Total: 9.72
Fb enabled:
Full: 15.450
Short: .003870
Total: 15.46

Redoing total overhead gives 60% hit overall when enabling FB.
Full overhead: 59.27%
Short overhead: 24%

With larger number of transactions:
FB enabled:
short: 0.1190
FB disabled:
short: 0.08505

Overhead: 39.91%

Noticed that there's 1/8 scan line delay on the first line. This is
due to the fact that the PSRAM fetch and the video SM aren't properly
synced. Will need to put the PSRAM fetch into the hevents queue. (The
hevents PIO SM input FIFO is really messing things up!)

1-sep-2023:

Thinking about the above problem, realized that we can offset the
fill/empty of the buffer by offsetting the DMA starting address. Try
using the ring buffer feature of the DMA engines, and doing this.

Nope - that only affects which pixels get sent out first. This is a
temporal problem: there is no interlock between empty and fill...

In Barcelona - did the hop-on, hop-off bus tour...

Fixed the random screen test to run longer.
With FB enabled, execution time is 0.3568
With FB disabled, execution time is 0.2618

Delta is 36.28%. Ratio is 1.3628.

With burst size set to 8 words:
With FB enabled, execution time is 0.2280
With FB disabled, execution time is 0.1556

Delta is 46.52

With shared DMA enabled, execution time is 0.7001

10-sep-2023:

Counted 32 bit FB transfers: 24576

1024*786/32 = 25152
98304/25152 = 3.9083

Had bug in vertical line count: should have divided by number of lines in
scan buffer.

12-sep-2023:

Realized that we could use chaining to synchronize all of the DMA processes,
albeit at a cost of many more control register reloads.

Goal - synchronize the horizontal events:
1) For non-active lines, make a list of h events. Instead of chaining to
control register reload at end, chain to active h events list.
2) Make a list of active h events. This list is composed of:
  a) PSRAM address setup. Chain to (b).
  b) copy from PSRAM output FIFO to scan line buffer. Chain to (c).
  c) h events for the scan line. Chain to active list.
  At end of active list, reload to non-active list.

Details:
Non active hevents:
Write to hsync fifo

Active:
Write to PSRAM command FIFO

DMA channel 1:
read addr: hsync events 
write addr: hsync input FIFO
count:
  1) vfp + vsync + vbp
  2) active

chain-to:
  1) active channel
  2) reload channel

List looks like:
one entry per line:
for lines 0 to vfp: read addr: vfp


13-sep-2023:

Apparently, a DMA channel can be enabled, but not triggered.

So, chain events:
1) At end of vbp list: chain to ps addr
2) 

27-sep-2023:

Finally, was able to get the display to be centered and operate correctly.
Took awhile! Key was to make display DMA driven solely by the video PIO SM
empty signal.

FYI, time with FB enabled/disabled when running tests 0, 1 and 3:
enabled: 12.0619
disabled: 9.9723

Overhead: (12.0619 - 9.9723)/9.9723 = 0.2095 or 21%.

Rough ideal calc: 70 Mpix/sec/8 = 8.75 MByte/sec
It takes 15 PIO clocks per 16 bit word in the read inner loop,
so 300 MHz/7.5 = 40 MB/s

Assuming we're getting near peak: 8.75/40 = 21.87%. This is in good
agreement with above. (Note that the 8.75 doesn't include blanking time,
so is probably ~20% too high, but then the peak PSRAM bw doesn't include
setup time, nor time for the PSRAM PIO SM to arbitrate. Thus it's a wash...).

Note that there is a "magic" constant in the wait to enable the video PIO:
  fb_mono_sync_wait(inst->vactive + inst->vfp + inst->vsync + 13);

The value 13 works for both 1024x768 60 and 70 Hz timing parameters. (640x480
is broken for now...)

Had a thought: could do dual head VGA. Share h/v sync pins, so only one
more pin needed. Currently GPIO 9 is spare. Would leave only one PIO SM,
since we need a seperate video out SM. Thus, this would preclude ethernet.

30-sep-2023:

Still having difficulty with DMA ring buffers. What works is:
  channel_config_set_ring(&ps_out_config, true, 7);
uint32_t scan_buf[1024*1/32] __attribute__((aligned (1024)));

The documentation states that the ring buffer masks the give number of address
bits. Thus, we'd get 128 bytes worth of ring buffer. Scan buf is 32 words,
or 128 bytes! So it's working correctly.
  

17-oct-2023:

Re-working video subsystem - goal is to use only one PIO SM. The freed up SM
could be sed for a second video stream or a SPDIF auto output.

Current PIO code:

.program fb_sync
; Generate syncs and signal video out state machine
; Pin mapping:
; out pins are mapped to H/V sync
; set pin is mapped to vga green
;
; Burn one pixel to execute output commands
; Two pixels minimum time (wait == 0)
start:
       out EXEC, 16       ; Two clks to do video sm req or clear video out
       out PINS, 2        ; Do syncs
       out Y, 14          ; Get wait time
pwait:
       jmp Y--, pwait [3] ; Do wait time in pixels (4 clk/pixel)

.program fb_video
; Generate 1 bpp video out
; Pin mapping:
; out pin is mapped to pixel output
;
; Note have to change active pixel counts below, depending on format
start:
      mov PINS, NULL	  ; Turn off video output
PUBLIC set_active:
      set X, 31           ; Set active pixels/32 for 1024 active
      wait 1 IRQ 5        ; Wait until signalled
pixoutL:
     nop 
pixoutS:
     pull ifempty         ; Get pixels into shift register, when empty
     out PINS, 1          ; Output a pixel
     jmp !OSRE, pixoutL   ; Loop until shift count exhausted
     jmp X--, pixoutS     ; Next group of 32 pixels


Single SM code:
; Burn one pixel to execute output commands
; One pixel minimum time (wait == 0)
.
PUBLIC vidout:
     out PINS, 1          ; Output a pixel
     jmp X--, vidout      ; Do until count exhausted, then get next cmd

.wrap_target
PUBLIC start:
     out X, 16            ; Get loop count
     out EXEC, 16         ; Two clks to execute passed in instruction
wait:
     jmp X--, wait        ; Do wait
.wrap


Video output instructions, sent to the above:
       set PINS, <hsync,vsync>   ; Update H/V syncs
       jmp vidout         ; Start video output
       nop


Commands for active scan line:
word 0:
       <clks for h front porch>
       nop

word 1:
       <clks for hsync assertion>
       set PINS, 0b01    ; Set hsync

word 2:
       <clks for h back porch>
       set PINS, 0b00    ; Clear hsync

word 3:
       <number of pixels + 1 32 bit blanking interval>
       jmp vidout

word 4-n:
       <pixels....>
       
word n+1
       <32 bit blanking interval>

DMA:
       copy sync commands to FIFO
       setup PSRAM read command
       copy PSRAM output to buffer
       copy buffer to FIFO
       copy 32 bit zero to FIFO

Blank h lines:
word 0:
       <clks for h front porch>
       nop

word 1:
       <clks for hsync assertion>
       set PINS, 0b11    ; Set hsync/vsync

word 2:
       <clks for h back porch>
       set PINS, 0b10    ; Clear hsync

word 3:
       <clks for number of pixels>
       nop

DMA:
       copy sync commands to FIFO

20-oct-2023:

Testing implementation of the new PIO SM.

  uint32_t dly = 1;
  uint32_t on  = ((SET_INST | 0x03) << 16) | dly;
  uint32_t off = ((SET_INST | 0x00) << 16) | dly;

  while (1) {
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, on);
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, off);
  }

With the 1024 x 768 @ 70Hz timing selected, measured 15 MHz on
sync output. Thus, each put to the SM used 5 instructions, causing
a divide by 10 of the SM's 150 MHz clock. Confirmed by scope measurement.
With dly = 0, a divide by 8 is generated, for a result of 18.75 MHz.
Since the minimum delay time is 4 instructions, and the instruction rate
is 2 * pixel clock, the minimum delay is then 2 pixels.

So, to set an arbitrary pixel delay:
delay_value = (pixel_count - 2) * 2

desired delay = 2 pixels
delay_value = (2 - 2) * 2 = 0

desired delay = 3 pixels
delay_value = (3 - 2) * 2 = 2

21-oct-2023:

Thinking about relationship between sync and active video, for the above
PIO video SM.

0) Assume pins are changed at the end of the instruction when not delayed.
(delays are added after instruction execution - see 3.2.2 in data sheet).
1) Blank assertion/deassertion occurs when the 3rd clock is executed from start.
2) Video output starts at fourth clock from start.

So, to pixel align video with respect to sync, must add one tick to back porch
time and subtract one tick from front porch time. This should align
the active time and blanking times correctly.

Scope test case:
  uint32_t fp = (NOP_INST << 16) | 1;
  uint32_t on  = ((SET_INST | 0x03) << 16) | 3;
  uint32_t bp = ((SET_INST | 0x00) << 16) | 3;
  uint32_t act = (JMP_INST << 16) | 31;
  uint32_t pix = 0x80000001;

  while (1) {
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, fp);
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, on);
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, bp);
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, act);
    pio_sm_put_blocking(_inst.pio, _inst.sm_video, pix);
  }

verifying with real timing values:
    .hfp = 24, or 320 ns
    .hsync = 136, or 1.81 us
    .hbp = 144, or 1.92 us

  uint32_t fp = (NOP_INST << 16) | (24 * 2 - 2 - 1);
  uint32_t on  = ((SET_INST | 0x03) << 16) | (136 * 2 - 2);
  uint32_t bp = ((SET_INST | 0x00) << 16) | (144 * 2 - 2 + 1);
  uint32_t act = (JMP_INST << 16) | 31;

Based on scope measurements, the following gives a fp of 320ns:

  uint32_t fp = (NOP_INST << 16) | ((24 - 2) * 2 - 3);
  uint32_t on  = ((SET_INST | 0x03) << 16) | ((136 - 2)  * 2);
  uint32_t bp = ((SET_INST | 0x00) << 16) | ((144 - 2) * 2 + 3);

Sigh. None of the above results in a solid display. Experimenting yeilds:

    for (int i = 0; i < _inst.vtotal; i++) {
      send_pix = 0;
      fp = (NOP_INST << 16) | ((_inst.hfp - 2) * 2);
      act = (NOP_INST << 16) | ((_inst.hactive - 2) * 2);

      if (i < _inst.vsync) {
	// V sync
	// Vsync asserted (pin 0), Hsync asserted (pin 1)
	on  = ((SET_INST | 0x00) << 16) | ((_inst.hsync - 2)  * 2);
	// Vsync asserted
	bp = ((SET_INST | 0x02) << 16) | ((_inst.hbp - 2) * 2 );
      } else if (i < _inst.vsync + _inst.vbp) {
	// V bp
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2);
      } else if (i < _inst.vsync + _inst.vbp + _inst.vactive) {
	// V active
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2 - 4);
	act = (JMP_INST << 16) | _inst.hactive - 1;
	send_pix = 1;
      } else if (i < _inst.vsync + _inst.vbp + _inst.vactive + _inst.vfp) {
	// V fp
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2);
      }

      pio_sm_put_blocking(_inst.pio, _inst.sm_video, fp);
      pio_sm_put_blocking(_inst.pio, _inst.sm_video, on);
      pio_sm_put_blocking(_inst.pio, _inst.sm_video, bp);
      pio_sm_put_blocking(_inst.pio, _inst.sm_video, act);

      if (send_pix) {
	for (int j = 0; j < (_inst.hactive/32); j++) {
	  //pix = i&1 ? 0xaaaaaaaa : 0x55555555;
	  pix = i&1 ? 0xcccccccc : 0x33333333;
	  //pix = -1;
	  pio_sm_put_blocking(_inst.pio, _inst.sm_video, pix);
	}
      }
    }
  }

So why is - 4 the magic number? 1, 2, 3, and 5 all result in an unstable disp.

22-oct-2023:

After thinking about the above conundrum, realized that the video out
routine also has overhead: 4 clocks. This must be removed from either
before or after calling the routine. In our case, it should be split:
1 clock before, and 3 after. This will put the active video on a pixel
boundary.

With the following test code, a solid display is acheived:
  while (1) {
    for (int i = 0; i < _inst.vtotal; i++) {
      send_pix = 0;
      fp = (NOP_INST << 16) | ((_inst.hfp - 2) * 2);
      act = (NOP_INST << 16) | ((_inst.hactive - 2) * 2);

      if (i < _inst.vsync) {
	// V sync
	// Vsync asserted (pin 0), Hsync asserted (pin 1)
	on  = ((SET_INST | 0x00) << 16) | ((_inst.hsync - 2)  * 2);
	// Vsync asserted
	bp = ((SET_INST | 0x02) << 16) | ((_inst.hbp - 2) * 2 );
      } else if (i < _inst.vsync + _inst.vbp) {
	// V bp
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2);
      } else if (i < _inst.vsync + _inst.vbp + _inst.vactive) {
	// V active
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2 - 1);
	act = (JMP_INST << 16) | _inst.hactive - 1;
	fp = (NOP_INST << 16) | ((_inst.hfp - 2) * 2 - 3);
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);

	send_pix = 1;
      } else if (i < _inst.vsync + _inst.vbp + _inst.vactive + _inst.vfp) {
	// V fp
	on  = ((SET_INST | 0x01) << 16) | ((_inst.hsync - 2)  * 2);
	bp = ((SET_INST | 0x03) << 16) | ((_inst.hbp - 2) * 2);
      }

      pio_sm_put_blocking(_inst.pio, _inst.sm_video, bp);
      pio_sm_put_blocking(_inst.pio, _inst.sm_video, act);

      if (send_pix) {
	for (int j = 0; j < (_inst.hactive/32); j++) {
	  pix = i&1 ? 0xaaaaaaaa : 0x55555555;
	  //pix = i&1 ? 0xcccccccc : 0x33333333;
	  //pix = -1;
	  pio_sm_put_blocking(_inst.pio, _inst.sm_video, pix);
	}
      }

      pio_sm_put_blocking(_inst.pio, _inst.sm_video, fp);
      pio_sm_put_blocking(_inst.pio, _inst.sm_video, on);

    }
  }

Non-integral pixel clock dividers still make a noisy display. E.g.:

Using 1024 x 768 @ 60 video format, gives clk_div = 2.307692.
Using 1024 x 768 @ 70 video format, gives clk_div = 2.000000.


4-nov-2023:

From: https://wellys.com/posts/rp2040_c_linux/
Debugging with gdb:
Start:
gdb-multiarch  build/apps/fb_test/fb_test.elf

Once at gdb prompt:
(gdb) target remote localhost:3333

Hurray! Single SM video finally works. Key debugging learning: must chain
to a DMA channel in order to trigger it. Just having a DREQ present is not
sufficient.

Next issue: memory test causes screen to blank. Happens during the burst
memory read/write phase. This may preclude dual head display, if not
solved.

If we fire off the PSRAM read/copy to buffer command earlier, that
would give more time to complete. Requires assuming that the read
has completed, before copying to video SM, and putting a copy from
buffer to video SM command into the command stream. Plus, if the read doesn't
complete, it'll result in re-displaying the previous line, instead of
blanking the screen.

Unfortunately, since we have only one SM, moving the PSRAM load doens't
solve the problem. The latency between request and completion still delays
DMA execution. (If there was a way to fire-and-forget, then this would work).

Another idea is to try running two DMA streams, one for video SM, the other
for PSRAM loads, and chain between them. This will (at least) eliminate
the load/startup time for the PSRAM request.


Another idea is to have a single word write channel that would write to
a PSRAM command channel, then chain back to the video command channel.
Then, the video command channel would skip the PSRAM trigger, and point
directly to the buffer read channel. The single word write would be
done before the timing write so that the data could be fetched over a
video line time.

Rough calc to fetch a line:
Assuming 40 MB/s, that's 25ns per byte or 100ns/word. We need 32 words, so
3.2us. This is just about the horizontal blanking time: 4.05 us.

5-nov-2023:

Continuing above: we'll need to do double buffering, since there's no guarantee
that we'd get a PSRAM fetch done in time. So, double the scan buf, and
add a little bit of management at the start of vblank: reset the
scan buf read/write DMA pointers by copying the write pointer to the read
pointer, then trigger a write.

Thought: could eliminate one PIO instruction by using side set to turn
off video pin:

.side_set 1 opt

PUBLIC vidout:
     out PINS, 1                  ; Output a pixel
     jmp X--, vidout              ; Do until count exhausted, then get next cmd

.wrap_target
PUBLIC start:
     out X, 16         side 0b0  ; Get loop count, blank video out
     out EXEC, 16                ; Two clks to execute passed in instruction
fb_wait:
     jmp X--, fb_wait            ; Do wait
.wrap

Would have to re-jigger the vidout entry/exit delay count from four to three...

Did above, works perfectly. 20% PIO program size reduction :-)

Think the reset of the PSRAM cmd and PSRAM output write pointer should be
done before active, so that line 0 isn't time delayed with respect to
the rest of the screen.

6-nov-2023:

Moved the PSRAM cmd and PSRAM write resets, as above. Also found that
V sync wasn't generated correctly - an off-by-one error:
Was:
    vs = ((i > inst->vfp) && (i < (inst->vfp + inst->vsync)));
Fixed:
    vs = ((i >= inst->vfp) && (i < (inst->vfp + inst->vsync)));

Also moved the start of the PSRAM sequence to just after the transfer
to video sm:
    // Start with transmitting pixel data to the Video SM
    // Read with wrap from scan line buffer, write to video SM
    // Trigger PSRAM fetch once done
    cmd_buf[cmd_ptr].raddr = (uint32_t)&(scan[scanbuf_index]);
    cmd_buf[cmd_ptr].waddr = (uint32_t)&inst->pio->txf[inst->sm_video];
    cmd_buf[cmd_ptr].count = words_per_scanline;
    cmd_buf[cmd_ptr].cnfg = cfg_scanline;
    cmd_ptr++;

and:
  // Chain to command channel to fetch the next set of commands
  channel_config_set_chain_to(&cfg_scanline, ps_start_chan);

Now it's perfect! (Hope I haven't jinxed myself now :-))

Next steps:
1) Add per scanline IRQ
2) Add moving frame buffer start address
   Could use the DMA add sniffer feature to do this in real time.

Performance slightly improved:
Old from above:
FYI, time with FB enabled/disabled when running tests 0, 1 and 3:
enabled: 12.0619
disabled: 9.9723
Overhead: (12.0619 - 9.9723)/9.9723 = 0.2095 or 21%.

New:
enabled: 11.98625
disabled: 9.864730
Overhead:(11.98625 - 9.864730)/9.864730 = .2150 or 21.5%

I guess the compiler improved between now and September...

Sniffer info:
Set/Get accumulator
inline static void dma_sniffer_set_data_accumulator(uint32_t seed_value) {
     dma_hw->sniff_data = seed_value;
 }
 
 inline static uint32_t dma_sniffer_get_data_accumulator(void) {
     return dma_hw->sniff_data;
 }


Scheme:
Setup PSRAM initial command block in memory:
.cmd0
.cmd1
.cmd2

Initialize accumulator with cmd1
Read addend
Write accumulator to cmd1
Write command block to PSRAM FIFO

Note that there are 12 DMA channels in RP2040, and we're already using 5 of
them. We'll need at least four channels for networking.

Could repurpose the PSRAM trigger into PSRAM DMA command generator. Especially
if we can make the commands a power of two for ring buffer read...
Will also save memory, since we don't have to have a list of PSRAM cmd block.

Let's try it out:

  // 1) PSRAM command channel setup
  ps_start_config = dma_channel_get_default_config(ps_start);

  // Increment read address
  channel_config_set_read_increment(&ps_start_config, true); 

  // Don't increment write address
  channel_config_set_write_increment(&ps_start_config, true); 

  // Limit writes to 4 words
  channel_config_set_ring(&ps_start_config, true, 4);

  // Set to trigger command channel when done
  channel_config_set_chain_to(&ps_start_config, cmd_chan);

  dma_channel_configure(ps_start, &ps_start_config, 
			&dma_hw->ch[ps_cmd].read_addr, // Setup all DMA regs
			ps_cmd,
			4,
			false);

(Note: will have to reload this at blank time)
 PS data channel is now written via above; no setup necessary

 PS read channel setup remains the same

PS command buffer contains (for non-computed PSRAM commands):
For PSRAM read:
read from PS data buf
write to PS FIFO
count of commands
write to FIFO DMA config

When doing computed PSRAM commands:
read from cmd1
write to sniffer acc
count 1
write to mem DMA config (no read inc, no write inc, chain to PSRAM cmd chan)

read from inc val
write to temp
count 1
write to mem DMA config

read from sniffer acc
write to cmd1
count 1
write to mem DMA config

read from psram.cmd
write to PSRAM FIFO
count 3
write to FIFO config, chain to PSRAM read channel


Tried 1080p timing, but no output observed. Clk div is 1.010101.
Tried 1280p timing, output observed, but need to make scan buf bigger.

Fixed buffer size issues to get 1080p running. Of course, memory test execution
time takes a hit: 16.33268

(16.33268 - 9.864730)/9.864730 = .6556 or 66% overhead!

And, the display is really noisy - reached the limit of output buffers, I guess.
But, it doesn't blank out...

1024 x 768 @ 60 Hz execution time is 11.650924
(11.650924 - 9.864730)/9.864730 = 0.1810 or 18%.

640 x 480 @ 60 Hz execution time is 10.491788
(10.491788 - 9.864730)/9.864730 = 0.0634 or 6.3%

7-nov-2023:

In thinking about the new PSRAM read process start (just after the read
of data for sending to video SM), there's now enough time to do the PSRAM
read and copy to memory. Thus, we can eliminate the scan line double buffering.

Did a bunch of cleanup of the fb_mono library...

8-nov-2023:

Thinking about character font lookups via DMA, realized that
we can trigger a DMA via writing to the write address register. Thus,
we can keep one DMA engine reading the address increment value, and writing
the sniffer register result to another:
When doing DMA font lookups:
// Initialize ACC with initial character font address
Read font base address
Write to sniffer acc
count 1
write to mem DMA config (no read inc, no write inc, chain to PSRAM cmd chan)

// Read FB destination address value
// Write destination address to DMA engine write pointer


// Read scan line DMA write pointer, write to acc

// Read scan line buffer delta Y - 1 value, write tmp, bumping ACC

// Read siffer ACC, write to scan line DMA write pointer
// This triggers font read/scanline buf write

9-nov-2023:

Looking at the PSRAM command packet:
0) Addresses 15:0 are in cmd1
1) Addresses 32:16 are in cmd0

Scan line buffer is 32 words/128 bytes, so addr<6> is set. 


11-nov-2023:

Thinking about line drawing, and how to accelerate. Perhaps a PIO SM to
do set/clear pixels, and a DMA engine to fetch them. Should also read about
the DDA engines to see if they can implement line drawing.

PIO SM:
Need word to modify, color value, and index. Two 32 bit inputs at a minimum.
Also think about a DDA to enable only feeding in the word to modify. E.g.
use Y to control how often to move the pixel mask. 10 bits for 1K width.
Or, a mask to move/not move the bit. Or, a mask that sets more than one bit.
The last is probably the most useful, generally.



12-nov-2023:

It's time to go back to getting the R2000 stuff to run. But, here's
a thought: it might be possible to draw lines just via DMA, using
the sniffer add function. At least the address calculations, anyways.

First goal: get the R2000 emulator to compile and run.

Building on previous work, got to:
running!!
ready, time is 0x00000000005C84B7
ready, time is 0x00000000005C86C5
SD card init fail

To be continued...

2-dec-2023:
In Cabo!

Was able to get the SD card mounted, and PSRAM accesses were seen.

Setting up actual DEC 1024x864 timing:
From the DS3100 functional spec:

Pixel clock  69.1968 MHz 14.45 ns
Active Video     1024 pixels 14.8 us
Blanking          256 pixels 3.70 us
Total line       1280 pixels 18.5 us
Sync front porch   12 pixels  173 ns
Sync width        128 pixels 1850 ns
Sync back porch   116 pixels 1676 ns

Vertical Timing
Line rate        54.062 KHz  18.5 us
Active video      864 lines  15.98 ms
Blanking           37 lines  684 us
Total lines       901 lines  16.67 ms
Sync front porch  12 pixels  173 ns
Sync width         3 lines   55.5 us
Sync back porch   34 lines - 12 pixels 629 us

Ok, so the vfp looks strange. We'll actually do:
vfp: 1
vsync: 3
vbp: 33
total: 37

6-dec-2023:

Adding rom/disk image loading.
Rom image: rom_loader.bin
disk image: ultrix.gui

If the x86 emulator is to be trusted, then the loader from the source/romboot
will boot ultrix. This is the loader embedded in the main_uc via
"include loader.inc".

12-dec-2023:

Got to:
BBoo  aattttoo  oonn  tt%    uusscchhlloo  ooll

BBoo  aattttoo  oonn  tt%    uusscchhlloo  ooll

Showing up on the console when booting ultrix.gui.
Trying: linux.wheezy...

16-dec-2023:

Finally, signs of life!:

ram: 32                                                                         
ramtop: 31                                                                      
isCDROM: 0                                                                      
Disk geometry: 4337 cyl of 16 heads of 17-sector tracks for 1179664 LBAs total  
uMIPS v2.2.0 (BL ver 37)                                                        
 will run with 32MB                                                             
r: 0 pa: 00000000 sz: 01fe0000 33423360                                         
r: 1 pa: 1fc00000 sz: 00000110 272                                              
r: 2 pa: 17000000 sz: 01000000 16777216                                         
r: 3 pa: 1e000000 sz: 01000000 16777216                                         
r: 4 pa: 1c000000 sz: 01000000 16777216                                         
r: 5 pa: 1a000000 sz: 02000000 33554432                                         
r: 6 pa: 18000000 sz: 02000000 33554432                                         
r: 7 pa: 00000000 sz: 00000000 0                                                
r: 8 pa: 00000000 sz: 00000000 0                                                
hello, world                                                                    
Boot partition found at 32 + 32768 sec                                          
 > 'VMLINUX'
 
loading 0x00351248 bytes from offset 0x00001000 to 0x80040000 + 0x00373A30...   
  0x00351248 / 0x00351248 -> 100%                                               
clearing BSS...                                                                 
  0x000227E8 / 0x000227E8 -> 100%                                               
LOADED                                                                          
[    0.000000] Initializing cgroup subsys cpuset                                
[    0.000000] Initializing cgroup subsys cpu                                   
[    0.000000] Initializing cgroup subsys cpuacct                               
[    0.000000] Linux version 4.4.292+ (dmitrygr@wvm) (gcc version 6.3.0 (Codesca
pe GNU Tools 2017.10-05 for MIPS MTI Linux) ) #109 Sun Sep 11 14:35:39 CDT 2022 
[    0.000000] bootconsole [prom0] enabled                                      
[    0.000000] This is a DECstation 2100/3100                                   
[    0.000000] CPU0 revision is: 00000220 (R3000)                               
[    0.000000] Determined physical RAM map:                                     
[    0.000000]  memory: 01fe0000 @ 00000000 (usable)                            
[    0.000000] Zone ranges:                                                     
[    0.000000]   Normal   [mem 0x0000000000000000-0x0000000001fdffff]           
[    0.000000] Movable zone start for each node                                 
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000000000000-0x0000000001fdffff]          
[    0.000000] Initmem setup node 0 [mem 0x0000000000000000-0x0000000001fdffff] 
[    0.000000] Primary instruction cache 0kB, linesize 0 bytes.                 
[    0.000000] Primary data cache 0kB, linesize 0 bytes.                        
[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pag
es: 8088                                                                        
[    0.000000] Kernel command line: earlyprintk=prom0 console=ttyS3 root=/dev/pv
d3 rootfstype=ext4 rw init=/bin/sh                                              
[    0.000000] PID hash table entries: 128 (order: -3, 512 bytes)               
[    0.000000] Dentry cache hash table entries: 4096 (order: 2, 16384 bytes)    
[    0.000000] Inode-cache hash table entries: 2048 (order: 1, 8192 bytes)      
LEDS set to 0x00                                                                
LEDS set to 0x00                                                                
[    0.000000] Memory: 28488K/32640K available (2940K kernel code, 115K rwdata, 
212K rodata, 180K init, 78K bss, 4152K reserved, 0K cma-reserved)               
[    0.000000] NR_IRQS:128                                                      
                                                                                
Memory read of 1 bytes at physical addr 0x1D000000 fails                        
LEDS set to 0x00                                                                
[    0.000000] Bus error exception: CPU read timeout at 0x1d000000
[    0.000000] Data bus error, epc == 800418f0, ra == 800418e4                  
[    0.000000] Oops[#1]:                                                        
[    0.000000] CPU: 0 PID: 0 Comm: swapper Not tainted 4.4.292+ #109            
[    0.000000] task: 8035bc30 ti: 80356000 task.ti: 80356000                    
[    0.000000] $ 0   : 00000000 10004000 10004000 bd000000                      
[    0.000000] $ 4   : 80357e50 803b0000 00000000 001fffff                      
[    0.000000] $ 8   : 00000002 8033ee04 8033ee18 8033f3b4                      
[    0.000000] $12   : ffffffff ffffff80 818021a4 ffffff80                      
[    0.000000] $16   : 80357e98 8038d9b4 80360000 803a0000                      
[    0.000000] $20   : 00000001 803a0000 00000002 80357e50                      
[    0.000000] $24   : 81036048 00000000                                        
[    0.000000] $28   : 80356000 80357e00 803b0000 800418e4                      
[    0.000000] Hi    : 00003008                                                 
[    0.000000] Lo    : 00001804                                                 
[    0.000000] epc   : 800418f0 0x800418f0                                      
[    0.000000] ra    : 800418e4 0x800418e4                                      
[    0.000000] Status: 10004000                                                 
[    0.000000] Cause : 0000001c (ExcCode 07)                                    
[    0.000000] PrId  : 00000220 (R3000)                                         
[    0.000000] Process swapper (pid: 0, threadinfo=80356000, task=8035bc30, tls=

etc.
Lessons learned:
1) Our memory subsystem actually has 16 bit memory address alignment, not
words, not bytes. This means we can actually do byte/short reads across
even byte boundaries.
2) Be very careful about short/byte reads and writes!

Final read/write functions:

void spiRamRead(uint32_t addr, void *data, uint_fast16_t sz) {

  if (sz < 4) {
    uint8_t localdata[4];
    uint8_t* dataptr = (uint8_t *)data;
    uint32_t align;

    hyperram_read(addr, localdata, 4);
    align = addr & 0x1;

    for(int i = 0; i < sz; i++) {
      *dataptr++ = localdata[align + i];
    }
  } else {
    hyperram_read(addr, data, sz);
  }
}

void spiRamWrite(uint32_t addr, const void *data, uint_fast16_t sz) {

  if (sz < 4) {
    // Do RMW
    uint8_t rmwdata[4];
    uint8_t *dptr = (uint8_t *)data;
    uint32_t start_wr = addr & 0x1;

    hyperram_read(addr, rmwdata, 4);

    for (int i = 0; i < sz; i++) {
      rmwdata[i + start_wr] = *dptr++;
    } 

    hyperram_write(addr, rmwdata, 4);
  } else {
    hyperram_write(addr, data, sz);
  }
}

So, the reference simulator has the following memory regions:
r: 0 pa: 00000000 sz: 02000000 33554432
r: 1 pa: 1fc00000 sz: 00040000 262144
r: 2 pa: 17000000 sz: 01000000 16777216
r: 3 pa: 1e000000 sz: 01000000 16777216
r: 4 pa: 1c000000 sz: 01000000 16777216
r: 5 pa: 1a000000 sz: 02000000 33554432
r: 6 pa: 0fc00000 sz: 03400000 54525952
r: 7 pa: 18000000 sz: 02000000 33554432
r: 8 pa: 1d000000 sz: 01000000 16777216

And we have:
r: 0 pa: 00000000 sz: 01fe0000 33423360                                         
r: 1 pa: 1fc00000 sz: 00000110 272                                              
r: 2 pa: 17000000 sz: 01000000 16777216                                         
r: 3 pa: 1e000000 sz: 01000000 16777216                                         
r: 4 pa: 1c000000 sz: 01000000 16777216                                         
r: 5 pa: 1a000000 sz: 02000000 33554432                                         
r: 6 pa: 18000000 sz: 02000000 33554432                                         
r: 7 pa: 00000000 sz: 00000000 0                                                
r: 8 pa: 00000000 sz: 00000000 0

Our main memory is slightly smaller, (region 0) but that should be OK.
Region 1 (ROM) looks suspicious...
We fault at:
Memory read of 1 bytes at physical addr 0x1D000000 fails                        
LEDS set to 0x00                                                                
[    0.000000] Bus error exception: CPU read timeout at 0x1d000000
[    0.000000] Data bus error, epc == 800418f0, ra == 800418e4                  
Which is region 8 of the reference simulator.

Turns out that we need to fill in the TOY registers:
bool ds1287init(void) {
}

//check for RTC irqs... on pc also tick 1/8192th of a sec
void ds1287step(uint_fast16_t nTicks) {
}

Did a cp ds1287.c ds1287RP2040.c, now gets further:
[    0.000000] WARNING: Persistent clock returned invalid value!                
[    0.000000]          Check your CMOS/BIOS settings.                          
[    0.000000] sched_clock: 32 bits at 16 Hz, resolution 62500000ns, wraps every
 134217727968750000ns                                                           
[    0.000000] Console: colour dummy device 80x25                               
[    0.000000] console [ttyS3] enabled                                          
[    0.000000] bootconsole [prom0] disabled                                     

Just hangs here - guessing that's due to no IRQs getting delivered...

Or perhaps there's no console? Ref simulator output:

[    0.000000] Console: colour dummy device 80x25
[    0.000000] console [ttyS3] enabled
[    0.000000] console [ttyS3] enabled
[    0.000000] bootconsole [prom0] disabled
[    0.000000] bootconsole [prom0] disabled
[    0.000000] Calibrating delay loop... 33.54 BogoMIPS (lpj=1046528)

FYI, here's the new region dump:
r: 0 pa: 00000000 sz: 01fe0000 33423360                                         
r: 1 pa: 1fc00000 sz: 00000110 272                                              
r: 2 pa: 17000000 sz: 01000000 16777216                                         
r: 3 pa: 1e000000 sz: 01000000 16777216                                         
r: 4 pa: 1c000000 sz: 01000000 16777216                                         
r: 5 pa: 1a000000 sz: 02000000 33554432                                         
r: 6 pa: 1d000000 sz: 01000000 16777216                                         
r: 7 pa: 18000000 sz: 02000000 33554432                                         
r: 8 pa: 00000000 sz: 00000000 0

FYI, from BogoMips mini-Howto:
System             BogoMips Reporter
Mips R3000A/20      19.79   Kagstrom <simon.kagstrom.864@_student.lu.se>
Mips R3000/33 Dec   32.82   Martin Michlmayr <tbm@_cyrius.com

From the reference simulator:
root@uMIPS:~# cat /proc/cpuinfo 
system type             : Digital DECstation 2100/3100
machine                 : Unknown
processor               : 0
cpu model               : R3000 V2.0  FPU V2.0
BogoMIPS                : 33.54
wait instruction        : no

20-dec-2023:

Made a little more progress - now hangs at "Calibrating delay loop...".
Implemented repeating timers in the DS1287 code, to simulate osc ticks.
The new timer is ticking, but we're not delivering interrupts.
Instrumenting the ref simulator:
[    0.000000] Calibrating delay loop... ***** sending RTC IRQ
***** sending RTC IRQ
***** sending RTC IRQ
***** sending RTC IRQ
***** sending RTC IRQ
***** sending RTC IRQ
***** sending RTC IRQ
33.54 BogoMIPS (lpj=1046528)

So, adding printf to both simulators shows that the ref simulator does
do a read of 0x0c to clear the interrupts, but the hw simulator does not.
Looking at the cpuAsm.S interrupt delivery mech...
Turns out that there was a logic problem with our enabling of interrupts.
Old:
	if (!mDS1287.pf) {
		mDS1287.pf = 1;
		if (mDS1287.pie && !mDS1287.irqf) {
			mDS1287.irqf = 1;
			cpuIrq(SOC_IRQNO_RTC, true);
			pr("***** sending IRQ\n");
		}
         }

Problem was that our callback set the pf flag, as soon as the periodic timer
was enabled. This prevented delivering any interrupts, once the DS1287
interrupt enable register was set.
Fix:

  // Deliver an interrupt (once per timer event) if enabled.
  // May not be a precise emulation, since the data sheet implies
  // that the irq pin is asserted as long as the pf flag is set
  if (mDS1287.pie && !mDS1287.irqf) {
    mDS1287.irqf = 1;
    cpuIrq(SOC_IRQNO_RTC, true);
  }

  // Emulate the periodic event flag. Only cleared by a read from reg 0x0c
  if (!mDS1287.pf) {
    mDS1287.pf = 1;
  }

Now we get:
[    0.125000] Calibrating delay loop... 1.46 BogoMIPS (lpj=45760)              
[    1.000000] pid_max: default: 32768 minimum: 301                             
[    1.000000] Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)      
[    1.000000] Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes) 
[    1.375000] Initializing cgroup subsys memory                                
[    1.437500] Initializing cgroup subsys devices                               
[    1.437500] Initializing cgroup subsys pids                                  
[    2.062500] devtmpfs: initialized                                            
[    2.500000] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, ms
[    2.500000] futex hash table entries: 256 (order: -1, 3072 bytes)            
[    2.875000] NET: Registered protocol family 16                               
[   10.750000] NET: Registered protocol family 2                                
[   10.812500] IP idents hash table entries: 2048 (order: 2, 16384 bytes)       
[   11.187500] TCP established hash table entries: 1024 (order: 0, 4096 bytes)  
[   11.250000] TCP bind hash table entries: 1024 (order: 0, 4096 bytes)         
[   11.250000] TCP: Hash tables configured (established 1024 bind 1024)         
[   11.312500] UDP hash table entries: 256 (order: 0, 4096 bytes)               
[   11.375000] UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)          
[   11.500000] NET: Registered protocol family 1                                
[   12.250000] fuse init (API version 7.23)                                     
[   12.500000] Block layer SCSI generic (bsg) driver version 0.4 loaded (major )
[   12.500000] io scheduler noop registered (default)                           
[   12.625000] DECstation DZ serial driver version 1.04                         
[   12.625000] ttyS0 at MMIO 0x1c000000 (irq = 4, base_baud = 0) is a DZ        
[   12.812500] ttyS1 at MMIO 0x1c000000 (irq = 4, base_baud = 0) is a DZ        
[   12.937500] ttyS2 at MMIO 0x1c000000 (irq = 4, base_baud = 0) is a DZ        
[   13.125000] ttyS3 at MMIO 0x1c000000 (irq = 4, base_baud = 0) is a DZ        
[   15.875000] loop: module loaded                                              
[   15.937500] PVD: found device with 1179664 sectors                           
[   15.937500] PVD: Allocated major number 254 for PVD device                   
[   16.437500]  pvd: pvd1 pvd2 pvd3                                             
[   17.125000] NET: Registered protocol family 17                               
[   17.562500] registered taskstats version 1                                   
[   17.687500] hctosys: unable to open rtc device (rtc0)                        
[   22.437500] EXT4-fs (pvd3): recovery complete                                
[   22.562500] EXT4-fs (pvd3): mounted filesystem with ordered data mode. Opts:)
[   22.625000] VFS: Mounted root (ext4 filesystem) on device 254:3.             
[   23.375000] devtmpfs: mounted                                                
[   23.562500] Freeing unused PROM memory: 252k freed                           
[   23.687500] Freeing unused kernel memory: 180K                               
/bin/sh: 0: can't access tty; job control turned off                            
# [   97.250000] random: nonblocking pool is initialized

Note that this is with the C version of the cpu emulator. Trying with
assembly version: and it hangs! Right at the same place: calibrating delay loop.
IRQ problems again?

An aside: our VM reports 5389 bogomips, with a cpu MHz of 2694, and the reference emulator gives 33.54 bogomips with these parameters. The reference emulator
is 1.46 bogomips, with the RP2040 running at 300 MHz. 

The BogoMips mini-howto reports 32.82 for a Mips R3000/33 system.

So the question is: can the assembly version run 23 times faster?? Probably
not... Dmitry's ref emulator delivers 0.78 bogoMips at 72 MHz, presumably
with the assembly version of the cpu emulator. So: 300 MHz * 0.0108 = 3.24
Off by a factor of 10.

with C emulator:
    0.000000] NR_IRQS:128
***** new timer: -62500
***** RTC write to 0x0a: 06
***** RTC write to 0x0a: 46
[    0.000000] sched_clock: 32 bits at 16 Hz, resolution 62500000ns, wraps evers
8 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 0
7 **** delivering RTC irq
7 **** RTC read from 0x0c: D0
[    0.062500] Console: colour dummy device 80x25
[    0.062500] console [ttyS6 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf:0
5 **** delivering RTC irq
3] enabled
[    0.062500] console [ttyS3] enabled
5 **** RTC read from 0x0c: C0
[    0.125000] bootconsole [prom0] disabled
[    0.125000] bootconsole [prom0] disabled
[    0.125000] Calibrating delay loop... 4 **** in RTC callback mDS1287.pie: 1 0
3 **** delivering RTC irq
3 **** RTC read from 0x0c: C0
2 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 0
1 **** delivering RTC irq
1 **** RTC read from 0x0c: C0
0 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 0
1.44 BogoMIPS (lpj=45056)
[    0.875000] pid_max: default: 32768 minimum: 301
[

asm emu:
***** new timer: -62500
***** RTC write to 0x0a: 06
***** RTC write to 0x0a: 46
[    0.000000] sched_clock: 32 bits at 16 Hz, resolution 62500000ns, wraps evers
[    0.000000] Console: colour dummy device 80x25
[    0.000000] console [ttyS3] enabled
[    0.000000] console [ttyS3] enabled
[    0.000000] bootconsole [prom0] disabled
[    0.000000] bootconsole [prom0] disabled
10 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 0
9 **** delivering RTC irq
9 **** RTC read from 0x0c: D0
[    0.000000] Calibrating delay loop... 8 **** in RTC callback mDS1287.pie: 1 0
7 **** delivering RTC irq
6 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 1
5 **** in RTC callback mDS1287.pie: 1 mDS1287.irqf: 1
4 ***

25-dec-2023:

Experiments attempting to fix IRQ problem for ASM version of emulator.
1) Push IRQ clear to periodic ISR. Results for C emu:
0011612 50 **** RTC wr: 0A 2C
10014989 50 **** RTC rd: 0B 06
10015210 50 **** RTC wr: 0B 06
10018255 50 **** RTC rd: 0B 06
10020768 50 **** RTC wr: 0B 46
10026084 49 **** in RTC callback 0000001C
***** new timer: -62500
10029446 49 **** pf: 1
10031528 49 **** delivering RTC irq
10034741 before cause: 0000001C
10037606 after cause: 0000201C
[    0.000000] sched_clock: 32 bits at 16 Hz, resolution 62500000ns, wraps evers
10073516 49 **** RTC rd: 0C D0
10077920 49 **** RTC rd: 0C 00
10081253 49 **** RTC rd: 0C 00
10084578 49 **** RTC rd: 0C 00
10087900 49 **** RTC rd: 0C 00
10091227 49 **** RTC rd: 0C 00
10091946 48 **** in RTC callback 00002000
10094875 48 **** pf: 0
10096958 48 **** delivering RTC irq
10100171 before cause: 00002000
10103036 after cause: 00000000
10105814 @@@@@@ setting pf: 00000000

With Asm emu:
7937361 50 **** RTC wr: 0A 2C
07940006 50 **** RTC rd: 0B 06
07941980 50 **** RTC wr: 0B 06
07944890 50 **** RTC rd: 0B 06
07947537 50 **** RTC wr: 0B 46
[    0.000000] sched_clock: 32 bits at 16 Hz, resolution 62500000ns, wraps eve0C
***** new timer: -62500
07969465 49 **** pf: 1
07971548 49 **** delivering RTC irq
07974760 before cause: 0000001C
07977625 after cause: 0000201C
ry 134217727968750000ns
07983332 49 **** RTC rd: 0C D0
07986907 49 **** RTC rd: 0C 00
07989728 49 **** RTC rd: 0C 00
07992513 49 **** RTC rd: 0C 00
07995291 49 **** RTC rd: 0C 00
07998069 49 **** RTC rd: 0C 00
08000848 49 **** RTC rd: 0C 00
08003626 49 **** RTC rd: 0C 00
08006404 49 **** RTC rd: 0C 00
08009183 49 **** RTC rd: 0C 00
08011961 49 **** RTC rd: 0C 00
08014739 49 **** RTC rd: 0C 00
08017518 49 **** RTC rd: 0C 00
08020296 49 **** RTC rd: 0C 00
08023074 49 **** RTC rd: 0C 00
08025853 49 **** RTC rd: 0C 00
08028725 49 **** RTC rd: 0C 10
08031409 49 **** RTC rd:08031965 48 **** in RTC callback 00002000
08035623 48 **** pf: 0
08037707 48 **** delivering RTC irq
08040919 before cause: 00002000

Delta between 0c reads:
Asm emu:
07992513 - 07989728
2785
07989728 - 07986907
2821
07986907 - 07983332
3575

C emu:
10084578 - 10081253
3325
10081253 - 10077920
3333
10077920 - 10073516
4404

9-jan-2024:

Finally fixed irq issue. Remembered that the project description talked
about reserving R11 for IRQ servicing. Added:
add_compile_options(-ffixed-r11)
to CMakeLists.txt at the psram_wren level. Should make this specific to
the MIPs emulator? Probably depends on how the libraries use R11...

Boosted bogoMIPS substantially:
[    2.125000] bootconsole [prom0] disabled
[    2.125000] Calibrating delay loop... 6.89 BogoMIPS (lpj=215040)
[   25.625000] pid_max: default: 32768 minimum: 301

old:
1.44 BogoMIPS (lpj=45056)

So only 4.76 slower than a reference R3000 MIPs system.

13-jan-2024:

BTW: here's the commment that allowed me to fix the IRQ issue, from cpuAsm.S:
//we use reg to point to handle_irq or do_cycle
//we adjust as needed - will save a few cycles per instr
//but we need free reg first: r11
// will need to add  -ffixed-r11 to compiler args
//but gcc's FPU code uses r11 so we stash a boolean
//in cpu struct to tell us if we're in fpu code.
//on return we restore proper value to r11
//we assume no other code uses r11. bad bad things will
//happen if it does! This really should be reverified
//in m3/m7 ports too, in case libgcc uses r11 for other
//things there too

23-jan-2024:

Fixed C version of emulator by reverting some of changes made to the
DS1287 emulation. (Mostly, removed the internal time registers).

Now, on to the serial input...

Added to usartRP2040.c:
struct repeating_timer timerChar;

bool checkchar_callback(struct repeating_timer *t) {

  uint32_t c = getchar_timeout_us(0);

  if (c != PICO_ERROR_TIMEOUT) {
    usartExtRx(c);
  }

}

void usartInit(void) {
  stdio_init_all();
  //sleep_ms(3000);

  // -50MS so that the timer will repeat 500 per sec, regardless of how
  // long the callback takes to execute
  add_repeating_timer_ms(-50, checkchar_callback, NULL, &timerChar);
}  

Works when using cpu.c, not cpuAsm.s. In latter case, accepts inputs,
but hangs during execution:

[  329.187500] Freeing unused kernel memory: 180K
/bin/sh: 0: can't access tty; job control turned off
# ls

vs:
[  344.750000] Freeing unused kernel memory: 180K
/bin/sh: 0: can't access tty; job control turned off
# ls
bin   dev  home  lib64  mnt  proc  run   selinux  swapfile  tmp  var
boot  etc  lib   media  opt  root  sbin  srv      sys       usr
# 

Using cpu.c, commands take a perceptible amount of time: ls is 5 seconds
from <ret>.

cpu.c exec init hangs. Actually, just needed to wait a long time...

There seems to be a problem with time:
# uptime ; sleep 1 ; uptime
 19:48:03 up  1:48,  0 users,  load average: 0.49, 0.13, 0.04
 19:49:24 up  1:49,  0 users,  load average: 0.94, 0.37, 0.14

A rough guess gives 6 seconds per uptime command, and 5 seconds per sleep.
# uptime ; uptime
 20:36:13 up  2:36,  0 users,  load average: 0.53, 0.14, 0.05
 20:37:00 up  2:37,  0 users,  load average: 0.78, 0.26, 0.10

This gives 47 seconds per uptime.

Found one problem: didn't return true at the end of the one HZ
repeating timer ISR.

RTC set to index 12, or 62.5 ms.

With add_repeating_timer_ms(-62 * 8, 
# uptime ; uptime
 18:21:30 up 21 min,  0 users,  load average: 0.98, 0.62, 0.45
 18:22:04 up 22 min,  0 users,  load average: 0.99, 0.67, 0.47

With add_repeating_timer_ms(-62 * 16, 
# uptime; uptime
 18:22:29 up 22 min,  0 users,  load average: 0.31, 0.49, 0.54
 18:23:03 up 22 min,  0 users,  load average: 0.58, 0.54, 0.56
#

With add_repeating_timer_ms(-62 * 32, 
# uptime ; uptime
 18:23:11 up 23 min,  0 users,  load average: 0.79, 0.74, 0.67
 18:24:19 up 24 min,  0 users,  load average: 0.88, 0.77, 0.68
# 

Dmitry runs the samd21 at 90MHz. The samd31 ds1287 clock write:
mCntTops[] = {0xffff /* as rare as possible */, 487, 976, 14, 30, 60, 121, 243, 487, 976, 1952, 3905, 7811, 15624, 31249, 62499, };
hzVals[] = {0, 256, 128, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2};


Index 12 is: 7811, at a sysclk of 16 Hz.

clk/hz: 7812/16 = 488.25.

So, added tick count to ds1287:
160 counts per 10 one hz ISR, so clock set to 16 Hz.

Could be that we're delivering too many irq... Yup:
# uptime ; uptime
 18:00:36 up 0 min,  0 users,  load average: 0.25, 0.06, 0.02
 18:00:38 up 0 min,  0 users,  load average: 0.25, 0.06, 0.02

Added:
line:362			cpuIrq(SOC_IRQNO_RTC, false);

This clears the IRQ when rtc reg 0x0c is read.

Also fixed the hang when running cpuAsm.S. New bogoMIPS:
[    0.062500] bootconsole [prom0] disabled
[    0.062500] Calibrating delay loop... 13.44 BogoMIPS (lpj=419328)

Now only 2.49 times slower than a R3000/33!

Was able to execute exec init:
root@uMIPS:~# whoami
root
root@uMIPS:~# uname -a
Linux uMIPS 4.4.292+ #109 Sun Sep 11 14:35:39 CDT 2022 mips GNU/Linux
root@uMIPS:~# 

System is pretty responsive, when not loading from disk...

24-jan-2024:

Timinig exec init:
 .baud_rate = 25 * 1000 * 1000,
07:15:29 - 06:53:29 = 22 min

With .baud_rate = 100 * 1000 * 1000,
11:25:35 - 11:03:19 = 22 min

with spi.c:
        spi_init(spi_p->hw_inst, 400 * 1000);
[    6.562500] VFS: Mounted root (ext4 filesystem) on device 254:3.             
[    6.750000] devtmpfs: mounted                                                
[    6.812500] Freeing unused PROM memory: 252k freed                           
[    6.812500] Freeing unused kernel memory: 180K

        spi_init(spi_p->hw_inst, 1000 * 1000);
[    4.812500] VFS: Mounted root (ext4 filesystem) on device 254:3.             
[    5.062500] devtmpfs: mounted                                                
[    5.125000] Freeing unused PROM memory: 252k freed                           
[    5.125000] Freeing unused kernel memory: 180K  	

        spi_init(spi_p->hw_inst, 10 * 1000 * 1000);
[    4.812500] VFS: Mounted root (ext4 filesystem) on device 254:3.             
[    5.062500] devtmpfs: mounted                                                
[    5.125000] Freeing unused PROM memory: 252k freed                           
[    5.125000] Freeing unused kernel memory: 180K      

So it looks like 1 MHz is the max SD SPI rate.

29-jan-2024:

Made 1 MHz SPI rate, given above. Measuring resultant exec init time:
Failed with:
  653.937500] Bus error exception: CPU memory read parity error at 0x01f9f000  
[  653.937500] Data bus error, epc == 80050874, ra == 800d471c                  
[  653.937500] Oops[#1]:                                                        
[  653.937500] CPU: 0 PID: 1236 Comm: startpar Not tainted 4.4.292+ #109        
[  653.937500] task: 81a7b000 ti: 819ac000 task.ti: 819ac000                   

Reverted back to 100KHz rate.

Disk images:
linux.wheezy
ultrix.gui
ultrix.textmode
ultrix.tmp

Attempted to boot ultrix.textmode:
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999                   
real mem = 33157120                                                             
avail mem = 26947584                                                            
using 809 buffers containing 3313664 bytes of memory                            
KN01 processor - system rev 1                                                   
cpu0 ( version 1.5, implementation 0 )                                          
fpu0 ( version 0.0, implementation 0 )                                          
                                                                                
Exception condition                                                             
        Cause reg       = 0x28                                                  
        Exception PC    = 0x800fad04                                            
        Status reg      = 0x20000000                                            
        Bad virt addr   = 0x0                                                   
                                                                                
                                                                                
cpu 0 panic: trap                                                               
routine: 0x800a11d4 called from: 0x800fd81c                                     
routine: 0x800fd490 called from: 0x8010d848                                     
routine: 0x8010d1b0 called from: 0x800ffc88                                     
                                                                                
TRACE ABORTED: Trace confused                                                   
                                                                                
                                                                                
                                                                                
locks held by cpu 0                                                             
                                                                                
                                                                                
print locks held by non-active processes                                        
done                                                                            
                                                                                
Exception condition                                                             
        Cause reg       = 0x8                                                   
        Exception PC    = 0x800a1478                                            
        Status reg      = 0x14                                                  
        Bad virt addr   = 0x8c                                                  
                                                                                
Exception condition                                                             
        Cause reg       = 0x8                                                   
        Exception PC    = 0x8012e964                                            
        Status reg      = 0x4                                                   
        Bad virt addr   = 0x0                                                   
                                                                                
                                                                                
HALTED                                                                          

Weird: I'm getting memory parity errors galore, when booting. Example:
    5.500000] Bus error exception: CPU memory read parity error at 0x01f9f000
[    5.500000] Data bus error, epc == 8020d3f0, ra == 801ab948
[    5.500000] Oops[#1]:
[    5.500000] CPU: 0 PID: 1 Comm: swapper Not tainted 4.4.292+ #109

Tried changing clock rate - still failed. (Note: have to change clock rate
in both hyperram.c: hyperram_init and in ucHwRP2040.c: initHwSuperEarly

New bogoMIPS: 5.48.

Tried 2nd board, boots fine. Hardware problems?? Yes! Swapped uSD cards,
failure follows card...Re-wrote uSD images, now works.


Tried booting ultrix.gui:
Memory write of 2 bytes at physical addr 0x11000000 fails

6-feb-2024:

Managed to integrate graphics library into simulator. Had some problems
with getting the system clock passed in correctly for the pixel rate
calculation.

Trying to boot textmode again, as graphics mode failed with:

ws: Timeout on byte -1 of self-test report

In order to use the C version of cpu, had to conditionalize out graphics,
as the image was too large for the RP2040's SRAM...
(the define is: NO_FRAMEBUFFER, used in CMakelists target_compile_definitions:
#  MONO_FRAMEBUFFER
  NO_FRAMEBUFFER

Weird things with textmode and cpu.c:
Memory write of 4 bytes at physical addr 0x01FE0000 fails
dBUS error pa 0x01fe0000 at pc 0x80102188 ra 0x801037a4
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 33423360
avail mem = 27185152
using 816 buffers containing 3342336 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
unknown instruction 0x4442F800 @ 0x800FAD00 (17 0)


With EMULATOR_RAM_MB set to 16:
Memory write of 4 bytes at physical addr 0x00FE0000 fails
dBUS error pa 0x00fe0000 at pc 0x80102188 ra 0x801037a4
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 16646144
avail mem = 12201984

Perhaps the memory probe routine tries to write off the edge to size memory?

Ok, so the unknown instruction is actually:
		case 17: //COP1 (FPU)
			if (!cpuPrvCopAccess(1))
				return;
	#if defined(FPU_SUPPORT_FULL) || defined(FPU_SUPPORT_MINIMAL)			
(from cpu.c)
I guess I have to turn on FPU support for ultrix. Currently set to
FPU_SUPPORT_NONE.

Using: FPU_SUPPORT_MINIMAL gives:


Memory write of 4 bytes at physical addr 0x01FE0000 fails
dBUS error pa 0x01fe0000 at pc 0x80102188 ra 0x801037a4
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 33423360
avail mem = 27185152
using 816 buffers containing 3342336 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
Read 0x000FAD00: 4442f800
dc0 at ibus0
fb0 at ibus0
HBA 'sii' and DME 'siiram' attached on Controller 0.
sii0 at ibus0
rz6 at sii0 slave 6 ()
ln0 at ibus0
ln0: DEC LANCE Ethernet Interface, hardware address: 66:44:22:44:66:22 
rtc index/val: 8 -3906
battery backup clock not valid
WARNING: lost battery backup clock rtc index/val: 12 -62500
-- CHECK AND RESET THE DATE!
Mon Dec 13 00:50:13 CST 1999
Automatic reboot in progress...
/dev/rz6a: 595 files, 9243 used, 6852 free (60 frags, 849 blocks, 0.4% fragment)
/dev/rrz6g: PARTIALLY TRUNCATED INODE I=4123 (SALVAGED)
/dev/rrz6g: INCORRECT BLOCK COUNT I=4126 (2 should be 0) (CORRECTED)
/dev/rrz6g: BLK(S) MISSING IN BIT MAPS (SALVAGED)
/dev/rrz6g: FILE SYSTEM MODIFIED, VERIFYING
/dev/rrz6g: 10992 files, 429579 used, 1552179 free (3531 frags, 193581 blocks, )
check quotas: done.
savecore: checking for dump...dump does not exist
local daemons: syslog sendmail.
Removing remnant Opser files
preserving editor files
clearing /tmp
standard daemons: update cron accounting network snmpd.
start errlog daemon - elcsd
Mon Dec 13 00:53:31 CST 1999


ULTRIX V4.5 (Rev. 47) (uMIPS)

login: root
Password:
Last login: Mon Dec 13 00:49:34 on console
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
UWS V4.5 (Rev. 6)

                Digital Equipment Corporation
                Nashua, New Hampshire


Welcome to uMIPS
# shutdown -h now
Shutdown at 00:53 (in 0 minutes) [pid 142]

System shutdown time has arrived
# syncing disks... done
halting.... (transferring to monitor)



HALTED


A milestone reached! And it even appears to work with cpuAsm.S enabled...

Note that the rootpassword is mipsmips - also the same for Linux...

Trying to build with graphics enabled caused the RAM region to overflow.
I guess adding the FPU support pushed us over the limit.

Removed double buffering for setting the frame buffer start, which
enabled compilation. Unfortunately, still fails during execution:

using 809 buffers containing 3313664 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
dc0 at ibus0

Exception condition
        Cause reg       = 0x1c
        Exception PC    = 0x800fd410
        Status reg      = 0xff04
        Bad virt addr   = 0xafc36100


cpu 0 panic: bus timeout
routine: 0x800a11d4 called from: 0x800fd784
routine: 0x800fd490 called from: 0x8010d848
routine: 0x8010d1b0 called from: 0x800ffc88

TRACE ABORTED: Trace confused

7-feb-2024:

Today's bug: figure out why we're getting bus errors when booting the
textmode version of Ultrix with graphics compiled in:

uMIPS v2.2.0 (BL ver 37)
 will run with 32MB
r: 0 pa: 0fc00000 sz: 03400000 54525952
r: 1 pa: 00000000 sz: 01f9f000 33157120
r: 2 pa: 1fc00000 sz: 00000110 272
r: 3 pa: 17000000 sz: 01000000 16777216
r: 4 pa: 1e000000 sz: 01000000 16777216
r: 5 pa: 1c000000 sz: 01000000 16777216
r: 6 pa: 1a000000 sz: 02000000 33554432
r: 7 pa: 1d000000 sz: 01000000 16777216
r: 8 pa: 18000000 sz: 02000000 33554432


ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 33157120
avail mem = 26947584
using 809 buffers containing 3313664 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
dc0 at ibus0

Exception condition
        Cause reg       = 0x1c
        Exception PC    = 0x800fd410
        Status reg      = 0xff04
        Bad virt addr   = 0xafc36100


If we return 0 in the mBusCSR:
MIPS v2.2.0 (BL ver 37)
 will run with 32MB
r: 0 pa: 0fc00000 sz: 03400000 54525952
r: 1 pa: 00000000 sz: 01f9f000 33157120
r: 2 pa: 1fc00000 sz: 00000110 272
r: 3 pa: 17000000 sz: 01000000 16777216
r: 4 pa: 1e000000 sz: 01000000 16777216
r: 5 pa: 1c000000 sz: 01000000 16777216
r: 6 pa: 1a000000 sz: 02000000 33554432
r: 7 pa: 1d000000 sz: 01000000 16777216
r: 8 pa: 18000000 sz: 02000000 33554432
hello, world

ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 33157120
avail mem = 26947584
using 809 buffers containing 3313664 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
dc0 at ibus0
fb0 at ibus0
HBA 'sii' and DME 'siiram' attached on Controller 0.
sii0 at ibus0
rz6 at sii0 slave 6 ()
ln0 at ibus0
ln0: DEC LANCE Ethernet Interface, hardware address: 66:44:22:44:66:22 

etc...

Had to return true when returning from gfxPrvFramebuffer!
In order to find this, enabled cpu.c after freeing up bss memory by adding
to fb_mono.c:
#define MIN_VIDEO_MEM
#ifdef MIN_VIDEO_MEM
// For minimum memor usage: 640x480
#define MAX_LINES 525
#define MAX_ACTIVE_LINES 480
#else
// Accomodate screen formats up to 1125 (1080P) vertical total lines
#define MAX_LINES 1125
#define MAX_ACTIVE_LINES 1080
#endif

This yielded:
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
real mem = 33157120
avail mem = 26947584
using 809 buffers containing 3313664 bytes of memory
KN01 processor - system rev 1
cpu0 ( version 1.5, implementation 0 )
fpu0 ( version 0.0, implementation 0 )
dc0 at ibus0
gfx mem access wr/adr: 1 0FC36100
wr/adr: 1 00036100
dBUS error pa 0x0fc36100 at pc 0x800fd410 ra 0x800fd328

When booting with cpuAsm.S, ultrix.gui, maximum video mode, still get:
  0x00063870 / 0x00063870 -> 100%
[6]: '.comment' 00000000h->00000000h+00000024h@1576E0h (R: 0@000000h L: 0@00000h

ws: Timeout on byte -1 of self-test report


rtc index/val: 8 -3906
rtc index/val: 12 -62500


ULTRIX V4.5 (Rev. 47) (uMIPS)

login: root
Password:
Last login: Mon Dec 13 01:11:34 on tty01
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999
UWS V4.5 (Rev. 6)

                Digital Equipment Corporation
                Nashua, New Hampshire


I turned on the display, and actually saw the Digital Logo!!!
I guess the timeout message above doesn't matter??

Re-enabling cpuAsm, and full resolution display...

Seeing "snow" (i.e. uncleared pixels) in the display. Could be our
display stride does not match that used by ultrix. From graphics.h:
#elif defined(MONO_FRAMEBUFFER)
	#define SCREEN_STRIDE			(256)
	#define SCREEN_BYTES			(0x00040000)
	#define SCREEN_PALETTE_BYTES	(4 * (256 + 16))

The screen is 1024 x 864 (visible), or 1024 x 1024 (fb size). Or,
1024 x 1024/8 = 1024 x 128 or 128KB, or 0x40000.
One scanline is 128 bytes, or 32 32 bit words. Why is stride above
256?

This is why (from pg 82 of the DS3100 functional specification):
6.12. Monochrome Frame Buffer
The VFB01 monochrome frame buffer option contains a 1024-by-864-pixel, 1-plane, frame buffer.
The frame buffer appears as a 64-K-by-32-bit region of memory in the processor address space.
The frame buffer is organized as 2048 by 1024 pixels, of which the upper-left-hand 1024-by-864
pixels are displayed

Weird, eh? I bet it has to do with the VRAM shift register width...

Taking an extraordinary amount of time to boot: already have waited 15 minutes.
Perhaps we need to look at speeding up disk I/O. Now 50 minutes. Wonder if
it's still working? Ok, rebooting with cpu.c to see how long that takes.
That actually worked - booted to prompt in about 3 minutes. No logo, though.
Logo takes another two minutes.

Finessed the .bss overflow by defining exactly the number of lines
needed by the dma blocks. Booted, and was able to see the entire screen!
Unfortunately, it hangs. I'm guessing that the extra memory pressure
caused the failure. (Would also explain why it fails with cpuAsm.S).

Nope, eventually got to the login prompt. Retrying cpuAsm.S... Nope, still
didn't boot.

8-feb-2024:

Still can't seem to boot with cpuArm.S.

FYI: decwindows apps can be found in /usr/bin, starting wtih dx. E.g.:
dxpaint, dxclock, dxterm.

Do a setenv DISPLAY :0, then run above.

Tried disabling CRTC, still no boot with cpuArm.S. Booting ultrix.textmode
does work with cpuArm.S, when NO_FRAMEBUFFER is defined.

9-feb-2024:

With cpu.c, and ultrix.textmode:
Memory write of 4 bytes at physical addr 0x01F9F000 fails
dBUS error pa 0x01f9f000 at pc 0x80102188 ra 0x801037a4

10-feb-2024:

Still debugging. With cpu.c:
AccessCSR: pa/size: 1E000000 0 read: 00000800
gfx mem access wr/adr: 1 0FC36100
gfx mem access wr/adr: 1 0FC36188
gfx mem access wr/adr: 0 0FC36100

With cpuAsm.S:
dc0 at ibus0
AccessCSR: pa/size: 1E000000 0 read: 00000800

Exception condition
        Cause reg       = 0x1c
        Exception PC    = 0x800fd410
        Status reg      = 0xff04
        Bad virt addr   = 0xafc36100

So, note that the bad virt addr of 0xafc36100 and the gfx mem addr: 0x0FC36100.

Need to see if .S handles gfx access differently than .c...

AccessCSR: pa/size: 1E000000 0 read: 00000800                                   
hit at 0FC36100 sz/wr: 1 1                                                      
gfx mem access wr/adr: 1 0FC36100                                               
gfx mem access wr/adr: 1 0FC36188                                               
hit at 0FC36100 sz/wr: 1 0                                                      
gfx mem access wr/adr: 0 0FC36100                                               

Address map:
    Address Range       Size  Region  Properties
0x00000000..0x7FFFFFFF   2.0  KUSEG   Mapped and cached
0x80000000..0x9FFFFFFF   0.5  KSEG0   Unmapped and cached
0xA0000000..0xBFFFFFFF   0.5  KSEG1   Unmapped and uncached
0xC0000000..0xFFFFFFFF   1.0  KSEG2   Mapped and cached

So the virt address is in KSEG1.

Added to mem.c:
	if ((addr & ~0xff) == 0x0FC36100) {
	  pr("hit at %08x sz/wr: %d %d\n", 
	     addr, size, write);
	  while (1) {}
	}
This worked for .c, but not for .S. Must have a problem in .S pa->virt xlate...

error addr:  0x0FC36100

ram:         0x00000000 - 0x01F9EFFF                                            
palette:     0x01F9FBC0 - 0x01F9FFFFframebuffer: 0x01FA0000 - 0x01FDFFFF                                            

r: 0 pa: 0fc00000 sz: 03400000 54525952                                         
r: 1 pa: 00000000 sz: 01f9f000 33157120                                         
r: 2 pa: 1fc00000 sz: 00000110 272                                              
r: 3 pa: 17000000 sz: 01000000 16777216                                         
r: 4 pa: 1e000000 sz: 01000000 16777216                                         
r: 5 pa: 1c000000 sz: 01000000 16777216                                         
r: 6 pa: 1a000000 sz: 02000000 33554432                                         
r: 7 pa: 1d000000 sz: 01000000 16777216                                         
r: 8 pa: 18000000 sz: 02000000 33554432

graphics ranges from 0x0fc00000 to 0x13000000, so error addr 0x0fc36100 falls in
that range. Within graphics range, we have:
fb: 0x0fc00000 to 0x0fd00000, so error addr is in fb range.

Need to understand why the .S mapper is faulting this address. I wonder
if the OFST_MEMLIMIT variable is set correctly...
#define OFST_MEMLIMIT			0x3c
.globl mCpu


11-feb-2024:

So, looking at MD00090-2B-MIPS32PRA-AFP-06.02.pdf, pg 95, table 8-25,
a cause reg of 0x1c translates to an exccode field value of 0x03. This
is a TLB exeception, store (TLBS). 

12-feb-2024:

Dumping the tlb from cpu.c, after the fourth graphics region access:
0 va: FFFFC000 pa: 002A0000 asid: 00 flags: 70 rfu: 0 g: 1 v:1 d:1 n:0          
1 va: FFFFD000 pa: 002A1000 asid: 00 flags: 70 rfu: 0 g: 1 v:1 d:1 n:0          
2 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
3 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
4 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
5 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
6 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
7 va: 80000000 pa: 00000000 asid: 00 flags: 00 rfu: 0 g: 0 v:0 d:0 n:0          
8 va: C0598000 pa: 0058F000 asid: 00 flags: 70 rfu: 0 g: 1 v:1 d:1 n:0          
9 va: C25DC000 pa: 005EC000 asid: 00 flags: 70 rfu: 0 g: 1 v:1 d:1 n:0          


So, all of these appear to be kseg2 mappings. Don't see how they
map to the FB.

n - no cache. Don't use I/D caches for this mapping.
d - dirty. If 0, page is write protected. (i.e. fault on write).
v - valid
g - global. Ignore PID when mapping

So, adding cpu.c:
static bool cpuPrvMemTranslate(uint32_t *paP, uint32_t va, bool write)
	if (va == 0xafc36100) {
	  pr(" memtralate hit at %08x\n", va);
	  pr(" switch val: %02d\n", va >> 29);
	  pr(" isinkernelmode: %d\n", cpuPrvIsInKernelMode());
	  pr(" paP: %08x\n", va &~ 0xe0000000);
	}

yielded:
 memtralate hit at AFC36100                                                     
 switch val: 05                                                                 
 isinkernelmode: 1                                                              
 paP: 0FC36100

and the relevant code:
		case 4:	//kseg0
		case 5:	//kseg1
			if (!cpuPrvIsInKernelMode()) {
	//			fprintf(stderr, "addr err 1 0x%08x\n", va);
				cpuPrvTakeAddressError(va, false);
				return false;
			}
			*paP = va &~ 0xe0000000;
			return true;

So, the is in kernel mode code in cpuAsm.S needs to be examined.


13-feb-2024:

Recreated cpuAsm.S error, via adding the following to cpu.c:
static bool cpuPrvMemTranslate(uint32_t *paP, uint32_t va, bool write)
{
	int_fast8_t idx;
	
	if (va == 0xafc36100) {
#if 0
	  pr(" memtralate hit at %08x\n", va);
	  pr(" switch val: %02d\n", va >> 29);
	  pr(" isinkernelmode: %d\n", cpuPrvIsInKernelMode());
	  pr(" paP: %08x\n", va &~ 0xe0000000);
#endif
	  cpuPrvTakeAddressError(va, false);
	  return false;
	}

	switch (va >> 29) {

Result:
AccessCSR: pa/size: 1E000000 0 read: 00000800
take excep: 04

Exception condition
        Cause reg       = 0x10
        Exception PC    = 0x800fd410
        Status reg      = 0xff04
        Bad virt addr   = 0xafc36100


cpu 0 panic: unaligned access
routine: 0x800a11d4 called from: 0x800fd7ec
routine: 0x800fd490 called from: 0x8010d848
routine: 0x8010d1b0 called from: 0x800ffc88

This would suggest that there's a bug in cpuAsm.S, possibly
in either segment determination, or with kernel mode signalling.

Instrumenting:
memtranslate hit at AFC36100
 switch val: 05
 isinkernelmode: 1
 paP: 0FC36100
take excep: 04

So, .S code:

	lsls		\pa, \vaUse, #1
	bcc			80f					//kuseg - needs translation
	bmi			81f					//ksseg/kseg3 - translate if not in user
//kseg0 and kseg1 - direct map to PA in kernel mode, fault in user mode
	isUsrMode	\pa

For 0xafc36100, shift left by one results in carry flag set, N flag clear. 0xA = 0b1011. 
So we should drop into isUsrMode


Recall segment mapping:
0x00000000..0x7FFFFFFF   2.0  KUSEG   Mapped and cached
0x80000000..0x9FFFFFFF   0.5  KSEG0   Unmapped and cached
0xA0000000..0xBFFFFFFF   0.5  KSEG1   Unmapped and uncached
0xC0000000..0xFFFFFFFF   1.0  KSEG2   Mapped and cached

0b000 - 0b011: KUSEG
0b100        : KSEG0
0b101        : KSEG1
0b110 - 0b111: KSEG2

So, upper three bits:
0 - 3, i.e. bit<31> clear in VA
4 - 5, i.e. bit<31> set, bit<30> clear
6 - 7, i.e. bit<31> set, bit<30> clear

feb-14-2024:

Figuring out memory allocation. From boot messages:
ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999                   
real mem = 33161216                                                             
avail mem = 26951680                                                            
using 809 buffers containing 3313664 bytes of memory 

33 161 216 = 0x1FA0000
26 951 680 = 0x19B4000
 3 313 664 = 0x0329000

cpuinit ramamt: 0x1F9FB60

32*104*1024 = 33554432

33554432 - 33161216 = 393216
393 216 = 0x60000

Ok, so soc_pc does:
	cpuInit(RAM_AMOUNT);
where:
soc.h: #define RAM_AMOUNT	(32<<20)

It looks like, soc_pc.c allocates memory for SII and FB outside of the
emulated memory:
static uint16_t mSiiBuffer[SII_BUFFER_SIZE / sizeof(uint16_t)];
static MassStorageF gDiskF;
static uint8_t gRam[RAM_AMOUNT];
static uint8_t gRom[256*1024];
static uint8_t gScsiBuf[512];

Thus, we are correct in reducing cpuInit memory by the private buffer
amounts.

So, we should separate SII and FB accesses from system RAM. 
(Note: probably don't need to allocate palette memory, since mono doesn't
really have much of a color choice...)

It looks like Ultrix probes up to the passed amount (modulo page size).

With:
ramAmt = 32*1024*1024;

ULTRIX V4.5 (Rev. 47) System #1: Sun Dec 12 13:36:11 CST 1999                   
real mem = 33554432                                                             
avail mem = 27303936                                                            
using 819 buffers containing 3354624 bytes of memory

33 554 432 = 0x02000000
 3 354 624

Assumption above verified. Wonder how ULTRIX determines the framebuffer
starting address - at a guess, it's always right after the passed memory
limit.
Guess is wrong - it's hardwared to 0x0fc00000:
	return memRegionAdd(0x0fc00000, 0x03400000, graphicsMemAccess);


So, now have to make the cpuAsm.S memory routine understand graphics accesses.
In soc_pc.c, all accesses are passed through memaccess(), which references
all of the allocated memory regions, and their access functions.

in cpuAsm.S:
	lsrs		\tmp2, \tmp, #28			//see if RAM
	bne			95f				//not ram

So, upper four bits are zero -> in RAM. This will alias grahpics to memory.


16-feb-2024:

Yesterday evening, added the following to cpuAsm.S memread/write routines: 

// test if in graphics RAM range
	movs                    \tmp2, #0xfc
	lsls                    \tmp2, \tmp2, #20
	subs                    \tmp2, \tmp, \tmp2
	bcc			94f      // jump if not graphics 	
	mov			\tmp, \tmp2
	b                       96f
	
// test if in allowed RAM range	
94:	ldr			\tmp2, [REG_CPU_P2, #0 + OFST_MEMLIMIT]
	cmp			\tmp, \tmp2
	bcs			93f
96:	ramWrite	\tmp, \srcReg, \strOp, \sizeOrder
	b	

This allowed ultrix.texmode to boot! Unfortunately, .gui failed - most likely, due
to the fb addresses not getting offset to where the fb actually is in PSRAM.

So, for the initial access:
mem report hit at 0FC36100 sz/wr: 00036100 3

This should be offset by mFbBase:
ram:         0x00000000 - 0x01F9EFFF
palette:     0x01F9FBC0 - 0x01F9FFFF
framebuffer: 0x01FA0000 - 0x01FDFFFF

mem report hit at 0FC36100 r1/r2/r3: 20026BA0 01FA0000 11BD6100
fb base addr/contents: 20026BA0 01FA0000

01FA0000
00036100
--------
01FD6100

updated memwr/rd:
// test if in graphics RAM range
	movs                    \tmp2, #0xfc
	lsls                    \tmp2, \tmp2, #20
	subs                    \tmp2, \tmp, \tmp2
	bcc			94f      // jump if not graphics 	
	ldr                     \tmp, =mFbBase
	ldr                     \tmp, [\tmp]
	adds		        \tmp, \tmp2
	b                       96f

Now it actually boots! All the way to the "digital" logo screen...

Reference debug code:
//RAM
	push		{r0-r3}
	// tmp is r3 (dst pa)
	// tmp2 is r0	
	// r1 is va
	
//	ldr			r1, [REG_CPU_P2, #0 + OFST_MEMLIMIT]
//	movs                    r1, #0
//	movs                    \tmp2, #0xfc
//	lsls                    \tmp2, \tmp2, #20
//	subs                    \tmp2, \tmp, \tmp2
//	movs			r2, #2
//	bcs			999f      // jump if graphics 
//	bcc			999f      // jump if not graphics 
//	movs                    r2, #1
	
//	mov                     r1, \tmp	
//	movs			r2, #2
	
//	movs                    \tmp2, #0xfc
//	lsls                    \tmp2, \tmp2, #20
//	subs                    \tmp2, \tmp, \tmp2
//	bcc			999f      // jump if not graphics 	
//	movs			r2, #3
	
//	ldr                     r1, =mFbBase
//	ldr			r1, [r1]
//	adds			\tmp2, r1
	
	movs                    \tmp2, #0xfc
	lsls                    \tmp2, \tmp2, #20
	subs                    \tmp2, \tmp, \tmp2
	bcc			999f      // jump if not graphics 
	ldr                     \tmp, =mFbBase
	ldr                     \tmp, [\tmp]
	adds		        \tmp, \tmp2
999:
	bl			memReport
	pop			{r0-r3}



Next steps:
1) Add a cursor. Requires compositing a cursor image onto the video stream.
2) Add keyboard/mouse support. Using USB host to talk to integrated mouse/kb controller.
3) Add networking.

Cursor considerations:
From: https://github.com/maximeborges/pico-rmii-ethernet
phy_tx.pio: 10 instructions
phy_rx.pio: 7 instructions

Currently using 5 instructions for video. Total is 22, leaving 10 for a video
compositor.
Can also use existing video DMA engines to help with layer management.
16 lines of video:
16 * 1024/8 = 2048 bytes.
Hyperram allows us to fetch 32 bits on 16 bit boundaries.

Compositor outline:
Allocate 16 scan lines in PSRAM for compositing buffer. Refresh process will
switch to this area when cursor Y is hit.

At blanking time, compositor is driven by DMA, which interleaves FB and cursor
data. 

Note: removed clock tick adjustment code found in loadUltrix.c by undefining:
//ultrix.45 stock is 256. 64 works well. 32 hangs due to various calculations over & underflowing
//#define ADJUST_HZ_REAL_TO						16
//#define ADJUST_HZ_REPORTED_TO					64

This makes the wall clock and Ultrix clock (roughly) match, at the cost
of clock interrupt overhead. Need to replace the first 8K of ultrix image
with new loader. TBD.

fb_mono.c display dma:
1) A dma command list is sent to a DMA engine.
2) command list consists of video PIO commands and PSRAM PIO commands

17-feb-2024:

With further thought, came up with this approach:
1) Add two dma channels: cursor read, cusor write.
2) Cursor read channel is hooked into the PSRAM DMA chain, right after
the PSRAM->scanline buffer transfer (before the scanline->video PIO xfer).
This will read two 32 bit words from the scanline buffer (cursor X position),
and write to a pre-allocated .bss 32 bit x 2 x 16 buffer.
3) Cursor write channel is chained to from cursor read channel, and chains
to the scanline->video PIO DMA channel. This channel transfers from another
pre-allocated .bss buffer to the scanline buffer at the cursor X position.
4) The PSRAM DMA chain is modified at the cursor Y position to chain to
the cursor read DMA channel. (Do this for all sixteen lines of the cursor).
Restore the chain when cursor is moved.
5) A routine is called at vsync time to composite the cursor into the
cursor write buffer, using cursor read data. Note that if the cursor position
changes, it is necessary to read the frame buffer to pick up the new data
for compositing. (Otherwise, the cursor will be composited with the old data
for one frame).
6) Hook into the cmd_buf end of screen routine to reload the cursor DMA channels.
Use ring buffer register to wrap the cursor read/write addresses.

19-feb-2024:

Having difficulty hooking into screen refresh properly. Need to hook
directly after PSRAM read data transfer to scan line buffer. Currently
doing this via chaining from ps start cmd to cursor rd/wr then to writing
timing event to video PIO. But, it appears that this delays the start of
the scanline too much. Need to chain directly from the ps read chan, but
this doesn't get written every scanline - only the ps cmd chan does.

Nope - above was correct - wasn't chaining properly to the cmd buffer
(was chaining to ps start - which caused two fetches of fb data, leading
to scan line skipping on screen).

Sigh. So, the refresh process does not touch the scanline write address
during display. This means that that scan line [0] does not always display
at the left edge of the display. Need to copy the refresh address
to the compositing address. Yet another dma channel! (or two...)

At this point, it makes more sense to have a cursor cmd/data dma setup.
Assuming it would be fast enough...

20-feb-2024:

Added two dma channels to copy the PSRAM to scan buffer write address
to cursor read read addr and cursor write write addr regs, respectively.
This works, if the cursor X is zero. Need to offset the scan buffer write
address by the proper amount to get the scan buf addr. Could do this by
doing a dummy DMA of the offset amount, and using the incremented address
as the source to cursor rd/write rd/wr regs. Yet another dma channel!
Really need to try out the cursor dma engine idea.
So:
Normal: dma_cmd chain to psram_start to kick off psram read to scan buf
Cursor: dma_cmd chain to cursor_start
DMA channels: cursor cmd, cursor data, cursor rd, cursor wr
cursor dma cmd chan is reading four words at a time,
and writing them to cursor data dma chan.

cursor chan setup block:
  write: dummy address 
  read: (written by step 0)
  count: number of words for cursor x offset
  control: chain to cursor cmd

Contents of cursor control blocks:
// Wait for end of blank trigger
0) read: psram read chan write address
   write: 
   count: 1
   control: Trigger cursor dma cmd chan to execute next command.
1) read: address containing psram read chan trigger
   write: multi_chan_trigger
   count: 1
   control: Trigger cursor dma cmd chan to execute next command.
2) write: cursor chan 0 dma read address
   read: address of cursor chan setup block
   count: 4
   control: chain to cursor chan 0, which will chain back to cursor cmd chan
// Setup cursor read/write scan line buffer address values
3) write: cursor chan setup block 1, read address
   read: cursor chan 0 read address
   count: 1
   control: chain to cursor cmd chan
4) write: cursor chan setup block 2, write address
   read: cursor chan 0 read address
   count: 1
   control: no chain
// Wait for end of psram read trigger
5) write: cursor chan 0 dma read address
   read: cursor read setup block
   count: 4
   control: chain to cursor chan 0, which will chain back to cursor cmd chan
6) write: cursor chan 0 dma read address
   read: cursor write setup block
   count: 4
   control: no chain


Note: if a count of zero doesn't work, can modify rd_no_inc DMA command
reg to not inc read address.

FYI: 
typedef struct {
     uint32_t ctrl;
 } dma_channel_config;


24-feb-2024:

Debugging cursor dma:
640 active pixels, or 20/0x14 32 bit words,
scan buf 20009e80
With line set to 9:
cursor noinc addr/value: 2000a7e4 20009ea0
With line set to 10:
cursor noinc addr/value: 2000a7e4 20009ef0
With line set to 11:
cursor noinc addr/value: 2000a7e4 20009ec0
With line set to 12:
cursor noinc addr/value: 2000a7e4 20009e90

count set to 0:
cursor inc addr/value: 2000a7dc 20009e90
cursor rd DMA chan: 7
raddr: 500001c0 20009e90
waddr: 500001c4 2000a758

set to 1:
cursor inc addr/value: 2000a75c 20009e10
cursor rd DMA chan: 7
raddr: 500001c0 20009e14
waddr: 500001c4 2000a6d8

set to 2:
cursor inc addr/value: 2000a7dc 20009e90
cursor rd DMA chan: 7
raddr: 500001c0 20009e98
waddr: 500001c4 2000a758

Debugging > 1 line cursor:
cursor cmd DMA chan: 5
raddr: 50000140 20041f10
waddr: 50000144 50000180
count: 50000148 00000000
ctl:   5000014c 001fad39 no chain

cursor cmd DMA chan: 5
raddr: 50000140 20041f00
waddr: 50000144 50000180
count: 50000148 00000000
ctl:   5000014c 001fad39 no chain

27-feb-2024:

Sigh. Spending a lot of cycles, trying to figure out how to do a counted
DMA sequence. If there was a way to issue DREQ to a channel by writing a
register, that would be very useful. Instead, will use the interpolators
to implement a counter, then use a masked/shifted value to trigger a DMA
to overwrite a DMA command loop reload value.

See section 2.3.1.6 for description of the Interpolator.

Can also use this for calculation of the framebuffer address - perhaps
in the same interpolator.

28-feb-2024:

Heartbreak: the interpolators are attached to the SIO, which is not
connected to the main system bus. This, unfortunately, means that
the DMA engine can not access this. And it was so promising!

Now what? Can we use the DMA sniffer? I think so:
1) Init accumulator with 0x1000 - count
2) DMA value of 1 with sniffer enabled channel
3) DMA byte 2 to multi-channel 2 reg (i.e. 0x0 until count reached, then 0x1)

So, implementing gives:

after sleep
test buf: 1d8 01 aa00aa0 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: 477 01 178260640 00 00 00 00 00 00 00 00 00 00 00 00 00 

bumping sleep time from 16 to 17:
after sleep
test buf: 1e0 01 aa00aa0 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: 480 01 178260640 00 00 00 00 00 00 00 00 00 00 00 00 00

with init accum, and byte move:
after sleep
test buf: deadbe00 01 aa00aa0 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: -559038976 01 178260640 00 00 00 00 00 00 00 00 00 00 00 00 00 
after sleep
test buf: deadbe01 01 aa00aa0 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: -559038975 01 178260640 00 00 00 00 00 00 00 00 00 00 00 00 00

So it might work. Trying with move to multi dma trigger reg, with
channel set to write 0xfeedface to test buf 0:
after sleep
test buf: deadbeef 01 feedface 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: -559038737 01 -17958194 00 00 00 00 00 00 00 00 00 00 00 00 00 
after sleep
test buf: feedface 01 feedface 00 00 00 00 00 00 00 00 00 00 00 00 00 
test buf: -17958194 01 -17958194 00 00 00 00 00 00 00 00 00 00 00 00 00 

Yes, it worked! Now to make a scan line dma loop. Success!

Another whacky idea: use a DMA channel in byte mode as an incrementor,
similarly to how we used the sniffer. This would then allow the sniffer
to be used as an address calculator for the scanline address...

Representatitve sample of the ps command buffer:
127 cmd0 cmd1 cmd2 00a0ff02 0000f007 1200003f
128 cmd0 cmd1 cmd2 00a0ff02 00000008 1200003f
129 cmd0 cmd1 cmd2 00a0ff02 00001008 1200003f
130 cmd0 cmd1 cmd2 00a0ff02 00002008 1200003f

Note that cmd1 (actually, all of them) is in big-endian order.
Fortunately, we can turn on the byte swap feature of the DMA engine
when copying the sniffer accumulator to the ps command buffer.

This would then free up the ps cmd buffer, at 1080 * 3 words, or 12960 bytes
12.65KB

Currently, with usb enabled in CMakeLists.txt:
/usr/lib/gcc/arm-none-eabi/10.3.1/../../../arm-none-eabi/bin/ld: uMIPS.elf section `.bss' will not fit in region `RAM'
/usr/lib/gcc/arm-none-eabi/10.3.1/../../../arm-none-eabi/bin/ld: region RAM overflowed
/usr/lib/gcc/arm-none-eabi/10.3.1/../../../arm-none-eabi/bin/ld: region `RAM' overflowed by 2892 bytes

Uh oh, when running uMips:

unning!!
SD mount OK!
Opened ultrix.gui
init getTime: 8792
ready, time is 0x0000000000002430
ready, time is 0x000000000000300F

*** PANIC ***

DMA channel %d is already claimed


Have to see who's not using dma_claim_unused channel...

Ok, this is weird: just lost all front panel USB ports.

29-feb-2024:

So I checked again this morning, and no USB front panel. Did an update and
reboot, and they showed up again. Sigh.

Also discovered that I'd left a bug in the new code, and had to hunt that
down and fix. (Used the wrong config when fetching the last scan line,
which was chanining to the now non-existant ps_start channel. I guess
the channel state was persistent over reboots, so it magically worked...)

So, still getting the already claimed error, though with a litte more
detail:

*** PANIC ***

DMA channel 0 is already claimed

I think I can switch to channel 8 (i.e. byte 2)...

Changes:
  test_dma_chan = 8;
  dma_channel_claim(test_dma_chan);

  // Trigger new jump address write, if at end of active 
  // Note: this will trigger channel 8!
  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(dma_hw->sniff_data)) + 2;
  cmd_buf[cmd_ptr].waddr = ((uint32_t)&(dma_hw->multi_channel_trigger)) + 1;
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload_byte;
  cmd_ptr++; //12

1-mar-2024:

Made using channel 0 or 8 a define. Tried booting ultrix, but it hangs
during image copy for SD. Perhaps we've pushed the DMA engine too much?
Linux also fails to boot.
Disabling fb to test...now boots. **Sigh**.

Reverting back to "noisy_cursor" worked, after commenting out the
cursor_en() call. This had the per-line hevents buffer.
In this version, cursor_en changes the chain to in the cmd buf to
point to the cursor dma channels. When enabled, this caused the
ultrix boot screen to display the same scanline repeatedly. Perhaps
this is a clue? Maybe the same bug Dmitry ran into? E.g.:
(https://dmitry.gr/?r=06.%20Thoughts&proj=09.ComplexPioMachines)
 It turns out that RP2040's DMA chaining, in some cases, may trigger the chained channel before the last write has completed. Seems the chain signal is fired when the last write is issued, not when it is completed. In most cases this would be perfectly fine, since almost certainly nobody depends on cycle-exact DMA chaining, and doing it this way makes the signal appear faster. In my case, when one channel reconfigures another, and then chains to it, it mattered, since sometimes the second channel would get triggered to start before the last configuration word had been written. 

So the question is: which piece of chaining causes the problem?

Let's try the easy stuff first:

Adding back in the pieces of h_events processing:
1) Vertical blank processing...


2-mar-2024:

After thinking about the problem some more, decided to revert back to
haning fb_mono.c. Replaced the active video lines with sending just
blanking (i.e. not calling the psram load/etc. dma channel), but
hang still observed. Also used the scrolling ISR feature to verify
that the screen was still refreshing when hang occured. Given this,
it looks like the DMA loop construct is the issue.

Probing the problem:
1) If we comment out incrementing the sniffer accumulator,
no hang, observed. Kernel errors observed
2) If we restore the sniffer increment, and redirect the sniffer acc write,
no hangs. Kernel errors.
3) If we restore the sniffer acc write, and redirect the test_chan write
to test_buf[0], hang before boot partition found.

All of the above should result with the same behavior, since we're not
updating the active loop jump value, so (3) would be the problem child.

fails:
  tmp_trigger = 1 << 16;
  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(tmp_trigger)) + 2;
  cmd_buf[cmd_ptr].waddr = ((uint32_t)&(dma_hw->multi_channel_trigger)) + 1;
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload_byte;

works:
  tmp_trigger = 1 << 8;
  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(tmp_trigger));
  cmd_buf[cmd_ptr].waddr = ((uint32_t)&(dma_hw->multi_channel_trigger));
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload;
  cmd_ptr++; //9

Fixed problem by:
  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(dma_hw->sniff_data)) + 2;
  cmd_buf[cmd_ptr].waddr = ((uint32_t)&(tmp_trigger)) + 1;
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload_byte;
  cmd_ptr++; //12

  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(tmp_trigger));
  cmd_buf[cmd_ptr].waddr = ((uint32_t)&(dma_hw->multi_channel_trigger));
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload;
  cmd_ptr++; //9

I think testing corrupted the linux.wheezy image...

Ultrix gui boots fine. Image size significantly trimmed down:
102668 bytes written at address 0x20000000
downloaded 102668 bytes in 0.790421s (126.846 KiB/s)

Now we can go back to adding a cursor overlay plane. Steps:
1) Move to using a dma channel as a counter, instead of the sniffer.
2) Use the sniffer to generate PSRAM addresses.
3) Write generated PSRAM addresses to a repeatable buffer.
4) Add scan line read/writes to repeatable buffer.
5) Add segmentation to video command buffer to enable calling normal
   or cursor PSRAM buffers per section.

Later that day:

xfer attempt in bad state
xfer attempt in bad state

Memory read of 32 bytes at physical addr 0x1FCFFFE0 fails


HALTED

This seems bad... Perhaps there are more subtle DMA problems?? Rebooting at
Sat Mar  2 01:44:09 PM PST 2024
The reboot triggered some disk file system salvage operations. This takes
approximately forever to finish.

Changed over to using a DMA channel for incrementing (vs. the sniffer reg),
and reordered increment operations to avoid immedate use after write DMA
commands.

Still fails:
 * SCSI reset
xfer attempt in bad state
xfer attempt in bad state

Memory read of 32 bytes at physical addr 0x1FCFFFE0 fails


HALTED

Doesn't look good. Not sure what other alternatives are available...

3-feb-2024:

So, perhaps the writes to multi-channel trigger are the issue. Perhaps
there's a way to trigger a channel via writing one of the registers.

Aliases are seperated as follows:
Trans count: 0x008
Alias 1:     0x01c (trigger)
Alias 2:     0x024
Alias 3:     0x038

DMA channels are seperated by 0x040
Chan 0 read addr: 0x000
Chan 1 read addr: 0x040


So, if we use byte 1:
chan 0 trans trigger: 0x5000 00 1c
chan x trans trigger: 0x5000 01 1c

x = 0x100/0x40 = 0x40 or 4. 

So, by re-writing a write address value, we can trigger either channel 0
or channel 4. Alternatives:

chan 1 trans trigger: 0x5000 00 5c
chan 5 trans trigger: 0x5000 01 5c

chan 2 trans trigger: 0x5000 00 9c
chan 6 trans trigger: 0x5000 01 9c

chan 3 trans trigger: 0x5000 00 dc
chan 7 trans trigger: 0x5000 01 dc

We can then alternatively trigger the increment DMA channel, or the
loop address write channel.


5-feb-2024:

Finally successful in getting alternative DMA video engine working. Here's
the interesting bits:

 // Generate increment value for reload of loop address: 1 or 2
  // Write to loop cmd packet counter value
  uint32_t inc_target_ptr = cmd_ptr;
  cmd_buf[cmd_ptr].raddr = ((uint32_t)&(dma_hw->ch[inc_chan].read_addr)) + 2;
  cmd_buf[cmd_ptr].waddr = 0xabadcafe; // Will be filled in below
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload_byte;
  cmd_ptr++;

  // Bump loop counter
  inc_count_val = 1;
  cmd_buf[cmd_ptr].raddr = (uint32_t)&inc_count_val;
  cmd_buf[cmd_ptr].waddr = (uint32_t)&(dma_hw->ch[inc_chan].al1_transfer_count_trig);  
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload;
  cmd_ptr++;

  // Now fill in the address for writing the increment target to
  cmd_buf[inc_target_ptr].waddr = (uint32_t)&cmd_buf[cmd_ptr].count;

  // Generate top of loop address, conditionally
  uint32_t loop_ptr = cmd_ptr;
  cmd_buf[cmd_ptr].raddr = (uint32_t)&loop_addr[0];
  cmd_buf[cmd_ptr].waddr = (uint32_t)&active_curr;
  cmd_buf[cmd_ptr].count = 1; // Will be overwritten by conditional step above
  cmd_buf[cmd_ptr].cnfg = cfg_reload_conditional;
  cmd_ptr++; 

  // Go to top of loop
  // Writing to the read address (alias 3) will restart the control DMA sequence
  cmd_buf[cmd_ptr].raddr = (uint32_t)&active_curr;
  cmd_buf[cmd_ptr].waddr = (uint32_t)&dma_hw->ch[cmd_chan].al3_read_addr_trig;
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload_last;
  cmd_ptr++; 

Rebooted Ultrix, now let's see if it triggers the same error message
seen on 2-mar...

Weird, can't login - just keeps going to the prompt. Re-writing image...
That seemed to help. Leaving running to see if it triggers the error message.

Uh oh, now getting this:
# ls
/etc/sec/: Permission denied.
# ps aux
/etc/sec/: Permission denied.

Have I triggered yet another subtle bug? Re-writing image, and rebooting
with graphics_init disabled...

Welcome to uMIPS
# ps aux
USER       PID %CPU %MEM   SZ  RSS TT STAT   TIME COMMAND
root       113 25.0  1.9  612  500 01 R      0:00 ps aux
root       109  7.3 23.5 8512 6172 ?  S      0:04 - bc -once :0 (Xws)
root       101  4.5  1.0  356  268 01 R      0:01 -csh (csh)
root       111  1.8  5.3 1712 1380 co S      0:02 /usr/bin/Xprompter -e :0

# ps aux
ldopen: cannot read magic number /vmunix
/vmunix: No namelist
# man man
Fixed up unaligned data access for pid 125 (csh) at pc 0x4017dc
#

Now this is strange...

Ok, so decided to add a clear_dma for the unused channels. This didn't help.
Only other hope is to try a different SD card...Still failed with 2-mar
error this time:


ULTRIX V4.5 (Rev. 47) (uMIPS)

login: AccessCSR: pa/size: 1E000000 0 read: 00000800
AccessCSR: pa/size: 1E000000 0 read: 00000A00
AccessCSR: pa/size: 1E000000 0 read: 00000800
 * SCSI reset
xfer attempt in bad state
xfer attempt in bad state

Memory read of 32 bytes at physical addr 0x1FCFFFE0 fails


HALTED

Note that we still have one write to the multi-channel register:

  // Trigger PSRAM fetch once done for next scanline
  // This overlaps video SM processing with PSRAM fetch
  ps_cmd_trigger = 1 << ps_cmd_chan;
  cmd_buf[cmd_ptr].raddr = (uint32_t)&(ps_cmd_trigger);
  cmd_buf[cmd_ptr].waddr = (uint32_t)&dma_hw->multi_channel_trigger;
  cmd_buf[cmd_ptr].count = 1;
  cmd_buf[cmd_ptr].cnfg = cfg_reload;
  cmd_ptr++; //11

We could change this to a alias 1 counter trigger...done, now rebooting...
Still fails:

AccessCSR: pa/size: 1E000000 0 read: 00000A00
 * SCSI reset
xfer attempt in bad state
xfer attempt in bad state

Memory read of 32 bytes at physical addr 0x1FCFFFE0 fails


HALTED

Added DMA clears to vid_mode = -1 call to fb_mono_init, just to be sure
that we're not doing something unexpected...

in mem.c:
#if 0
	if ((addr & ~0xff) == 0x0FC36100) {
	  pr("hit at %08x sz/wr: %d %d\n", 
	     addr, size, write);
	  //while (1) {}
	}
#endif

So no one is claiming physical addr 0x1FCF FFE0. How is this address
generated?? Trying cpu.c ... which generated a slightly different error:
AccessCSR: pa/size: 1E000000 0 read: 00000A00
unknown instruction 0xB5CF0001 @ 0x004EFED4 (45 1)
AccessCSR: pa/size: 1E000000 0 read: 00000800
 * SCSI reset
xfer attempt in bad state
xfer attempt in bad state

Memory read of 32 bytes at physical addr 0x1FCFFFE0 fails
iBUS error pa 0x1fcfffe0 at pc 0xbfcfffff ra 0x80085f24

6-mar-2024

So, decided to fire up the other board, using the same software, on both
the laptop VM, and the home system. Seems to work fine. The VGA system,
on the other hand, won't even boot on either. Need to swap SD cards, just
to be sure it's not a card problem.

Interesting - now, none of the boards fail. Maybe the video board needed
a power cycle?

Generating psram address:


 // PSRAM read command to read current line, at PSRAM offset 0
  psram_hline(inst, &ps_cmd_buf_reset, 0, 0);

  // Generate scan line address increment
  psram_hline(inst, &ps_cmd_buf_curr, 1, 0);

  uint32_t cmd1_be = ps_cmd_buf_curr.cmd1 - ps_cmd_buf_reset.cmd1;
  uint32_t addr_inc = (((cmd1_be >> 24) & 0xff) |
		       (((cmd1_be >> 16) & 0xff) << 8) |
		       (((cmd1_be >> 8) & 0xff) << 16) |
		       (((cmd1_be >> 0) & 0xff) << 24));

printf("&&&&& addr_inc: %08x\n", addr_inc);
  printf("line 1/0: %08x %08x\n", ps_cmd_buf_curr.cmd1, ps_cmd_buf_reset.cmd1);

&&&&& addr_inc: 00100000
line 1/0: 00001000 00000000

Splicing in the above worked.

Thinking about how to send the PSRAM command directly to the PIO SM.
Currently, the ps_cmd channel chains to the ps_read cmd channel so that
there's no delay from data available at the PIO to the transfer to the
scan line buffer. This needs two channels. Alternative: trigger the ps_read
channel ahead of sending the command directly to the PIO SM. The ps_read
will wait until data ready is asserted. Should work??

Problem - mismatch in timing between video timing and psram commands.
If we reset the PS read write channel before sending the ps cmd, it may
interfere with the previous psram output transfer...

7-mar-2024:

Left uMIPs running, still working when we returned. Rebooting with previous
SD card...Seems to work!

Can't seem to set frame buffer starting address of uMIPS:
Desired addr: 0x01FA0000
Problem is that we only increment upper 16 bits of address when generating
PSRAM address. Need to do 24 bits... Did this via byte reads of
cmd0/1 into a temporary, then swapping on the way to the sniffer acc.


Verifying memory perf:
Pass:    8 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
Full exe time: 12.317177
Short      WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Short exe time: 0.005613
Frame      WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Total execution time: 12.664592

Seems like there's a reversion from 6-nov-2023:
enabled: 12.0619
disabled: 9.9723
Overhead: (12.0619 - 9.9723)/9.9723 = 0.2095 or 21%.

New:
enabled: 11.98625
disabled: 9.864730
Overhead:(11.98625 - 9.864730)/9.864730 = .2150 or 21.5%

Trying without fb enabled:
ass:    1 WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
Full exe time: 9.594698
Short      WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Short exe time: 0.005608
Frame      WRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWRWR
Total execution time: 9.881220

13-mar-2024:

So, got double buffering with cursor compositing to work. Now to make
it scan line enabled. On insight: use byte moves in the cursor buffers
to make the 16 bit alignment easier. Limits maximum reads/writes to 3 bytes,
but to make things easier, we'll use 4.

In a 256 byte buffer, there are 64 32 bit words. We need 16 for a 16 high
cursor, so that's 4 per buffer. If we use a DMA channel as an incrementer,
then we'd need to have to reload it so that only the least significant bits
toggled... Oh! Here's a thought: make the transfer count 4x larger. Wastes
DMA cycles, though. And would only spread out the buffer addresses.

14-mar-2024:
Happy Pi Day! Will be prepping Pico boards for the next phase: getting
USB host support for mouse and keyboard input working.

Had a thought for making cursor support easier: make the scan buffer(s) 2048
pixels wide (i.e. 256 bytes). This will allow copying of the scan buffer
support's upper three bytes to the cursor read/write address, thus saving
the necessity of knowing which scan line the cursor is on.

As part of the prep for usb host, updated pico-sdk, following the
directions in "Getting started with Pico" pdf, viz:

$ git clone https://github.com/raspberrypi/pico-sdk.git --branch master
$ cd pico-sdk
$ git submodule update --init
$ cd ..
$ git clone https://github.com/raspberrypi/pico-examples.git --branch master

I'm thinking that using a seperate dma channel as a cursor Y counter is
the way to go. It'll be cleaner to control, and should remove odd/even
scan line dependencies.

17-mar-2024:

Finally got compositing cursor to work well. Only need to add in
addressing of the cursor buffers. But first, need to pack electronics
box for road trip.

18-mar-2024:

Added cursor buffer addressing, using cursor inc counter DMA channel, for
both read and write compositing buffers. Emulated DC503 Programmable Sprite
Cursor chip plane A and B cursor pattern buffers. Using the graphics.c
cursor functions as a template, implemented cursor/framebuffer compositing
semantics. Noticed that changing the cursor is "noisy", which is to be
expected, as the new position is using old position framebuffer contents
for compositing. Fixed by adding a read new FB contents when cursor
position changes. (Note: need to make this a function of Y and X positions).
Worked when low activity on FB port, but screen DMA process crashes with
high activity. At a guess, there's an issue when reloading FB contents while
in interrupt context. Couple of things to try: 1) Fetch new contents when
change_cur_position is called (which is not sync'd to vsync, unlike when
we're in the ISR, so new contents won't be as fresh). 2) Try switching
to a unused PSRAM port. Or both.

19-mar-2024:

Tried (1) above - no hangs observered. Will probably make this the solution
of choice, as spending a PSRAM port seems excessive. (Maybe as a final
optimization?)

Now on to getting USB host KB/mouse support to work.

Useful webpage:
https://forums.raspberrypi.com/viewtopic.php?t=346802

Compiling the $PICO_EXAMPLES_PATH/usb/host/host_cdc_msc_hid and running it
on the PSRAM board works. Delivers both keyboard (cooked) and mouse events.
Does not deliver control chars.

Found a really useful github repo: https://github.com/pkoning2/lk201emu.git
This is a USB keyboard to LK201 converter. Ideal for driving the emulator!
Now to port this to the pico SDK environment...

Also found: https://hackaday.io/project/19576-dec-mouse-adapter
Hopefully, will help with the mouse part of the emulation...

20-mar-2024:

Added hooks for using the fb_mono cursor, and was able to see the DecWindows
cursor when booting Ultrix! Slight problem with underlaying framebuffer
contents, so disabled the "on cursor movement, fetch fb" optimization for now.
May be a first position only issue... Actually, was a bug: forgot to update
the saved cursor postion after using new fb contents. Noticed a potential
y positioning bug during boot - seems like the Y position is a factor of
two off. Could be the 2x wide scanlines? We use scanlines, but the PSC
might be using something different... Bugfix worked.

22-mar-2024:

Integrating tinyUSB into simulator. Unfortunately, the main task: tuh_task
must run at application level, which precludes running it from a
repeating timer callback (which runs at interrupt level). Further,
cpuASM never returns from the cpuCycle call, so can't integrate a callback
in a main loop there (unless adding a call in cpuASM.S itself...)
Could spin up the second core to run the USB stack...

23-mar-2024:

Pushing tinyUSB to the second core seems to work. The tinyUSB demo code
and the simulator both output to the serial port.

Now to make USB mouse output look like decmouse events.

26-mar-2024:

Mouse cursor finally works. One of the issues may have been making the
sign negative for zero mouse movements. (Observed several system faults).
One big issue is that our mini kb/mouse apparently puts out a weird
report: sort of composite, but not really. In any case, offsetting past
the first byte seems to solve the issue:
      report_offset = report + 1;
      process_mouse_report( (hid_mouse_report_t const*) report_offset );

A few issues:
1) Can't position mouse at top of screen.
2) Can't position mouse to left of screen.
3) Mouse Y movement is opposite that of mouse pad. (E.g. moving up gestures
result in downward screen movement).

Looking at Dmitry's code:
	
	if (dx > DEC_MOUSE_MAX_MOVE)
		dx = DEC_MOUSE_MAX_MOVE;
	
	if (dy > DEC_MOUSE_MAX_MOVE)
		dy = DEC_MOUSE_MAX_MOVE;

where:
#define DEC_MOUSE_MAX_MOVE			0x7f

Also, graphics.c:

int32_t cr, cc,
sr = (int32_t)(uint32_t)mCursorY - CURSOR_Y_OFST,
sc = (int32_t)(uint32_t)mCursorX - CURSOR_X_OFST;

where:
#define CURSOR_X_OFST		(212)
#define CURSOR_Y_OFST		(34)

Adding the above to graphicsRP2040.c:
	  fb_mono_set_cursor_pos(mCursorX - CURSOR_X_OFST,
				 mCursorY - CURSOR_Y_OFST);

Seems to fix problems 1 & 2. While moving the mouse, however,
managed to blue screen. CMSIS window had a couple fo SWD error messages.

Addressed issue 3 by moving sign bit determination to < 0 portion:

if (report->y >= 0) {
    dec_report[2] = (report->y) & 0x7f;
  } else {
    dec_report[0] |= 0x08;
    dec_report[2] = (-report->y) & 0x7f;
  }

28-mar-2024:

Starting to add keyboard support. Host sends the following at startup:
kb: d3
kb: aa
kb: ca
kb: d2
kb: da
kb: e2
kb: ea
kb: 1b
kb: 84
kb: 8b
kb: 11
kb: 8f

Then at screen init:
kb: d3
kb: e9
kb: 8e
kb: 96
kb: 9e
kb: a6
kb: ae
kb: b6
kb: be
kb: c6
kb: ce
kb: d6
kb: de
kb: e6
kb: ee
kb: f6
kb: 99

Then after login prompt:
kb: 1b
kb: 84
kb: 23
kb: 84
kb: 11
kb: 8f
kb: 13
kb: 80

Shutdown 1:
kb: d3
kb: aa
kb: ca
kb: d2
kb: da
kb: e2
kb: ea
kb: 1b
kb: 84
kb: 8b
kb: 11
kb: 8f

Shutdown 2:
kb: d3
kb: e9
kb: 8e
kb: 96
kb: 9e
kb: a6
kb: ae
kb: b6
kb: be
kb: c6
kb: ce
kb: d6
kb: de
kb: e6
kb: ee
kb: f6
kb: 99
kb: 1b
kb: 84
kb: 23
kb: 84
kb: 11
kb: 8f
kb: 13
kb: 80
kb: d3
kb: aa
kb: ca
kb: d2
kb: da
kb: e2
kb: ea
kb: 1b
kb: 84
kb: 8b
kb: 11
kb: 8f

With keyboard transmissions: (kb rx):
kb: d3
kb: e9
kb: 8e
kb rx: ba
kb: 96
kb rx: ba
kb: 9e
kb rx: ba
kb: a6
kb rx: ba
kb: ae
kb rx: ba
kb: b6
kb rx: ba
kb: be
kb rx: ba
kb: c6
kb rx: ba
kb: ce
kb rx: ba
kb: d6
kb rx: ba
kb: de
kb rx: ba
kb: e6
kb rx: ba
kb: ee
kb rx: ba
kb: f6
kb rx: ba
kb: 99

After shutdown command:
                                                                          
kb: d3
kb: aa
kb rx: ba
kb: ca
kb rx: ba
kb: d2
kb rx: ba
kb: da
kb rx: ba
kb: e2
kb rx: ba
kb: ea
kb rx: ba
kb: 1b
kb: 84
kb: 8b
kb: 11
kb: 8f
AccessCSR: pa/size: 1E000000 0 read: 00000A00
# AccessCSR: pa/size: 1E000000 0 read: 00000800
kb: d3
kb: e9
kb: 8e
kb rx: ba
kb: 96
kb rx: ba
kb: 9e
kb rx: ba
kb: a6
kb rx: ba
kb: ae
kb rx: ba
kb: b6
kb rx: ba
kb: be
kb rx: ba
kb: c6
kb rx: ba
kb: ce
kb rx: ba
kb: d6
kb rx: ba
kb: de
kb rx: ba
kb: e6
kb rx: ba
kb: ee
kb rx: ba
kb: f6
kb rx: ba
kb: 99
kb: 1b
kb: 84
kb: 23
kb: 84
kb: 11
kb: 8f
kb: 13
kb: 80
kb: d3
kb: aa
kb rx: ba
kb: ca
kb rx: ba
kb: d2
kb rx: ba
kb: da
kb rx: ba
kb: e2
kb rx: ba
kb: ea
kb rx: ba
kb: 1b
kb: 84
kb: 8b
kb: 11
kb: 8f
AccessCSR: pa/size: 1E000000 0 read: 00000A00

29-mar-2024:

From src/class/hid/hid.h:

typedef struct TU_ATTR_PACKED
{
  uint8_t modifier;   /**< Keyboard modifier (KEYBOARD_MODIFIER_* masks). */
  uint8_t reserved;   /**< Reserved for OEM use, always set to 0. */
  uint8_t keycode[6]; /**< Key codes of the currently pressed keys. */
} hid_keyboard_report_t;

And milestone reached - successfully logged into DecWindows on the emulator!
Control characters work, delete key works, windows move reasonably well.

Now time to emulate lance! Using dev_le.c from gxemu.

30-mar-2024:

Trying to make uMips more responive, I lowered the inner loop sleep_ms from
100 to 50, and observed core dumps when moving the mouse rapidly. Reverting
back to 100 fixed this. Trying 75...works.

Found a goodish test program: /usr/games/worms. Running three copies: one
on console serial port, and two decterms. It possible to observe timeslicing
across the three windows...


31-mar-2024:

Revisiting pinouts, to see how to get more pins for SD card.

Rev 1.1 Final pinouts:
Ethernet:
Signal  Requirement    GPIO  Alternate function
TX0 	any GPIO 	0    UART0 TX/I2C0 SDA/SPI0 RX
TX1 	TX0 + 1 	1    UART0 RX/I2C0 SCL/SPI0 CSn
TX-EN 	TX0 + 2 	2    I2C1 SDA/SPI0 SCK

RX0 	any GPIO 	3    I2C1 SCL/SPI0 TX
RX1 	RX0 + 1 	4    UART1 TX/I2C0 SDA/SPI0 RX
CRS 	RX0 + 2 	5    UART1 RX/I2C0 SCL/SPI0 CSn

nINT / RETCLK 	        21 (Must be a RP2040 clock output, i.e. 21, 23, 24, 25)

MDIO 	any GPIO 	6    I2C1 SDA/SPI0 SCK
MDC 	MDIO + 1 	7    I2C1 SCL/SPI0 TX

SD Card:
Signal        
SDIO       SPI       Requirement   GPIO  Alternate function
1 SD_DAT2  (N/C)     SD_DAT1 + 1    14   
2 SD_DAT3  CS        SD_DAT2 + 1    15   SPI1 TX (Use as GPIO)
3 SD_CMD   RX (MOSI) any GPIO       11   SPI1 TX
4 3V3 
5 SD_CLK   SCK       any GPIO       10   SPI1 SCK 
6 GND
7 SD_DAT0  TX (MISO) any GPIO       12   SPI1 RX
8 SD_DAT1  (N/C)     SD_DAT0 + 1    13   

PSRAM:
Signal  Requirement    GPIO
DQ0     any GPIO       22
DQ1     DQ0 + 1        23
DQ2     DQ1 + 1        24
DQ3     DQ2 + 1        25
DQ4     DQ3 + 1        26
DQ5     DQ4 + 1        27
DQ6     DQ5 + 1        28
DQ7     DQ6 + 1        29
CK      any GPIO       18
CS#     any GPIO       19
RWDS    any GPIO       20
CK#     (pulled down to gnd via 10K resistor)
RESET#  (pulled up to +1v8 via 10K resistor)

UART:
Signal  Requirement     GPIO   Function
TX      RP2040 UART TX  16     UART0TX
RX      RP2040 UART RX  17     UART0RX

GPIO
Signal  Requirement     GPIO   Function
0       any GPIO        8      UART1 TX/I2C0 SDA
1       any GPIO        9      UART1 RX/I2C0 SCL

Currently using the following GPIOs for VGA: 
#define VGA_VSYNC_PIN 13 
#define VGA_HSYNC_PIN 14
#define VGA_GREEN_PIN 16

These are 3.3v buffered. Steals from SD card: SD_DAT1/2, and UART0 connection.

Reading the LAN8720A data sheet, it looks like it's possible to use the MDC
pin independently of the MDIO pin, as long as the MDIO pin is held hight.
The timing diagram shows that a start is detected by MDIO going low then high.
Also, there's no maximum time for MDC high or low periods. I'm thinking we
could drive MDC from HSYNC, and thus still be able to communicate with
the LAN8720A.

Could try this out by moving VGA to: GPIO 7, 8, 9.

Also need to improve the SDIO interface. The NVT4857UK is a promising
candidate, though it is a BGA device. $1.40/10s at Digikey.

3-apr-2024:

Rev 1.3 pinout:
Ethernet:
Signal  Requirement    GPIO  Alternate function
TX0 	any GPIO 	0    UART0 TX/I2C0 SDA/SPI0 RX
TX1 	TX0 + 1 	1    UART0 RX/I2C0 SCL/SPI0 CSn
TX-EN 	TX0 + 2 	2    I2C1 SDA/SPI0 SCK

RX0 	any GPIO 	3    I2C1 SCL/SPI0 TX
RX1 	RX0 + 1 	4    UART1 TX/I2C0 SDA/SPI0 RX
CRS 	RX0 + 2 	5    UART1 RX/I2C0 SCL/SPI0 CSn

nINT / RETCLK 	        21 (Must be a RP2040 clock output, i.e. 21, 23, 24, 25)

MDIO 	any GPIO 	6    I2C1 SDA/SPI0 SCK
MDC/HSYNC MDIO + 1 	7    I2C1 SCL/SPI0 TX

SD Card:
Signal        
SDIO       SPI       Requirement   GPIO  Alternate function
1 SD_DAT2  (N/C)     SD_DAT1 + 1    14   
2 SD_DAT3  CS        SD_DAT2 + 1    15   SPI1 TX (Use as GPIO)
3 SD_CMD   RX (MOSI) any GPIO       11   SPI1 TX
4 3V3 
5 SD_CLK   SCK       any GPIO       10   SPI1 SCK 
6 GND
7 SD_DAT0  TX (MISO) any GPIO       12   SPI1 RX
8 SD_DAT1  (N/C)     SD_DAT0 + 1    13   

PSRAM:
Signal  Requirement    GPIO
DQ0     any GPIO       22
DQ1     DQ0 + 1        23
DQ2     DQ1 + 1        24
DQ3     DQ2 + 1        25
DQ4     DQ3 + 1        26
DQ5     DQ4 + 1        27
DQ6     DQ5 + 1        28
DQ7     DQ6 + 1        29
CK      any GPIO       18
CS#     any GPIO       19
RWDS    any GPIO       20
CK#     (pulled down to gnd via 10K resistor)
RESET#  (pulled up to +1v8 via 10K resistor)

UART:
Signal  Requirement     GPIO   Function
TX      RP2040 UART TX  16     UART0TX
RX      RP2040 UART RX  17     UART0RX

VGA
Signal  Requirement     GPIO   Function
VSYNC   HSYNC+1         8      UART1 TX/I2C0 SDA
Video   any GPIO        9      UART1 RX/I2C0 SCL

Level translation requirements:
1) VGA:
3 pins: Video - 0.7v
2 pins: H/V Sync - 3.3v

2) SDIO
6 pins

3) UART/SWD
4 pins: 2 in, 2 out 3.3v levels

Current requirements:
1.0v into 75 ohms: I = 1.0v/75 = 0.01333, all three: 0.04 A or 40 mA.

The TLV751 can output 530 mA minimum, 720 mA typical.

So, 5 + 2 out, 2 in. 9 total.

7-apr-2024:

Looking at integrating ethernet onto board.
1) Magjack: PRT-08534 $2.10 
2) Majgack with usb A port: RJMG2330A1610ER $4.25 Q 10
3) USB A port: kUSBEXHT-ASFS1N   0.59 Q 10
4) LAN8742: 1.28 Q 25, 1.53 Q 1

3v3 @ 400/800 mA for SDcard

Houston, we have a problem: according to previous notes, we need:
PIO/SMs  function #inst
0/0, 1   SDIO     32

And also:
1/0, 1   RMII     17

We currently use:
1/0      video    5

So:
32 - 17 - 5 = 10 instructions, and one SM. This will be insteresting :-)
Can't really steal an SM from ethernet, since it is full duplex.

8-apr-2024

Looking at SDIO implementations:
https://uditagarwal.in/detailed-sdio-protocol-implementationpart-1/

10-apr-2024:

Voltage translator: TXV0106. 6 bits, unidirectional.
Good for:
1) HSYNC
2) VSYNC
3) 3 bits for RGB
4) UART TX

Still need:
bidirectional SWD data
SWD clock
UART RX

13-apr-2024:

Converting 3.3v to 0.7v across 75 ohms.

+----R1-----+
            |
	   75
	    |
	   GND

0.7v = I * 75,  I = 0.7/75 = 0.0093

(3.3 - 0.7) = 0.0093 * R1, R1 = (3.3 - 0.7)/ 0.0093 = 279.5698

Found 280 as R1 value on the Internet as answer to a question about VGA conv.

14-apr-2024:

J9 current position:
X: 72.055
Y: 78.825

Had to update board due to foot print library update.

72.055 + 2.54 = 74.595 (new x)

Ended up removing J9. Not needed for this rev. Submitted board to JLCPCB.
Hopefully, will be at Lynden before I get there!

16-apr-2024:

Got uMIPS to run from flash - though only by enabling
pico_set_binary_type(uMIPS copy_to_ram)

If default enabled, stops booting at:
[2]: '.data' 8015A620h->8015A620h+00029E00h@12A790h (R: 0@000000h L: 0@000000hh
  0x00029E00 / 0x00029E00 -> 100%

Will be interesting to debug...

Also tried to stop cursor twinkling during movement on decwindows. Locked
cursor fb underlay update via:
  // Can we update cursor?
  if (cursor_avail == 1) {
    cursor_avail = 0;
    fb_mono_cursor_x = (uint32_t)x_pos;
    fb_mono_cursor_y = (uint32_t)y_pos;
    // Get new FB contents, 16 bit aligned
    for (uint32_t i = 0; i < 16; i++) {
      new_fb_contents[i] = get_fb(x_pos, y_pos + i);
    }
  }

and setting cursor avail after compositing cursor. This didn't work.

Also noted crashes when moving cursor during testing. Maybe we've set the
cursor update rate too high? See 30-mar-2024 note.

Also tried logitech wireless kb. Didn't work, but workaround may be to
detect three reports generated, and skip the workaround for the mini kb.

Logitech report:
HID Interface Protocol = Keyboard
HID device address = 1, instance = 1 is mounted
HID Interface Protocol = Mouse
HID device address = 1, instance = 2 is mounted
HID Interface Protocol = None
HID has 3 reports 
A device with address 1 is mounted

Mini kb:
HID device address = 1, instance = 0 is mounted
HID Interface Protocol = Keyboard
HID Interface Protocol = Mouse
A device with address 1 is mounted

21-apr-2024:

Of course, while taking screen shots, the board is balky: scsi resets and
xfer attempts in bad state messages when moving windows. Slowing down the
usb hid report rate back to 100 ms...

Rough dma engine cmd buf size: 54 * 4 words = 216 words, 864 bytes.

22-apr-2024:

Decided to measure mem perf, and found:
Write MB/s: 42.531158
Total MB: 40.000000
Read MB/s: 32.221401
Total MB: 40.000000

I'd forgotten that the read perf is so much lower than write! I'm going to try
some experiments, since we've tweaked the PSRAM layout a bit on rev 1.2.
Changed read inner loop delays from 6 to 5 (4 immediately failed), now get:
Read MB/s: 36.185177
Leaving memory test to run...
(Oh, and there are no empty PIO instruction slots in hyperram.pio. That is
some tight code!)

Added report to frame buffer memory test:
write MB/s: 35.511806
Total MB: 40.000000
Read MB/s: 30.749172
Total MB: 40.000000

Interesting to see that writes are more impacted than reads, when video
is enabled.

Short memory test ran for 7412755 passes before being turned off. This is past
4362778, which is where the previous debugging effort last detected a problem.

25-apr-2024:

Enabled the logitec wireless keyboard. It enumerates as follows:
HID device address = 1, instance = 0 is mounted
HID Interface Protocol = Keyboard
HID device address = 1, instance = 1 is mounted
HID Interface Protocol = Mouse
HID device address = 1, instance = 2 is mounted
HID Interface Protocol = None
HID has 3 reports 
A device with address 1 is mounted

The minikeyboard enumerates:
HID device address = 1, instance = 0 is mounted
HID Interface Protocol = Keyboard
HID device address = 1, instance = 1 is mounted
HID Interface Protocol = Mouse
A device with address 1 is mounted

Note that there are no reports. Used this to differentiate between the two:
  if ( itf_protocol == HID_ITF_PROTOCOL_NONE )
  {
    hid_info[instance].report_count = tuh_hid_parse_report_descriptor(hid_info[instance].report_info, MAX_REPORT, desc_report, desc_len);
    init_report_count = hid_info[instance].report_count;
  }

and:
    case HID_ITF_PROTOCOL_MOUSE:
      //TU_LOG2("HID receive boot mouse report\r\n");
      // Fix minikeyboard report count
      if (init_report_count == 0) {
	report_offset = report + 1;
      }
      process_mouse_report( (hid_mouse_report_t const*) report_offset );
    break;

Noted that the logitec keyboard re-enumerates when plugged and unplugged,
while the minikeyboard does not.

28-apr-2024:

Worked on getting the cursor to behave better, but didn't make much
progress. Still has halo effect when moving. Pretty sure this is because
we touch compositing buffer contents during active... Also had a bunch
of disk failures when testing. Reverted fb_mono back, but still failed,
A power cycle (with the reverted version) finally worked. On thing to
note: the ethernet interface was plugged in. Reverted to hacked fb_mono,
unplugged eth i/f, rebooted and...success.

1-may-2024:

Experimenting with accessing FB during video sync IRQ resulted in hangs.
Turns out that adding a sleep_us over 7 us in the ISR will cause a hang during
fb_test. The video refresh process continues; it's processor access that
waits forever. Have to think about that one.

New boards arrived while we were away - still waiting on the Digikey order
with new level translators to arrive. Just looked at the website - estimated
arrival date is 6-may! Order placed on 26-apr, shipped on 27-apr, and I paid
for FedEx 3-day. So I'm actually getting 6 (business) day. Ha! Turns out I
was mistaken - I'd actually paid for FedEx ground, which is 7 day. I'll just
have to be patient. (Could start building up the rest of the board, though...)


Working on ISR problem:
static __force_inline uint32_t save_and_disable_interrupts(void) 	
    Save and disable interrupts.

Returns
    The prior interrupt enable status for restoration later via
    restore_interrupts() 

So, wrapped hyperram_{read|write}_blocking with above functions,
added fb_get (using psram channel 1) to ISR, tested with fb_test. Failed
to boot uMIPS - video hang. There must be some interaction between
the long PSRAM requests from SD card reads and video reads.

One thought: use the DMA engine to fetch the FB cursor contents. 16 reads
would be required. Could use the sniffer/dma loop functions to calculate
the address and fetch the data.

3-may-2024:

Built two boards - made up a new technique: took the old solder paste
from the first project (FM hat), mixed it with flux, dabbed onto board,
placed components, hot air gunned to solder. Even with the RP2040 (using
a very small amount of paste). Amazingly enough, booted the first time! Then
soldered the PSRAM, using the lay down solder on the foot print technique.
Did hot air the foot print to get the solder molten, then placed the PSRAM
and did a final application of hot air until the PSRAM floated. Also,
first time boot! (Flashed mem_test, via picotool, since we don't have the
level translators for SWD yet).

4-may-2024:

So, the Digikey package showed up last night! Soldered in the txs0104 and the
NVT4858 parts, but had the wrong footprint for the txv0106! Discovered yet
another error: wired the enable for thex txs0104 to ground, where it should
have been connected to 3.3v. 

6-may-2024:

So, attempted to use pico as debug probe. Had to first fix assembly error
on first board - SWD wasn't soldered on the level converter chip. Then
had intermittent SWD failures when running memory test. Re-purposed rev 1.2
into debugger, ran fine. Then swapped cable from 1.2 to pico, also ran
fine. The original setup had longer cables (about 2x) and the wires weren't in
ribbon format (though I did twist them). Also, with the original setup, I did
try lowering the interface clock speed to 2 MHz, which did help a bit.

Further experiments: Tried a similar cable length as original, but used
ribbon format. This worked fine. Also tried 10 MHz interface speed, failed
eventually. Added serial port wires, eventually failed when running mem_test
(which generates a lot of serial output). Added original connector wire,
wrapped loosely around debug port wires, but not connected to pico. This
should act as an antenna, but not as much as the ribbon cable. Testing
serial port coupling to debug port.

So failed after an hour with longer ribbon cable and pico. Shortened cable,
failed after a minute. Trying with longer ribbon cable and emu board as
debugger. This worked for > 1 hour. Trying with 10MHz interface speed...
works > 1 hr. Trying 20 MHz... got thi:

Info : High speed (adapter speed 20000) may be limited by adapter firmware

Still working. Also updated CMakelists.txt to change the serial port
definition to:
# Use J7 as serial port 
target_compile_definitions(mem_test PRIVATE
  PICO_DEFAULT_UART=0
  PICO_DEFAULT_UART_TX_PIN=16
  PICO_DEFAULT_UART_RX_PIN=17
)

Commented out the J6 definition...

Also changed the VGA port pin usage in fb_mono.h:
// VGA pins
#ifdef REV_1_2
#define VGA_VSYNC_PIN 13
#define VGA_HSYNC_PIN 14
#define VGA_GREEN_PIN 16
#else
// Rev 1.3 and above
#define VGA_HSYNC_PIN 7
#define VGA_VSYNC_PIN 8
#define VGA_GREEN_PIN 9
#endif

And in fb_mono.c:
#ifdef REV_1_2
  _inst.sync_base_pin = VGA_VSYNC_PIN;
  _inst.vsync_offset = 0;
  _inst.hsync_offset = VGA_HSYNC_PIN - VGA_VSYNC_PIN;
  _inst.vga_green_pin = VGA_GREEN_PIN;
#else
  _inst.sync_base_pin = VGA_HSYNC_PIN;
  _inst.vsync_offset = 1;
  _inst.hsync_offset = 0;
  _inst.vga_green_pin = VGA_GREEN_PIN;
#endif

Booting ultrix textmode:
real mem = 33157120
avail mem = 26947584

Made VGA header cable, ran fb_test, looks good (but blue :-).

Would really like to see if SD card SDIO mode works...

8-may-2024:

So, primary learning: the SD card can't be put into SDIO mode, if it's been
initialized in SPI mode. Or, the SD card library doesn't understand how
to initialize the card, if's been previously inited. The way to solve this is:
remove the card prior to changing from SPI to SDIO.

Given the above, discovered that rev 1.2 worked in SDIO mode all along.
Rev 1.3 doesn't appear to work reliably in SDIO mode.

Above was determined by downloading latest library:
git clone --recurse-submodules https://github.com/carlk3/no-OS-FatFS-SD-SDIO-SPI-RPi-Pico.git no-OS-FatFs

Compiled the command line example, and ran benchmark on rev 1.2:
> info

Manufacturer ID: 0x0
OEM ID: 42Product: ASTC
Revision: 2.0
Serial number: 0x5fa
Manufacturing date: 7/2020

SDHC/SDXC Card: hc_c_size: 59637
Sectors: 61069312
Capacity: 29819 MiB (31267 MB)
ERASE_BLK_EN: units of 512 bytes
SECTOR_SIZE (size of an erasable sector): 128 (65536 bytes)

SD card Allocation Unit (AU_SIZE) or "segment": 4194304 bytes (8192 sectors)
Drive "" is not mounted

> mount

> bench
Type is FAT32
Card size: 31.27 GB (GB = 1E9 bytes)
                                                                                
Manufacturer ID: 0x0                                                            
OEM ID: 42Product: ASTC                                                         
Revision: 2.0                                                                   
Serial number: 0x5fa                                                            
Manufacturing date: 7/2020                                                      
                                                                                
FILE_SIZE_MB = 5                                                                
BUF_SIZE = 65536                                                                
Starting write test, please wait.                                               
                                                                                
write speed and latency                                                         
speed,max,min,avg                                                               
KB/Sec,usec,usec,usec                                                           
6019.4,56585,7667,10844                                                         
5937.6,60856,7638,11003                                                         
                                                                                
Starting read test, please wait.                                                
                                                                                
read speed and latency                                                          
speed,max,min,avg                                                               
KB/Sec,usec,usec,usec                                                           
8566.8,8010,7595,7646                                                           
8580.8,8010,7595,7639                                                           
                                                                                
Done                                                                            
                                                                                
> 
Also tested:
> big_file_test bf 200 1

Writing...
Elapsed seconds 28.2
Transfer rate 7.10 MiB/s (7.45 MB/s), or 7275 KiB/s (7449 kB/s) (59596 kb/s)
Reading...
Elapsed seconds 24.3
Transfer rate 8.24 MiB/s (8.64 MB/s), or 8435 KiB/s (8637 kB/s) (69096 kb/s)

Above is with:
  .baud_rate = 125 * 1000 * 1000 / 6  // 20833333 Hz
in /command_line/config/hw_config.c
This seems to be the fastest available.

From the README:

    Writing
        Elapsed seconds 19.1
        Transfer rate 10.5 MiB/s (11.0 MB/s), or 10703 KiB/s (10960 kB/s) (87683 kb/s)
    Reading
        Elapsed seconds 16.3
        Transfer rate 12.3 MiB/s (12.9 MB/s), or 12550 KiB/s (12851 kB/s) (102807 kb/s)

So not as fast.
Card info:

Manufacturer ID: 0x0
OEM ID: 42Product: ASTC
Revision: 2.0
Serial number: 0x5fa
Manufacturing date: 7/2020

This is a generic card - no info on card itself. Using hdparm on linux:
/dev/sdb:
 Timing cached reads:   27682 MB in  2.00 seconds = 13858.94 MB/sec
 Timing buffered disk reads: 258 MB in  3.00 seconds =  85.87 MB/sec

A microcenter class 10 card:
/dev/sdb:
 Timing cached reads:   29986 MB in  2.00 seconds = 15013.57 MB/sec
 Timing buffered disk reads: 264 MB in  3.01 seconds =  87.75 MB/sec

And I can't get an info to work, after hot swap. Need to reload command_line.

bench gives:

write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
5565.7,29168,7003,10863
7142.9,27597,7003,8643

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
7075.4,9901,9186,9259
7065.9,10088,9185,9274

Lexar card:
/dev/sdb:
 Timing cached reads:   30382 MB in  2.00 seconds = 15212.96 MB/sec
 Timing buffered disk reads: 270 MB in  3.02 seconds =  89.40 MB/sec

with baudrate /6:
write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
9329.0,7626,6958,6995
9181.9,18597,6958,7131

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
9463.7,7326,6906,6928
9463.7,7327,6906,6927

with baudrate /5: 
write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
11084.3,6546,5854,5892
10877.3,15927,5854,6006

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
11226.7,6243,5801,5838
11107.8,11063,5800,5902

fails at baudrate /4.

Attempted to get rev 1.3 board to work with SDIO, but nothing was
successful. (E.g. increased PIO SM clock delays, lowered baud rate, etc.)
Was always getting checksum failures on read back, when running
command_line bench command. A future idea: get SD card to switch to 1.8v
levels to see if that fixes things...

Re-wired voltage translator board to allow usage with rev 1.2.
Now works with re-mapped GPIOS (incl. hsync shared with etherent MDCLK).

Tried changing baud rate, to better reflect our 300 MHz sysclk.
Got up to 30 MHz:
Lexar card:
write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
12603.1,14951,4926,5189
13206.2,5541,4927,4950

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
13273.1,5343,4907,4926
13306.8,5344,4907,4924

Microcenter:

write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
12278.4,7427,4970,5126
12307.2,14638,4970,5264

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
9133.9,7414,6986,7173
9133.9,7431,6987,7183

Generic:
write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
11997.4,7630,5185,5415
12108.3,7620,5184,5388

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
11942.8,5810,5452,5487
11942.8,5811,5452,5479

Sticking with Lexar card for now.

Now have to integrate latest library into uMIPs...Ok, done.

Failures right out of the gate:
inyUSB Host CDC MSC HID Example
SD mount OK!
Opened ultrix.gui
init getTime: 8752
ready, time is 0x000000000000277B
ready, time is 0x000000000000335A
ram: 32
ramtop: 31
ram:         0x00000000 - 0x01F9EFFF
palette:     0x01F9FBC0 - 0x01F9FFFF
framebuffer: 0x01FA0000 - 0x01FDFFFF
isCDROM: 0
Disk geometry: 2048 cyl of 128 heads of 16-sector tracks for 4194304 LBAs total
uMIPS v2.2.0 (BL ver 37)
 will run with 32MB
r: 0 pa: 00000000 sz: 01f9f000 33157120
r: 1 pa: 1fc00000 sz: 00000110 272
r: 2 pa: 17000000 sz: 01000000 16777216
r: 3 pa: 1e000000 sz: 01000000 16777216
r: 4 pa: 1c000000 sz: 01000000 16777216
r: 5 pa: 1a000000 sz: 02000000 33554432
r: 6 pa: 1d000000 sz: 01000000 16777216
r: 7 pa: 18000000 sz: 02000000 33554432
r: 8 pa: 00000000 sz: 00000000 0
hello, world
Boot partition found at 0 + 32768 sec
This might be UFS. 16384 blocks (16095 data), 1 cyl groups
 > '.'
 > '..'
 > 'lost+found'
 > 'bin'
 > 'etc'
 > 'tmp'
 > 'usr'
 > 'dev'
 > '.ue_profile'
 > 'mnt'
 > 'var'
 > 'sys'
 > 'vmunix'
7 sections, flags: 0x0007, entry at 0x80030000, GP 0x8018C410
[0]: '.text' 80030000h->80030000h+00127640h@000170h (R: 0@000000h L: 0@000000h)h
  0x00127640 / 0x00127640 -> 100%
flush_cache @ 0x801038EC
microdelay @ 0x8010361C
_mc146818write_todclk piece @ 0x800FEA78
[1]: '.rdata' 80157640h->80157640h+00002FE0h@1277B0h (R: 0@000000h L: 0@000000hh
  0x00002FE0 / 0x00002FE0 -> 100%
[2]: '.data' 8015A620h->8015A620h+00029E00h@12A790h (R: 0@000000h L: 0@000000h)h
  0x00029E00 / 0x00029E00 -> 100%
kn01 machine data @ 0x80167DE8
[3]: '.sdata' 80184420h->80184420h+000030F0h@154590h (R: 0@000000h L: 0@157680hh
  0x000030F0 / 0x000030F0 -> 100%
[4]: '.sbss' 80187510h->80187510h+00000AF0h@000000h (R: 0@000000h L: 0@157680h)h
  zeroing...
  0x00000AF0 / 0x00000AF0 -> 100%
[5]: '.bss' 80188000h->80188000h+00063870h@000000h (R: 0@000000h L: 0@000000h) h
  zeroing...
  0x00063870 / 0x00063870 -> 100%
[6]: '.comment' 00000000h->00000000h+00000024h@1576E0h (R: 0@000000h L: 0@00000h

Memory write of 2 bytes at physical addr 0x11000000 fails

Exception condition
        Cause reg       = 0x1c
        Exception PC    = 0x80156a60
        Status reg      = 0x0
        Bad virt addr   = 0xb1000000


cpu 0 panic: bus timeout
routine: 0x800a11d4 called from: 0x800fd784
routine: 0x800fd490 called from: 0x8010d848
routine: 0x8010d1b0 called from: 0x800ffc88

TRACE ABORTED: Trace confused



locks held by cpu 0 


print locks held by non-active processes
done

Exception condition
        Cause reg       = 0x8
        Exception PC    = 0x800a1478
        Status reg      = 0x14
        Bad virt addr   = 0x8c

Exception condition
        Cause reg       = 0x8
        Exception PC    = 0x8012e964
        Status reg      = 0x4
        Bad virt addr   = 0x0


HALTED

First, lets make sure we have a good copy of ultrix.gui...done. Rebooting...
same error. Tried switching to SPI mode, also failed. Tried on rev 1.3, failed.
This will be tomorrow's fix...

Well, went back to this after dinner - turns out, I'd forgotten that I'd
turned off graphicsInit in main_uc. Once it was enabled, the board booted.
Now to try SDIO mode...failed, with:

*** PANIC ***

No program space

Program size with graphics enabled:

Memory region         Used Size  Region Size  %age Used
             RAM:      220776 B       256 KB     84.22%
       SCRATCH_X:          2 KB         4 KB     50.00%
       SCRATCH_Y:          0 GB         4 KB      0.00%

With graphicsInit() commented out:

             RAM:      210100 B       256 KB     80.15%
       SCRATCH_X:          2 KB         4 KB     50.00%
       SCRATCH_Y:          0 GB         4 KB      0.00%

So it seems like there's a run time issue.

We can boot ultrix.textmode, with SDIO enabled.
Some times:
~17 seconds from login to prompt.
~55 seconds man man
# time man man > /dev/null
0.2u 0.0s 0:07 4% 17+27k 0+0io 0pf+0w
~87 seconds to shutdown

With SPI enabled:
start errlog daemon - elcsd
Mon Dec 13 00:56:36 CST 1999
~28 seconds from login to prompt
~58 second for:
# time man man > /dev/null
0.2u 0.2s 0:05 9% 16+19k 18+1io 0pf+0w
# time man man > /dev/null
0.2u 0.0s 0:05 5% 16+26k 0+0io 0pf+0w
~97 seconds to shutdown

9-may-2024:

Addressing memory shortage by switching to flash. Compiled with
no graphics, SPI mode:
Memory region         Used Size  Region Size  %age Used
           FLASH:      126924 B         2 MB      6.05%
             RAM:       84736 B       256 KB     32.32%
       SCRATCH_X:          2 KB         4 KB     50.00%
       SCRATCH_Y:          0 GB         4 KB      0.00%

start errlog daemon - elcsd
Mon Dec 13 00:57:48 CST 1999
~26 seconds from login to prompt
# time man man > /dev/null
0.2u 0.3s 0:06 8% 16+19k 18+1io 0pf+0w
# time man man > /dev/null
0.2u 0.0s 0:06 4% 18+26k 0+0io 0pf+0w
# 

Seems about the same. Now with no graphics, SDIO:
Memory region         Used Size  Region Size  %age Used
           FLASH:      133692 B         2 MB      6.37%
             RAM:       91504 B       256 KB     34.91%
       SCRATCH_X:          2 KB         4 KB     50.00%
       SCRATCH_Y:          0 GB         4 KB      0.00%

Had to pull uSDcard and do a couple of resets before it booted.

While waiting for the disk re-build, found that there are now
512Mb Hyperrams for $4.53900/Q10. They're the 200 MHz version, but
may be worth getting for the next build. Vs.: $4.48400 for 32MB 200 MHz.

start errlog daemon - elcsd
Mon Dec 13 00:52:00 CST 1999
~26 seconds from login to prompt
# time man man > /dev/null
0.2u 0.2s 0:08 6% 17+19k 18+1io 0pf+0w
# time man man > /dev/null
0.2u 0.0s 0:06 4% 16+25k 0+1io 0pf+0w
# 

Switching to graphics mode and SDIO:
Memory region         Used Size  Region Size  %age Used
           FLASH:      140528 B         2 MB      6.70%
             RAM:       95876 B       256 KB     36.57%
       SCRATCH_X:          2 KB         4 KB     50.00%
       SCRATCH_Y:          0 GB         4 KB      0.00%

And we paniced - no program space error again. So this must be
some heap/stack size issue. Increased both, still not booting.
I wonder if there's a PIO allocation issue? Almost - it's a PIO program
space issue. Added:
  if (pio_can_add_program(inst->pio, &fb_video_program)) {
    // Install PIO program
    inst->prog_offset_video = pio_add_program(inst->pio, &fb_video_program);
  } else {
    printf("Unable to load video PIO program\n");
    return;
  }
and, sure enough, got:
Unable to load video PIO program
Looking at rp2040_sdio.pio.h:
static const struct pio_program sdio_cmd_clk_program = {
    .instructions = sdio_cmd_clk_program_instructions,
    .length = 18,
    .origin = -1,
};
static const struct pio_program sdio_data_rx_program = {
    .instructions = sdio_data_rx_program_instructions,
    .length = 5,
    .origin = -1,
};
static const struct pio_program sdio_data_tx_program = {
    .instructions = sdio_data_tx_program_instructions,
    .length = 9,
    .origin = -1,
};

For a total of: 32 instructions. Sigh. Can't use SDIO until we put it on a
diet!

Might as well go back to rev 1.3 - video quality is better. On to getting
ethernet to work...

So hackaday has a business card challenge. Accepted!

Search for PCB-USB-C github kicad to get PCB foot print for usb-c connector.

11-may-2024:

Yesterday was rev 1.4 build day. Resulted in two working systems, one with
a rev 1.1 board modded to add a 3.3v SWD port (in addition to the 3.3v UART),
and one with a rev 1.2 as debugger. One board passes mem_test with 5 cycle
read loop delays, the other needs six:

public r_data:
     in PINS, 8           side 0b0 [6]    ; CA phase 0 
     in PINS, 8           side 0b0        ; CA phase 1
     jmp X--, r_data      side 0b1 [6]    ; Continue until all data captured 
     jmp done             side 0b0

Same layout, different silicon I guess. May try reflowing the processor/PSRAM
to see if that helps...

Also observed SDIO command_line bench command passing a couple of times, but
not consistenly. Tried to boot uMIPS, but failed. Today, we have to address
that problem. But, at least we saw SDIO working with the NXP interface chip,
which gives hope that there's a possible solution.

Sigh. For some reason rev 1.4 is not able to do SD SPI mode, only SDIO mode.
Weird. Both boards, multiple power cycles. Rev 1.2 works fine in either mode.
The NXP chip must be behaving strangely today.

So, using SPI mode on rev 1.2, command_line bench gives:
FILE_SIZE_MB = 5
BUF_SIZE = 65536
Starting write test, please wait.

write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
2411.6,27949,27101,27145
2401.7,38912,27101,27279

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
2360.6,32853,27558,27761
2375.6,28180,27557,27587

Done

With baud rate set to 30MHz.

Ok, now got rev 1.2 to fail SPI mode. Was changing baud rates, rebooted
in the middle of a test, now doesn't work. Powering down for a while.

12-may-2024:

So, after more experimentation, discovered that setting the pad threshold
affects SD SPI mounting. Still getting hard errors with NXP sd card interface:

> info

Manufacturer ID: 0xad
OEM ID: LSProduct: LX32G
Revision: 1.0
Serial number: 0x41b4bba6
Manufacturing date: 3/2022

SDHC/SDXC Card: hc_c_size: 60499
Sectors: 61952000
Capacity: 30250 MiB (31719 MB)
ERASE_BLK_EN: units of 512 bytes
SECTOR_SIZE (size of an erasable sector): 128 (65536 bytes)
Drive "" is not mounted

> mount

> bench
Type is FAT32
Card size: 31.72 GB (GB = 1E9 bytes)

Manufacturer ID: 0xad
OEM ID: LSProduct: LX32G
Revision: 1.0
Serial number: 0x41b4bba6
Manufacturing date: 3/2022

bench_open_close:184: f_expand error: A hard error occurred in the low level dis
k I/O layer (1)

> 

Above without enabling 1.8 v threshold via pad select. Enabled gives:

> Set sysclk to 300 MHz
before set: pad bank0 voltage select data: 00000000
after  set: pad bank0 voltage select data: 00000001

> info
SD card initialization failed

Decided to try changing:
.no_miso_gpio_pull_up = true
to
.no_miso_gpio_pull_up = false

Now passes command_line bench, even with 1.8 v threshold enabled. Sigh.
Boosted the baud rate to 37.5 MHz:
write speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
2412.7,27943,27101,27143
2402.8,36936,27101,27256

Starting read test, please wait.

read speed and latency
speed,max,min,avg
KB/Sec,usec,usec,usec
2369.1,33659,27543,27664
2375.6,28173,27543,27587

No increase in KB/sec when trying faster baud rates.

Now finally able to boot uMIPS on rev 1.4! Video does look much better
than with the hacked rev 1.2 board. Need to make a nice ribbon cable
video cable, with grounds next to the video channels.

With video running:
# time man man > /dev/null
0.2u 0.0s 0:02 12% 17+27k 0+0io 0pf+0w

This is much faster than previous. Apparently, the new library and tuning
baud rate made a difference.

Ribbon cable still had noisy vertical stripe 3/4 of the way across the screen.
Tried new Eyoyo screen - no stripe, and really crisp video. It's only 1024x600,
but the scaler does a good job. Tring offical DECwindows res...failed. Screen
doesn't sync to 1024x864. But does look good at 1024x768@60 Hz, so trying
uMIPs with that...works fine.

Onto eth debugging:
Etherent MAC address:
b8:27:eb:ee:ee:ee

Note, from rp2_common/pico_unique_id/include/pico/unique_id.h:
On PICO_NO_FLASH builds the unique identifier is set to all 0xEE.

CRS_DV/MODE2 - Pullup.

Diagnostic info:
phy addr: 00000001
status reg 0: 00001100 - no loop back, 100 Mb, auto neg enabled, normal power
                         normal op, don't restart auto neg, duplex mode enab
			 

status reg 1: 00007829
2 - auto neg complete
9 - link is down.

status reg 1: 00007809
0 - auto neg not complete
9 - link is down.

So, restarted the auto neg sequence:
status reg  0: 00001100
status reg  1: 00007829
status reg  5: 0000c5e1
status reg 31: 00001058
count: 2
neg count: 12238
status reg  0: 00001100
status reg  1: 0000782d
status reg  5: 0000c5e1
status reg 31: 00001058

And the negociation counter is as expected:

If the management entity re-starts auto-negotiation by setting the
Restart Auto-Negotiate bit of the Basic Control Register, the
LAN8720A/LAN8720Ai will respond by stopping all transmission/receiving
operations. Once the break_link_-timer is completed in the Auto-negotiation
state-machine (approximately 1200ms), auto-negotiation will re-start. In this
case, the link partner will have also dropped the link due to lack of a
received signal, so it too will resume auto-negotiation.

(Except that the 1200 ms is actually 12000 us).

Status reg 1 immediately after the negociation has completed, shows that
we have link up status (bit 2), and extended capabilities (bit 0).

13-may-2024:

So I think the problem with the ethernet code is that it does:

    // Wait for data to transmit
    set pins, 0b00      side 0
    pull block          side 0
    wait 1 pin 0        side 0

Which assumes that when the retclk goes high, phase will be maintained
across the rest of the transmit code. The real question is: if the
clock is high when the code starts, when is the next high time? I.e.
if we sample in the middle, then we'll output in the middle for the
remainder of the transmission. We really need to sync to the rising
edge, or generate the clock ourselves...Let's try the latter:

outpins: tx1, 0
set pins: txen, tx1, tx0
side set pins: clk

set input fifo to auto pull

xmit:  set x, 30         side 0  // Setup for loop
       nop               side 1

pWait: set pins, 0b101   side 0  // Transmit 0b01 for 31 2 bit times
       jmp x--, pWait    side 1

ready: set pins, 0b111   side 0  // Write 0b11 for 1 cycle (2 bits)
       nop               side 1

loop:  out pins, 2       side 0  // Write data
       jmp !osre, loop   side 1

.wrap_target
start:
	set pins, 0b000  side 0  // tx not valid
	jmp !osre, xmit  side 1  // start transmission process


Also pg. 92 in the RP2040 data sheet:
The DMA performs standard byte lane replication on narrow writes, so
byte data is available in all 4 bytes of the databus, and halfword data
in both halfwords.

We assume that the set pins that aren't overwritten by the out pins
will persist. (See setting tx enable at ready:).

Ethernet frame format, lsb first:
7 bytes preamble: 0x55
1 byte sfd: 0xd5
<etc>

Ok, so crs_dv is true whenever there are valid bits on the RX0,1 pins.
This means we're getting preamble data, followed by actual ethernet
frame data. We can filter these out!

Setting up for wireshark:
usb mac addr: 
00:24:9b:0e:4d:f2

Ethernet interface:
enx00249b0e4df2

And wireshark shows that we are transmitting correctly:

Frame 67: 350 bytes on wire (2800 bits), 350 bytes captured (2800 bits) on interface enx00249b0e4df2, id 0
Ethernet II, Src: Raspberr_ff:ee:ee (b8:27:eb:ff:ee:ee), Dst: Broadcast (ff:ff:ff:ff:ff:ff)
    Destination: Broadcast (ff:ff:ff:ff:ff:ff)
    Source: Raspberr_ff:ee:ee (b8:27:eb:ff:ee:ee)
    Type: IPv4 (0x0800)
Internet Protocol Version 4, Src: 0.0.0.0, Dst: 255.255.255.255
    0100 .... = Version: 4
    .... 0101 = Header Length: 20 bytes (5)
    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
    Total Length: 336
    Identification: 0x0009 (9)
    Flags: 0x00
    ...0 0000 0000 0000 = Fragment Offset: 0
    Time to Live: 255
    Protocol: UDP (17)
    Header Checksum: 0xba94 [validation disabled]
    [Header checksum status: Unverified]
    Source Address: 0.0.0.0
    Destination Address: 255.255.255.255
User Datagram Protocol, Src Port: 68, Dst Port: 67
Dynamic Host Configuration Protocol (Discover)

The src value matches:
hw addr: b8 27 eb ff ee ee

Sending raw packets:
pip install scapy

sendp(Ether(dst="ff:ff:ff:ff:ff:ff")/IP(.250.0.129"))

sendp(Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=ARP.who_has, psrc="10.250.0.145", pdst="10.250.0.129"))

sendp(Ether(dst="b8:27:eb:ff:ee:ee"), iface="enx00249b0e4df2"))

sendp(Ether()/IP(dst="1.2.3.4",ttl=(1,4)), iface="enx00249b0e4df2"))

Didn't seem to work, or at least wireshark didn't show any packets sent.

Trying loopback mode:
Near-end loopback mode sends the digital transmit data back out the receive data signals for testing purposes, as indi-
cated by the blue arrows in Figure 3-9. The near-end loopback mode is enabled by setting the Loopback bit of the Basic
Control Register to “1”. A large percentage of the digital circuitry is operational in near-end loopback mode because data
is routed through the PCS and PMA layers into the PMD sublayer before it is looped back. The transmitters are powered
down regardless of the state of TXEN.

That didn't work either. Made a gigabit ethernet loopback connector:
1->3
2->6
4->7
5->8

where pin one is on the left, with the tab down, cable facing towards you:
 1       8
+---------+
| opening |
+--+   +--+
   +---+


Fastest minimum packet rate:

Preamble =  8 bytes
Payload  = 64 bytes
IPG      = 12 bytes

72+12 = 84 bytes
1 byte = 8 * 10ns = 80ns

84 * 80ns = 6720ns or 0.1488 MHz or 148.8 K packets/sec

Measured: 130.2 with IPG loops set to 31. IPG: 1.320 us or 132 bits.
No crs_dv assertion with IPG loops set to 8. IPG: 600 ns or 60 bits
Should be 960 ns. With IPG loops set to 23/22, get 960 and good crs_dv.

Still getting 135.9 pkt/sec rate. 
6.36 us or 636 bits. 79.5 bytes. Should be 72 bytes. Found problem:
was mistakenly sending preamble in addition to payload. Removing
brought packet rate to expected 148.8 K packets/sec, with good
crs_dv. Hurray!

DHCP packet is 29.0 us, or 29000/80 = 362.5 bytes

14-may-2024:

Found out that the lan8720a board is strapped to 10base-t half duplex, no auto.
I guess this would be the safest config. There is a comment stating
this, but I didn't think it was relevant...

15-may-2024:

So yesterday was "interesting". Observed crs_dv going valid after a packet
was transmitted, which shouldn't happen. Did a bunch of experiments,
including what was probably one of the most trying mods ever: using
the spare buffer on the txs0106 chip to drive the 50 MHz eth clock.
Even went back to the original modded LTM board (and fixed a miswired
clock!). Nothing worked, went to bed perplexed and disappointed.

This morning, went back to the modded LTM board with a freshly modified
LAN board (moving the resistors to enable external clock), fired up
the original pico-rmii sw, and it worked! Then rotated in the old modded
LAN boards (with the I/O VCC pin brought out to the NC pin), and those
worked as well. Didn't observe the crs_dv asserting issue on any
of the boards. Then loaded original pico-rmii code on rev 1.4 (with clock
mod), and it worked as well. Now trying un-modded rev 1.4...works as well.

Ok, now to figure out what went wrong with my mods. First, need to
make sure that we can use 300 MHz system clock...OMG!! So, enabling/disabling
UART via:
pico_enable_stdio_uart(pico_rmii_ethernet_httpd 0)
causes the crs_dv random assertion issue! Toggled several times,
same issue observed. Interestingly, if usb is disabled, and uart enabled,
issue not observed. Walked through all combos, only both enabled
has issue. At first. Now can't repro. Hope it doesn't come back again!

Ok, successfully changed over to using sys_clk @ 300 MHz.

crs_dv issue surfaced momentarily. Switch over to clock modded 1.4 board.

Reading the LAN8720A datasheet more closely: pin 1 (clk_in) is an ICLK
buffer type. This is a non-variable I/O buffer, with low max of 0.35
and high min of 0.9. So should work at 1.8v: RP2040 datasheet has
Voh @ 1.8v of 1.24v. But could work at 3.3v, even with Vio of 1.8v,
as high max is 3.6v.

Modded board showed crs_dv on first sram boot, then disappeared on second
sram boot.

Measured ping response time on scope: 144 us. In good agreement with
RTT of ping:

ping 192.168.1.6 -c 1
PING 192.168.1.6 (192.168.1.6) 56(84) bytes of data.
64 bytes from 192.168.1.6: icmp_seq=1 ttl=255 time=0.276 ms

--- 192.168.1.6 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.276/0.276/0.276/0.000 ms

Ok, another clue: changing to yesterday's code, the bad crs_dv was
observed. Reverting back fixes this. My guess is that clock quality
is the major factor. Either we bring up the clock too late, or
clock generation itself is lacking.

19-may-2024:

Updating board for business card format.

Lower Y: 121 mm
Upper Y: 70 mm
Delta: 51
Need: 39 to reach 90 MM
So 70 - 39 = 31

20-may-2024:

Thinking about 3.3v supply for bc: SDcard takes around 80 - 100mA, according
to web search, when operating in UHD mode. Ethernet takes 92mA for 100Tx.
SDcard power:
https://goughlui.com/2021/02/27/experiment-microsd-card-power-consumption-spi-performance/#google_vignette

Measured current draw using fb_memtest: ~100 mA. So total with above is
300 mA. According to the tlv751 application board guide:

The regulator is capable of delivering up to 500 mA to the load for each
input channel with low VIN to VOUT dropout voltage.

So we should be ok.

Eth connector: ARJM11D7-009-AB-EW2 $2.935 Q 10. So expensive!

25-may-2024:

Strapping for LAN8742a:
REFOFF: gnd, to enable internal 1.2v reglator.
nINTSEL: Vcc, to enable external reference clock.

31-may-2024:
Need to figure out ferrite bead for LAN8742a power supply filtering.

1-jun-2024:

In thinking about deadline for BCC, decided to revert to simple card with
no ethernet/connectors. Note that we need a new flash part; decided on
GD25LQ64EWIGR as it's the same as we've used prior, just in WSON package.

(Note: must double check footprint!)

2-jun-2024:

Aligning connectors:
hole x: 108.29

new x, left most: 108.29 - (2 * 2.54) = 103.21
new x, next: 108.29 - (7*2.54) = 90.51
new x, next: 108.29 - (11*2.54) = 80.35


Hole y: 117.18
New y: 117.18 - (2*2.54) = 112.10


3-jun-2024:

Finished minimal BC layout. Now extending to BC format. Need to grow
39 mm, as derived above.


Holes:
Old:
H1:
X: 73.19
Y: 74

H2:
X: 117.29
Y: 74

New:
H1:
X: 73.19
Y: 74-39 = 35

H2:
X: 117.29
Y: 74-39 = 35

Edge:
X: 72.39/118.39
Y: 70/70

new Y: 70 - 39 = 31

Aligning Vbus:
H3:
X: 117.29
Y: 117.18

Vbus Y:
117.18 - (15*2.54) = 79.08


9-jun-2024:

Working on integrated board.
Aligning boot sel jumper, right side.

Y: 117.18 - (14*2.54) = 81.62

5v jumper:
83.545

X:
73.19 + (4 * 2.54) = 83.35

10-jun-2024:

Finished board layout last night, but JLCPCB has a two day shutdown...

Next, finish video DMA code for copying cursor data to memory.

First, remove cursor pixel read per scan line routine, since we'll
replace it with a read per frame routine.

12-jun-2024:

So, submitted order to JLCPCB, then tried to make order for Digikey.
Unfortunately, Digikey is out of every variation of the ethernet connector
until August. Sigh. Chose a new connector, revising board. Also changed
crystal to 20 pf vs. existing 10 pf. This is now rev 2.1.

New eth connector doesn't have a silkscreen outline. Making one:
Y: 21.72
X: 15.75

Lower Y is 13.94 from shield hole. (10.89 + 3.05)
Lower Y is 10.89 from center of mounting hole, which is where the footprint
is centered.
So:
Lower Y: -10.89
Upper Y: 21.72 - 10.89 = 10.83
Left X: 15.75/2 = -7.8750
Right X: 7.8750

Height: 13.35/2 = 6.6750

13-jun-2024:

Released rev 2.1 today, and placed Digikey order. Hopefully, everything will
arrive before we get home!

20-jun-2024:

Got the SM driven cursor frame buffer reads to work. Cursor is now buttery
smooth. Nice! Keay was to put reads well after v front porch, and to
put a line of blanking between each fb read. Downside is that the dma
command list is twice as long...

21-jun-2024:

Build rev 1.5 board, booted uMIPs successfully. Next rev should add
a second usb-c PCB connector for power.

Started building rev 2.1. Can't get PSRAM to work, even after repeated
re-flows. Problems with digikey parts list:
1) 470 pf is 201 not 603
2) No 12.1 k bias resistor
3) Wrong package for PSRAM
4) No 330 ohm resistor
5) No 10 ohm resistor

Sigh. Turns out that fb_mem_test doesn't get past init when running from
flash. To be debugged. Running mem_test from flash works fine. Flashing
rev 2.1 with mem_test shows that the PSRAM was installed correctly.
Thus preserving my unbroken record of successfully soldering BGA parts :-)

Oh, and the USB-A connector does not work as a slave port. To be tested if
it'll work as a host port. Fortunately, I'd brought out the micro USB
data pins as test points. A quick couple of bodge wires, and was on the
air.

22-jun-2024:

Finished building rev 2.1, booted uMIPS successfully. The USB A port does
work as a host port.

Tried out the Ethernet port, but saw lots of packet drops when the board
is pinged. Perhaps the substitution of 12K instead of 12.1K for the bias
resistor? Or other tuning - the lan8742 check list suggests 10 ohms for
tx0, 1, en termination resistors as a starting point. Or the clock termination
resistor.

Looking at rev 2.1 on the hp 2035 monitor, the video quality is very good.
No noise or ringing, just nice sharp pixels.
